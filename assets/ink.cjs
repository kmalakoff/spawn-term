"use strict";

var IntlSegmenter = typeof Intl === 'undefined' || !Intl.Segmenter ? require('./intl-adapter.cjs').Segmenter : Intl.Segmenter;
var globalThis = global;

var _waiting = [];
var _isReady = false;
function _notifyInitialized() {
  _isReady = true;
  _waiting.slice(0).forEach(function (fn) { fn(); })
}
exports.initialize = function _initialize(fn) {
  _isReady ? fn() : _waiting.push(fn);
  return;
}
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Box () {
        return Box;
    },
    get Newline () {
        return Newline;
    },
    get Spacer () {
        return Spacer;
    },
    get Static () {
        return Static;
    },
    get Text () {
        return Text;
    },
    get Transform () {
        return Transform;
    },
    get measureElement () {
        return measureElement;
    },
    get render () {
        return render;
    },
    get useApp () {
        return useApp;
    },
    get useFocus () {
        return useFocus;
    },
    get useFocusManager () {
        return useFocusManager;
    },
    get useInput () {
        return useInput;
    },
    get useStderr () {
        return useStderr;
    },
    get useStdin () {
        return useStdin;
    },
    get useStdout () {
        return useStdout;
    }
});
var _stream = require("stream");
var _process = /*#__PURE__*/ _interop_require_wildcard(require("process"));
var _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
var _assert = /*#__PURE__*/ _interop_require_default(require("assert"));
var _events = /*#__PURE__*/ _interop_require_wildcard(require("events"));
var _fs = /*#__PURE__*/ _interop_require_wildcard(require("fs"));
var _module = /*#__PURE__*/ _interop_require_default(require("module"));
var _buffer = require("buffer");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self1) {
    if (self1 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self1;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _possible_constructor_return(self1, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self1);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var _globalThis_window, _globalThis_process_versions, _globalThis_process, _globalThis_process_versions1, _globalThis_process1, _globalThis_Deno_version, _globalThis_Deno, _globalThis_process_versions2, _globalThis_process2, _globalThis_navigator_userAgent, _globalThis_navigator, _globalThis_navigator_userAgentData, _globalThis_navigator1, _globalThis_navigator2, _globalThis_navigator_userAgent1, _globalThis_navigator3, _globalThis_process3, _globalThis_navigator4, _globalThis_process4, _globalThis_navigator_platform, _globalThis_navigator5, _globalThis_navigator_userAgent2, _globalThis_navigator6, _globalThis_process5, _globalThis_navigator7, _globalThis_navigator_userAgent3, _globalThis_navigator8, _globalThis_process6;
function debounce$1(func, debounceMs) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, signal = _ref.signal, edges = _ref.edges;
    var pendingThis = undefined;
    var pendingArgs = null;
    var leading = edges != null && edges.includes('leading');
    var trailing = edges == null || edges.includes('trailing');
    var invoke = function() {
        if (pendingArgs !== null) {
            func.apply(pendingThis, pendingArgs);
            pendingThis = undefined;
            pendingArgs = null;
        }
    };
    var onTimerEnd = function() {
        if (trailing) {
            invoke();
        }
        cancel();
    };
    var timeoutId = null;
    var schedule = function() {
        if (timeoutId != null) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(function() {
            timeoutId = null;
            onTimerEnd();
        }, debounceMs);
    };
    var cancelTimer = function() {
        if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
    };
    var cancel = function() {
        cancelTimer();
        pendingThis = undefined;
        pendingArgs = null;
    };
    var flush = function() {
        cancelTimer();
        invoke();
    };
    var debounced = function debounced() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            return;
        }
        pendingThis = this;
        pendingArgs = args;
        var isFirstCall = timeoutId == null;
        schedule();
        if (leading && isFirstCall) {
            invoke();
        }
    };
    debounced.schedule = schedule;
    debounced.cancel = cancel;
    debounced.flush = flush;
    signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', cancel, {
        once: true
    });
    return debounced;
}
function debounce(func) {
    var debounceMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if ((typeof options === "undefined" ? "undefined" : _type_of(options)) !== 'object') {
        options = {};
    }
    var signal = options.signal, _options_leading = options.leading, leading = _options_leading === void 0 ? false : _options_leading, _options_trailing = options.trailing, trailing = _options_trailing === void 0 ? true : _options_trailing, maxWait = options.maxWait;
    var edges = Array(2);
    if (leading) {
        edges[0] = 'leading';
    }
    if (trailing) {
        edges[1] = 'trailing';
    }
    var result = undefined;
    var pendingAt = null;
    var _debounced = debounce$1(function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        result = func.apply(this, args);
        pendingAt = null;
    }, debounceMs, {
        signal: signal,
        edges: edges
    });
    var debounced = function debounced() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (maxWait != null) {
            if (pendingAt === null) {
                pendingAt = Date.now();
            }
            if (Date.now() - pendingAt >= maxWait) {
                result = func.apply(this, args);
                pendingAt = Date.now();
                _debounced.cancel();
                _debounced.schedule();
                return result;
            }
        }
        _debounced.apply(this, args);
        return result;
    };
    var flush = function() {
        _debounced.flush();
        return result;
    };
    debounced.cancel = _debounced.cancel;
    debounced.flush = flush;
    return debounced;
}
function throttle(func) {
    var throttleMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if ((typeof options === "undefined" ? "undefined" : _type_of(options)) !== 'object') {
        options = {};
    }
    var _options_leading = options.leading, leading = _options_leading === void 0 ? true : _options_leading, _options_trailing = options.trailing, trailing = _options_trailing === void 0 ? true : _options_trailing, signal = options.signal;
    return debounce(func, throttleMs, {
        leading: leading,
        trailing: trailing,
        signal: signal,
        maxWait: throttleMs
    });
}
/* globals WorkerGlobalScope, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope */ var isBrowser = ((_globalThis_window = globalThis.window) === null || _globalThis_window === void 0 ? void 0 : _globalThis_window.document) !== undefined;
((_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 ? void 0 : (_globalThis_process_versions = _globalThis_process.versions) === null || _globalThis_process_versions === void 0 ? void 0 : _globalThis_process_versions.node) !== undefined;
((_globalThis_process1 = globalThis.process) === null || _globalThis_process1 === void 0 ? void 0 : (_globalThis_process_versions1 = _globalThis_process1.versions) === null || _globalThis_process_versions1 === void 0 ? void 0 : _globalThis_process_versions1.bun) !== undefined;
((_globalThis_Deno = globalThis.Deno) === null || _globalThis_Deno === void 0 ? void 0 : (_globalThis_Deno_version = _globalThis_Deno.version) === null || _globalThis_Deno_version === void 0 ? void 0 : _globalThis_Deno_version.deno) !== undefined;
((_globalThis_process2 = globalThis.process) === null || _globalThis_process2 === void 0 ? void 0 : (_globalThis_process_versions2 = _globalThis_process2.versions) === null || _globalThis_process_versions2 === void 0 ? void 0 : _globalThis_process_versions2.electron) !== undefined;
((_globalThis_navigator = globalThis.navigator) === null || _globalThis_navigator === void 0 ? void 0 : (_globalThis_navigator_userAgent = _globalThis_navigator.userAgent) === null || _globalThis_navigator_userAgent === void 0 ? void 0 : _globalThis_navigator_userAgent.includes('jsdom')) === true;
typeof WorkerGlobalScope !== 'undefined' && _instanceof(globalThis, WorkerGlobalScope);
typeof DedicatedWorkerGlobalScope !== 'undefined' && _instanceof(globalThis, DedicatedWorkerGlobalScope);
typeof SharedWorkerGlobalScope !== 'undefined' && _instanceof(globalThis, SharedWorkerGlobalScope);
typeof ServiceWorkerGlobalScope !== 'undefined' && _instanceof(globalThis, ServiceWorkerGlobalScope);
// Note: I'm intentionally not DRYing up the other variables to keep them "lazy".
var platform = (_globalThis_navigator1 = globalThis.navigator) === null || _globalThis_navigator1 === void 0 ? void 0 : (_globalThis_navigator_userAgentData = _globalThis_navigator1.userAgentData) === null || _globalThis_navigator_userAgentData === void 0 ? void 0 : _globalThis_navigator_userAgentData.platform;
platform === 'macOS' || ((_globalThis_navigator2 = globalThis.navigator) === null || _globalThis_navigator2 === void 0 ? void 0 : _globalThis_navigator2.platform) === 'MacIntel' // Even on Apple silicon Macs.
 || ((_globalThis_navigator3 = globalThis.navigator) === null || _globalThis_navigator3 === void 0 ? void 0 : (_globalThis_navigator_userAgent1 = _globalThis_navigator3.userAgent) === null || _globalThis_navigator_userAgent1 === void 0 ? void 0 : _globalThis_navigator_userAgent1.includes(' Mac ')) === true || ((_globalThis_process3 = globalThis.process) === null || _globalThis_process3 === void 0 ? void 0 : _globalThis_process3.platform) === 'darwin';
platform === 'Windows' || ((_globalThis_navigator4 = globalThis.navigator) === null || _globalThis_navigator4 === void 0 ? void 0 : _globalThis_navigator4.platform) === 'Win32' || ((_globalThis_process4 = globalThis.process) === null || _globalThis_process4 === void 0 ? void 0 : _globalThis_process4.platform) === 'win32';
platform === 'Linux' || ((_globalThis_navigator5 = globalThis.navigator) === null || _globalThis_navigator5 === void 0 ? void 0 : (_globalThis_navigator_platform = _globalThis_navigator5.platform) === null || _globalThis_navigator_platform === void 0 ? void 0 : _globalThis_navigator_platform.startsWith('Linux')) === true || ((_globalThis_navigator6 = globalThis.navigator) === null || _globalThis_navigator6 === void 0 ? void 0 : (_globalThis_navigator_userAgent2 = _globalThis_navigator6.userAgent) === null || _globalThis_navigator_userAgent2 === void 0 ? void 0 : _globalThis_navigator_userAgent2.includes(' Linux ')) === true || ((_globalThis_process5 = globalThis.process) === null || _globalThis_process5 === void 0 ? void 0 : _globalThis_process5.platform) === 'linux';
platform === 'Android' || ((_globalThis_navigator7 = globalThis.navigator) === null || _globalThis_navigator7 === void 0 ? void 0 : _globalThis_navigator7.platform) === 'Android' || ((_globalThis_navigator8 = globalThis.navigator) === null || _globalThis_navigator8 === void 0 ? void 0 : (_globalThis_navigator_userAgent3 = _globalThis_navigator8.userAgent) === null || _globalThis_navigator_userAgent3 === void 0 ? void 0 : _globalThis_navigator_userAgent3.includes(' Android ')) === true || ((_globalThis_process6 = globalThis.process) === null || _globalThis_process6 === void 0 ? void 0 : _globalThis_process6.platform) === 'android';
var ESC = '\u001B[';
!isBrowser && _process.default.env.TERM_PROGRAM === 'Apple_Terminal';
var isWindows = !isBrowser && _process.default.platform === 'win32';
isBrowser ? function() {
    throw new Error('`process.cwd()` only works in Node.js, not the browser.');
} : _process.default.cwd;
var cursorUp = function() {
    var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return ESC + count + 'A';
};
var cursorLeft = ESC + 'G';
var eraseLines = function(count) {
    var clear = '';
    for(var i = 0; i < count; i++){
        clear += eraseLine + (i < count - 1 ? cursorUp() : '');
    }
    if (count) {
        clear += cursorLeft;
    }
    return clear;
};
var eraseLine = ESC + '2K';
var eraseScreen = ESC + '2J';
var clearTerminal = isWindows ? "".concat(eraseScreen).concat(ESC, "0f") : "".concat(eraseScreen).concat(ESC, "3J").concat(ESC, "H");
var isInCi = _process.env.CI !== '0' && _process.env.CI !== 'false' && ('CI' in _process.env || 'CONTINUOUS_INTEGRATION' in _process.env || Object.keys(_process.env).some(function(key) {
    return key.startsWith('CI_');
}));
// Gets all non-builtin properties up the prototype chain.
var getAllProperties = function(object) {
    var properties = new Set();
    do {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Reflect.ownKeys(object)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var key = _step.value;
                properties.add([
                    object,
                    key
                ]);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
    return properties;
};
function autoBind(self1) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, include = _ref.include, exclude = _ref.exclude;
    var filter = function(key) {
        var match = function(pattern) {
            return typeof pattern === 'string' ? key === pattern : pattern.test(key);
        };
        if (include) {
            return include.some(match); // eslint-disable-line unicorn/no-array-callback-reference
        }
        if (exclude) {
            return !exclude.some(match); // eslint-disable-line unicorn/no-array-callback-reference
        }
        return true;
    };
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = getAllProperties(self1.constructor.prototype)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), object = _step_value[0], key = _step_value[1];
            if (key === 'constructor' || !filter(key)) {
                continue;
            }
            var descriptor = Reflect.getOwnPropertyDescriptor(object, key);
            if (descriptor && typeof descriptor.value === 'function') {
                self1[key] = self1[key].bind(self1);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return self1;
}
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var signalExit$1 = {
    exports: {}
};
var signals = {
    exports: {}
};
var hasRequiredSignals;
function requireSignals() {
    if (hasRequiredSignals) return signals.exports;
    hasRequiredSignals = 1;
    (function(module) {
        // This is not the set of all possible signals.
        //
        // It IS, however, the set of all signals that trigger
        // an exit on either Linux or BSD systems.  Linux is a
        // superset of the signal names supported on BSD, and
        // the unknown signals just fail to register, so we can
        // catch that easily enough.
        //
        // Don't bother with SIGKILL.  It's uncatchable, which
        // means that we can't fire any callbacks anyway.
        //
        // If a user does happen to register a handler on a non-
        // fatal signal like SIGWINCH or something, and then
        // exit, it'll end up firing `process.emit('exit')`, so
        // the handler will be fired anyway.
        //
        // SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
        // artificially, inherently leave the process in a
        // state from which it is not safe to try and enter JS
        // listeners.
        module.exports = [
            'SIGABRT',
            'SIGALRM',
            'SIGHUP',
            'SIGINT',
            'SIGTERM'
        ];
        if (process.platform !== 'win32') {
            module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
        }
        if (process.platform === 'linux') {
            module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');
        }
    })(signals);
    return signals.exports;
}
var hasRequiredSignalExit;
function requireSignalExit() {
    if (hasRequiredSignalExit) return signalExit$1.exports;
    hasRequiredSignalExit = 1;
    // Note: since nyc uses this module to output coverage, any lines
    // that are in the direct sync flow of nyc's outputCoverage are
    // ignored, since we can never get coverage for them.
    // grab a reference to node's real process object right away
    var process1 = commonjsGlobal.process;
    var processOk = function processOk(process1) {
        return process1 && (typeof process1 === "undefined" ? "undefined" : _type_of(process1)) === 'object' && typeof process1.removeListener === 'function' && typeof process1.emit === 'function' && typeof process1.reallyExit === 'function' && typeof process1.listeners === 'function' && typeof process1.kill === 'function' && typeof process1.pid === 'number' && typeof process1.on === 'function';
    };
    // some kind of non-node environment, just no-op
    /* istanbul ignore if */ if (!processOk(process1)) {
        signalExit$1.exports = function() {
            return function() {};
        };
    } else {
        var assert = _assert.default;
        var signals = requireSignals();
        var isWin = /^win/i.test(process1.platform);
        var EE = _events.default;
        /* istanbul ignore if */ if (typeof EE !== 'function') {
            EE = EE.EventEmitter;
        }
        var emitter;
        if (process1.__signal_exit_emitter__) {
            emitter = process1.__signal_exit_emitter__;
        } else {
            emitter = process1.__signal_exit_emitter__ = new EE();
            emitter.count = 0;
            emitter.emitted = {};
        }
        // Because this emitter is a global, we have to check to see if a
        // previous version of this library failed to enable infinite listeners.
        // I know what you're about to say.  But literally everything about
        // signal-exit is a compromise with evil.  Get used to it.
        if (!emitter.infinite) {
            emitter.setMaxListeners(Infinity);
            emitter.infinite = true;
        }
        signalExit$1.exports = function(cb, opts) {
            /* istanbul ignore if */ if (!processOk(commonjsGlobal.process)) {
                return function() {};
            }
            assert.equal(typeof cb === "undefined" ? "undefined" : _type_of(cb), 'function', 'a callback must be provided for exit handler');
            if (loaded === false) {
                load();
            }
            var ev = 'exit';
            if (opts && opts.alwaysLast) {
                ev = 'afterexit';
            }
            var remove = function remove() {
                emitter.removeListener(ev, cb);
                if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {
                    unload();
                }
            };
            emitter.on(ev, cb);
            return remove;
        };
        var unload = function unload() {
            if (!loaded || !processOk(commonjsGlobal.process)) {
                return;
            }
            loaded = false;
            signals.forEach(function(sig) {
                try {
                    process1.removeListener(sig, sigListeners[sig]);
                } catch (er) {}
            });
            process1.emit = originalProcessEmit;
            process1.reallyExit = originalProcessReallyExit;
            emitter.count -= 1;
        };
        signalExit$1.exports.unload = unload;
        var emit = function emit(event, code, signal) {
            /* istanbul ignore if */ if (emitter.emitted[event]) {
                return;
            }
            emitter.emitted[event] = true;
            emitter.emit(event, code, signal);
        };
        // { <signal>: <listener fn>, ... }
        var sigListeners = {};
        signals.forEach(function(sig) {
            sigListeners[sig] = function listener() {
                /* istanbul ignore if */ if (!processOk(commonjsGlobal.process)) {
                    return;
                }
                // If there are no other listeners, an exit is coming!
                // Simplest way: remove us and then re-send the signal.
                // We know that this will kill the process, so we can
                // safely emit now.
                var listeners = process1.listeners(sig);
                if (listeners.length === emitter.count) {
                    unload();
                    emit('exit', null, sig);
                    /* istanbul ignore next */ emit('afterexit', null, sig);
                    /* istanbul ignore next */ if (isWin && sig === 'SIGHUP') {
                        // "SIGHUP" throws an `ENOSYS` error on Windows,
                        // so use a supported signal instead
                        sig = 'SIGINT';
                    }
                    /* istanbul ignore next */ process1.kill(process1.pid, sig);
                }
            };
        });
        signalExit$1.exports.signals = function() {
            return signals;
        };
        var loaded = false;
        var load = function load() {
            if (loaded || !processOk(commonjsGlobal.process)) {
                return;
            }
            loaded = true;
            // This is the number of onSignalExit's that are in play.
            // It's important so that we can count the correct number of
            // listeners on signals, and don't wait for the other one to
            // handle it instead of us.
            emitter.count += 1;
            signals = signals.filter(function(sig) {
                try {
                    process1.on(sig, sigListeners[sig]);
                    return true;
                } catch (er) {
                    return false;
                }
            });
            process1.emit = processEmit;
            process1.reallyExit = processReallyExit;
        };
        signalExit$1.exports.load = load;
        var originalProcessReallyExit = process1.reallyExit;
        var processReallyExit = function processReallyExit(code) {
            /* istanbul ignore if */ if (!processOk(commonjsGlobal.process)) {
                return;
            }
            process1.exitCode = code || /* istanbul ignore next */ 0;
            emit('exit', process1.exitCode, null);
            /* istanbul ignore next */ emit('afterexit', process1.exitCode, null);
            /* istanbul ignore next */ originalProcessReallyExit.call(process1, process1.exitCode);
        };
        var originalProcessEmit = process1.emit;
        var processEmit = function processEmit(ev, arg) {
            if (ev === 'exit' && processOk(commonjsGlobal.process)) {
                /* istanbul ignore else */ if (arg !== undefined) {
                    process1.exitCode = arg;
                }
                var ret = originalProcessEmit.apply(this, arguments);
                /* istanbul ignore next */ emit('exit', process1.exitCode, null);
                /* istanbul ignore next */ emit('afterexit', process1.exitCode, null);
                /* istanbul ignore next */ return ret;
            } else {
                return originalProcessEmit.apply(this, arguments);
            }
        };
    }
    return signalExit$1.exports;
}
var signalExitExports = requireSignalExit();
var signalExit = /*@__PURE__*/ getDefaultExportFromCjs(signalExitExports);
var consoleMethods = [
    'assert',
    'count',
    'countReset',
    'debug',
    'dir',
    'dirxml',
    'error',
    'group',
    'groupCollapsed',
    'groupEnd',
    'info',
    'log',
    'table',
    'time',
    'timeEnd',
    'timeLog',
    'trace',
    'warn'
];
var originalMethods = {};
var patchConsole = function(callback) {
    var stdout = new _stream.PassThrough();
    var stderr = new _stream.PassThrough();
    stdout.write = function(data) {
        callback('stdout', data);
    };
    stderr.write = function(data) {
        callback('stderr', data);
    };
    var internalConsole = new console.Console(stdout, stderr);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = consoleMethods[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var method = _step.value;
            originalMethods[method] = console[method];
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            console[method] = internalConsole[method];
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return function() {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = consoleMethods[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var method = _step.value;
                console[method] = originalMethods[method];
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        originalMethods = {};
    };
};
var loadYoga = function() {
    var _scriptDir = require("url").pathToFileURL(__filename).toString();
    return function(loadYoga) {
        loadYoga = loadYoga || {};
        var h;
        h || (h = typeof loadYoga !== 'undefined' ? loadYoga : {});
        var aa, ca;
        h.ready = new Promise(function(a, b) {
            aa = a;
            ca = b;
        });
        var da = Object.assign({}, h), q = "";
        "undefined" != typeof document && document.currentScript && (q = document.currentScript.src);
        _scriptDir && (q = _scriptDir);
        0 !== q.indexOf("blob:") ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
        var ea = h.print || console.log.bind(console), v = h.printErr || console.warn.bind(console);
        Object.assign(h, da);
        da = null;
        var w;
        h.wasmBinary && (w = h.wasmBinary);
        h.noExitRuntime || true;
        "object" != (typeof WebAssembly === "undefined" ? "undefined" : _type_of(WebAssembly)) && x("no native wasm support detected");
        var fa, ha = false;
        function z(a, b, c) {
            c = b + c;
            for(var d = ""; !(b >= c);){
                var e = a[b++];
                if (!e) break;
                if (e & 128) {
                    var f = a[b++] & 63;
                    if (192 == (e & 224)) d += String.fromCharCode((e & 31) << 6 | f);
                    else {
                        var g = a[b++] & 63;
                        e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | g : (e & 7) << 18 | f << 12 | g << 6 | a[b++] & 63;
                        65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
                    }
                } else d += String.fromCharCode(e);
            }
            return d;
        }
        var ia, ja, A, C, ka, D, E, la, ma;
        function na() {
            var a = fa.buffer;
            ia = a;
            h.HEAP8 = ja = new Int8Array(a);
            h.HEAP16 = C = new Int16Array(a);
            h.HEAP32 = D = new Int32Array(a);
            h.HEAPU8 = A = new Uint8Array(a);
            h.HEAPU16 = ka = new Uint16Array(a);
            h.HEAPU32 = E = new Uint32Array(a);
            h.HEAPF32 = la = new Float32Array(a);
            h.HEAPF64 = ma = new Float64Array(a);
        }
        var oa, pa = [], qa = [], ra = [];
        function sa() {
            var a = h.preRun.shift();
            pa.unshift(a);
        }
        var F = 0, G = null;
        function x(a) {
            if (h.onAbort) h.onAbort(a);
            a = "Aborted(" + a + ")";
            v(a);
            ha = true;
            a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
            ca(a);
            throw a;
        }
        function ua(a) {
            return a.startsWith("data:application/octet-stream;base64,");
        }
        var H;
        H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAE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GiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMk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AWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAH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IQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAF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ASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIA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AkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVk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";
        if (!ua(H)) {
            var va = H;
            H = h.locateFile ? h.locateFile(va, q) : q + va;
        }
        function wa() {
            var a = H;
            try {
                if (a == H && w) return new Uint8Array(w);
                if (ua(a)) try {
                    var b = xa(a.slice(37)), c = new Uint8Array(b.length);
                    for(a = 0; a < b.length; ++a)c[a] = b.charCodeAt(a);
                    var d = c;
                } catch (f) {
                    throw Error("Converting base64 string to bytes failed.");
                }
                else d = void 0;
                var e = d;
                if (e) return e;
                throw "both async and sync fetching of the wasm failed";
            } catch (f) {
                x(f);
            }
        }
        function ya() {
            return w || "function" != typeof fetch ? Promise.resolve().then(function() {
                return wa();
            }) : fetch(H, {
                credentials: "same-origin"
            }).then(function(a) {
                if (!a.ok) throw "failed to load wasm binary file at '" + H + "'";
                return a.arrayBuffer();
            }).catch(function() {
                return wa();
            });
        }
        function za(a) {
            for(; 0 < a.length;)a.shift()(h);
        }
        function Aa(a) {
            if (void 0 === a) return "_unknown";
            a = a.replace(/[^a-zA-Z0-9_]/g, "$");
            var b = a.charCodeAt(0);
            return 48 <= b && 57 >= b ? "_" + a : a;
        }
        function Ba(a, b) {
            a = Aa(a);
            return function() {
                return b.apply(this, arguments);
            };
        }
        var J = [
            {},
            {
                value: void 0
            },
            {
                value: null
            },
            {
                value: true
            },
            {
                value: false
            }
        ], Ca = [];
        function Da(a) {
            var b = Error, c = Ba(a, function(d) {
                this.name = a;
                this.message = d;
                d = Error(d).stack;
                void 0 !== d && (this.stack = this.toString() + "\n" + d.replace(/^Error(:[^\n]*)?\n/, ""));
            });
            c.prototype = Object.create(b.prototype);
            c.prototype.constructor = c;
            c.prototype.toString = function() {
                return void 0 === this.message ? this.name : this.name + ": " + this.message;
            };
            return c;
        }
        var K = void 0;
        function L(a) {
            throw new K(a);
        }
        var M = function(a) {
            a || L("Cannot use deleted val. handle = " + a);
            return J[a].value;
        }, Ea = function(a) {
            switch(a){
                case void 0:
                    return 1;
                case null:
                    return 2;
                case true:
                    return 3;
                case false:
                    return 4;
                default:
                    var b = Ca.length ? Ca.pop() : J.length;
                    J[b] = {
                        ga: 1,
                        value: a
                    };
                    return b;
            }
        }, Fa = void 0, Ga = void 0;
        function N(a) {
            for(var b = ""; A[a];)b += Ga[A[a++]];
            return b;
        }
        var O = [];
        function Ha() {
            for(; O.length;){
                var a = O.pop();
                a.M.$ = false;
                a["delete"]();
            }
        }
        var P = void 0, Q = {};
        function Ia(a, b) {
            for(void 0 === b && L("ptr should not be undefined"); a.R;)b = a.ba(b), a = a.R;
            return b;
        }
        var R = {};
        function Ja(a) {
            a = Ka(a);
            var b = N(a);
            S(a);
            return b;
        }
        function La(a, b) {
            var c = R[a];
            void 0 === c && L(b + " has unknown type " + Ja(a));
            return c;
        }
        function Ma() {}
        var Na = false;
        function Oa(a) {
            --a.count.value;
            0 === a.count.value && (a.T ? a.U.W(a.T) : a.P.N.W(a.O));
        }
        function Pa(a, b, c) {
            if (b === c) return a;
            if (void 0 === c.R) return null;
            a = Pa(a, b, c.R);
            return null === a ? null : c.na(a);
        }
        var Qa = {};
        function Ra(a, b) {
            b = Ia(a, b);
            return Q[b];
        }
        var Sa = void 0;
        function Ta(a) {
            throw new Sa(a);
        }
        function Ua(a, b) {
            b.P && b.O || Ta("makeClassHandle requires ptr and ptrType");
            !!b.U !== !!b.T && Ta("Both smartPtrType and smartPtr must be specified");
            b.count = {
                value: 1
            };
            return T(Object.create(a, {
                M: {
                    value: b
                }
            }));
        }
        function T(a) {
            if ("undefined" === typeof FinalizationRegistry) return T = function(b) {
                return b;
            }, a;
            Na = new FinalizationRegistry(function(b) {
                Oa(b.M);
            });
            T = function(b) {
                var c = b.M;
                c.T && Na.register(b, {
                    M: c
                }, b);
                return b;
            };
            Ma = function(b) {
                Na.unregister(b);
            };
            return T(a);
        }
        var Va = {};
        function Wa(a) {
            for(; a.length;){
                var b = a.pop();
                a.pop()(b);
            }
        }
        function Xa(a) {
            return this.fromWireType(D[a >> 2]);
        }
        var U = {}, Ya = {};
        function V(a, b, c) {
            function d(k) {
                k = c(k);
                k.length !== a.length && Ta("Mismatched type converter count");
                for(var m = 0; m < a.length; ++m)W(a[m], k[m]);
            }
            a.forEach(function(k) {
                Ya[k] = b;
            });
            var e = Array(b.length), f = [], g = 0;
            b.forEach(function(k, m) {
                R.hasOwnProperty(k) ? e[m] = R[k] : (f.push(k), U.hasOwnProperty(k) || (U[k] = []), U[k].push(function() {
                    e[m] = R[k];
                    ++g;
                    g === f.length && d(e);
                }));
            });
            0 === f.length && d(e);
        }
        function Za(a) {
            switch(a){
                case 1:
                    return 0;
                case 2:
                    return 1;
                case 4:
                    return 2;
                case 8:
                    return 3;
                default:
                    throw new TypeError("Unknown type size: " + a);
            }
        }
        function W(a, b) {
            var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!("argPackAdvance" in b)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
            var d = b.name;
            a || L('type "' + d + '" must have a positive integer typeid pointer');
            if (R.hasOwnProperty(a)) {
                if (c.ua) return;
                L("Cannot register type '" + d + "' twice");
            }
            R[a] = b;
            delete Ya[a];
            U.hasOwnProperty(a) && (b = U[a], delete U[a], b.forEach(function(e) {
                return e();
            }));
        }
        function $a(a) {
            L(a.M.P.N.name + " instance already deleted");
        }
        function X() {}
        function ab(a, b, c) {
            if (void 0 === a[b].S) {
                var d = a[b];
                a[b] = function() {
                    a[b].S.hasOwnProperty(arguments.length) || L("Function '" + c + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].S + ")!");
                    return a[b].S[arguments.length].apply(this, arguments);
                };
                a[b].S = [];
                a[b].S[d.Z] = d;
            }
        }
        function bb(a, b) {
            h.hasOwnProperty(a) ? (L("Cannot register public name '" + a + "' twice"), ab(h, a, a), h.hasOwnProperty(void 0) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h[a].S[void 0] = b) : h[a] = b;
        }
        function cb(a, b, c, d, e, f, g, k) {
            this.name = a;
            this.constructor = b;
            this.X = c;
            this.W = d;
            this.R = e;
            this.pa = f;
            this.ba = g;
            this.na = k;
            this.ja = [];
        }
        function db(a, b, c) {
            for(; b !== c;)b.ba || L("Expected null or instance of " + c.name + ", got an instance of " + b.name), a = b.ba(a), b = b.R;
            return a;
        }
        function eb(a, b) {
            if (null === b) return this.ea && L("null is not a valid " + this.name), 0;
            b.M || L('Cannot pass "' + fb(b) + '" as a ' + this.name);
            b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
            return db(b.M.O, b.M.P.N, this.N);
        }
        function gb(a, b) {
            if (null === b) {
                this.ea && L("null is not a valid " + this.name);
                if (this.da) {
                    var c = this.fa();
                    null !== a && a.push(this.W, c);
                    return c;
                }
                return 0;
            }
            b.M || L('Cannot pass "' + fb(b) + '" as a ' + this.name);
            b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
            !this.ca && b.M.P.ca && L("Cannot convert argument of type " + (b.M.U ? b.M.U.name : b.M.P.name) + " to parameter type " + this.name);
            c = db(b.M.O, b.M.P.N, this.N);
            if (this.da) switch(void 0 === b.M.T && L("Passing raw pointer to smart pointer is illegal"), this.Ba){
                case 0:
                    b.M.U === this ? c = b.M.T : L("Cannot convert argument of type " + (b.M.U ? b.M.U.name : b.M.P.name) + " to parameter type " + this.name);
                    break;
                case 1:
                    c = b.M.T;
                    break;
                case 2:
                    if (b.M.U === this) c = b.M.T;
                    else {
                        var d = b.clone();
                        c = this.xa(c, Ea(function() {
                            d["delete"]();
                        }));
                        null !== a && a.push(this.W, c);
                    }
                    break;
                default:
                    L("Unsupporting sharing policy");
            }
            return c;
        }
        function hb(a, b) {
            if (null === b) return this.ea && L("null is not a valid " + this.name), 0;
            b.M || L('Cannot pass "' + fb(b) + '" as a ' + this.name);
            b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
            b.M.P.ca && L("Cannot convert argument of type " + b.M.P.name + " to parameter type " + this.name);
            return db(b.M.O, b.M.P.N, this.N);
        }
        function Y(a, b, c, d) {
            this.name = a;
            this.N = b;
            this.ea = c;
            this.ca = d;
            this.da = false;
            this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
            void 0 !== b.R ? this.toWireType = gb : (this.toWireType = d ? eb : hb, this.V = null);
        }
        function ib(a, b) {
            h.hasOwnProperty(a) || Ta("Replacing nonexistant public symbol");
            h[a] = b;
            h[a].Z = void 0;
        }
        function jb(a, b) {
            var c = [];
            return function() {
                c.length = 0;
                Object.assign(c, arguments);
                if (a.includes("j")) {
                    var d = h["dynCall_" + a];
                    d = c && c.length ? d.apply(null, [
                        b
                    ].concat(c)) : d.call(null, b);
                } else d = oa.get(b).apply(null, c);
                return d;
            };
        }
        function Z(a, b) {
            a = N(a);
            var c = a.includes("j") ? jb(a, b) : oa.get(b);
            "function" != typeof c && L("unknown function pointer with signature " + a + ": " + b);
            return c;
        }
        var mb = void 0;
        function nb(a, b) {
            function c(f) {
                e[f] || R[f] || (Ya[f] ? Ya[f].forEach(c) : (d.push(f), e[f] = true));
            }
            var d = [], e = {};
            b.forEach(c);
            throw new mb(a + ": " + d.map(Ja).join([
                ", "
            ]));
        }
        function ob(a, b, c, d, e) {
            var f = b.length;
            2 > f && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
            var g = null !== b[1] && null !== c, k = false;
            for(c = 1; c < b.length; ++c)if (null !== b[c] && void 0 === b[c].V) {
                k = true;
                break;
            }
            var m = "void" !== b[0].name, l = f - 2, n = Array(l), p = [], r = [];
            return function() {
                arguments.length !== l && L("function " + a + " called with " + arguments.length + " arguments, expected " + l + " args!");
                r.length = 0;
                p.length = g ? 2 : 1;
                p[0] = e;
                if (g) {
                    var u = b[1].toWireType(r, this);
                    p[1] = u;
                }
                for(var t = 0; t < l; ++t)n[t] = b[t + 2].toWireType(r, arguments[t]), p.push(n[t]);
                t = d.apply(null, p);
                if (k) Wa(r);
                else for(var y = g ? 1 : 2; y < b.length; y++){
                    var B = 1 === y ? u : n[y - 2];
                    null !== b[y].V && b[y].V(B);
                }
                u = m ? b[0].fromWireType(t) : void 0;
                return u;
            };
        }
        function pb(a, b) {
            for(var c = [], d = 0; d < a; d++)c.push(E[b + 4 * d >> 2]);
            return c;
        }
        function qb(a) {
            4 < a && 0 === --J[a].ga && (J[a] = void 0, Ca.push(a));
        }
        function fb(a) {
            if (null === a) return "null";
            var b = typeof a === "undefined" ? "undefined" : _type_of(a);
            return "object" === b || "array" === b || "function" === b ? a.toString() : "" + a;
        }
        function rb(a, b) {
            switch(b){
                case 2:
                    return function(c) {
                        return this.fromWireType(la[c >> 2]);
                    };
                case 3:
                    return function(c) {
                        return this.fromWireType(ma[c >> 3]);
                    };
                default:
                    throw new TypeError("Unknown float type: " + a);
            }
        }
        function sb(a, b, c) {
            switch(b){
                case 0:
                    return c ? function(d) {
                        return ja[d];
                    } : function(d) {
                        return A[d];
                    };
                case 1:
                    return c ? function(d) {
                        return C[d >> 1];
                    } : function(d) {
                        return ka[d >> 1];
                    };
                case 2:
                    return c ? function(d) {
                        return D[d >> 2];
                    } : function(d) {
                        return E[d >> 2];
                    };
                default:
                    throw new TypeError("Unknown integer type: " + a);
            }
        }
        function tb(a, b) {
            for(var c = "", d = 0; !(d >= b / 2); ++d){
                var e = C[a + 2 * d >> 1];
                if (0 == e) break;
                c += String.fromCharCode(e);
            }
            return c;
        }
        function ub(a, b, c) {
            void 0 === c && (c = 2147483647);
            if (2 > c) return 0;
            c -= 2;
            var d = b;
            c = c < 2 * a.length ? c / 2 : a.length;
            for(var e = 0; e < c; ++e)C[b >> 1] = a.charCodeAt(e), b += 2;
            C[b >> 1] = 0;
            return b - d;
        }
        function vb(a) {
            return 2 * a.length;
        }
        function wb(a, b) {
            for(var c = 0, d = ""; !(c >= b / 4);){
                var e = D[a + 4 * c >> 2];
                if (0 == e) break;
                ++c;
                65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);
            }
            return d;
        }
        function xb(a, b, c) {
            void 0 === c && (c = 2147483647);
            if (4 > c) return 0;
            var d = b;
            c = d + c - 4;
            for(var e = 0; e < a.length; ++e){
                var f = a.charCodeAt(e);
                if (55296 <= f && 57343 >= f) {
                    var g = a.charCodeAt(++e);
                    f = 65536 + ((f & 1023) << 10) | g & 1023;
                }
                D[b >> 2] = f;
                b += 4;
                if (b + 4 > c) break;
            }
            D[b >> 2] = 0;
            return b - d;
        }
        function yb(a) {
            for(var b = 0, c = 0; c < a.length; ++c){
                var d = a.charCodeAt(c);
                55296 <= d && 57343 >= d && ++c;
                b += 4;
            }
            return b;
        }
        var zb = {};
        function Ab(a) {
            var b = zb[a];
            return void 0 === b ? N(a) : b;
        }
        var Bb = [];
        function Cb(a) {
            var b = Bb.length;
            Bb.push(a);
            return b;
        }
        function Db(a, b) {
            for(var c = Array(a), d = 0; d < a; ++d)c[d] = La(E[b + 4 * d >> 2], "parameter " + d);
            return c;
        }
        var Eb = [], Fb = [
            null,
            [],
            []
        ];
        K = h.BindingError = Da("BindingError");
        h.count_emval_handles = function() {
            for(var a = 0, b = 5; b < J.length; ++b)void 0 !== J[b] && ++a;
            return a;
        };
        h.get_first_emval = function() {
            for(var a = 5; a < J.length; ++a)if (void 0 !== J[a]) return J[a];
            return null;
        };
        Fa = h.PureVirtualError = Da("PureVirtualError");
        for(var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb)Gb[Hb] = String.fromCharCode(Hb);
        Ga = Gb;
        h.getInheritedInstanceCount = function() {
            return Object.keys(Q).length;
        };
        h.getLiveInheritedInstances = function() {
            var a = [], b;
            for(b in Q)Q.hasOwnProperty(b) && a.push(Q[b]);
            return a;
        };
        h.flushPendingDeletes = Ha;
        h.setDelayFunction = function(a) {
            P = a;
            O.length && P && P(Ha);
        };
        Sa = h.InternalError = Da("InternalError");
        X.prototype.isAliasOf = function(a) {
            if (!(_instanceof(this, X) && _instanceof(a, X))) return false;
            var b = this.M.P.N, c = this.M.O, d = a.M.P.N;
            for(a = a.M.O; b.R;)c = b.ba(c), b = b.R;
            for(; d.R;)a = d.ba(a), d = d.R;
            return b === d && c === a;
        };
        X.prototype.clone = function() {
            this.M.O || $a(this);
            if (this.M.aa) return this.M.count.value += 1, this;
            var a = T, b = Object, c = b.create, d = Object.getPrototypeOf(this), e = this.M;
            a = a(c.call(b, d, {
                M: {
                    value: {
                        count: e.count,
                        $: e.$,
                        aa: e.aa,
                        O: e.O,
                        P: e.P,
                        T: e.T,
                        U: e.U
                    }
                }
            }));
            a.M.count.value += 1;
            a.M.$ = false;
            return a;
        };
        X.prototype["delete"] = function() {
            this.M.O || $a(this);
            this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
            Ma(this);
            Oa(this.M);
            this.M.aa || (this.M.T = void 0, this.M.O = void 0);
        };
        X.prototype.isDeleted = function() {
            return !this.M.O;
        };
        X.prototype.deleteLater = function() {
            this.M.O || $a(this);
            this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
            O.push(this);
            1 === O.length && P && P(Ha);
            this.M.$ = true;
            return this;
        };
        Y.prototype.qa = function(a) {
            this.ka && (a = this.ka(a));
            return a;
        };
        Y.prototype.ha = function(a) {
            this.W && this.W(a);
        };
        Y.prototype.argPackAdvance = 8;
        Y.prototype.readValueFromPointer = Xa;
        Y.prototype.deleteObject = function(a) {
            if (null !== a) a["delete"]();
        };
        Y.prototype.fromWireType = function(a) {
            function b() {
                return this.da ? Ua(this.N.X, {
                    P: this.wa,
                    O: c,
                    U: this,
                    T: a
                }) : Ua(this.N.X, {
                    P: this,
                    O: a
                });
            }
            var c = this.qa(a);
            if (!c) return this.ha(a), null;
            var d = Ra(this.N, c);
            if (void 0 !== d) {
                if (0 === d.M.count.value) return d.M.O = c, d.M.T = a, d.clone();
                d = d.clone();
                this.ha(a);
                return d;
            }
            d = this.N.pa(c);
            d = Qa[d];
            if (!d) return b.call(this);
            d = this.ca ? d.la : d.pointerType;
            var e = Pa(c, this.N, d.N);
            return null === e ? b.call(this) : this.da ? Ua(d.N.X, {
                P: d,
                O: e,
                U: this,
                T: a
            }) : Ua(d.N.X, {
                P: d,
                O: e
            });
        };
        mb = h.UnboundTypeError = Da("UnboundTypeError");
        var xa = "function" == typeof atob ? atob : function xa(a) {
            var b = "", c = 0;
            a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
            do {
                var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
                var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
                var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
                var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
                d = d << 2 | e >> 4;
                e = (e & 15) << 4 | f >> 2;
                var k = (f & 3) << 6 | g;
                b += String.fromCharCode(d);
                64 !== f && (b += String.fromCharCode(e));
                64 !== g && (b += String.fromCharCode(k));
            }while (c < a.length);
            return b;
        }, Jb = {
            l: function l(a, b, c, d) {
                x("Assertion failed: " + (a ? z(A, a) : "") + ", at: " + [
                    b ? b ? z(A, b) : "" : "unknown filename",
                    c,
                    d ? d ? z(A, d) : "" : "unknown function"
                ]);
            },
            q: function q(a, b, c) {
                a = N(a);
                b = La(b, "wrapper");
                c = M(c);
                var d = [].slice, e = b.N, f = e.X, g = e.R.X, k = e.R.constructor;
                a = Ba(a, function() {
                    e.R.ja.forEach((function(l) {
                        if (this[l] === g[l]) throw new Fa("Pure virtual function " + l + " must be implemented in JavaScript");
                    }).bind(this));
                    Object.defineProperty(this, "__parent", {
                        value: f
                    });
                    this.__construct.apply(this, d.call(arguments));
                });
                f.__construct = function() {
                    this === f && L("Pass correct 'this' to __construct");
                    var l = k.implement.apply(void 0, [
                        this
                    ].concat(d.call(arguments)));
                    Ma(l);
                    var n = l.M;
                    l.notifyOnDestruction();
                    n.aa = true;
                    Object.defineProperties(this, {
                        M: {
                            value: n
                        }
                    });
                    T(this);
                    l = n.O;
                    l = Ia(e, l);
                    Q.hasOwnProperty(l) ? L("Tried to register registered instance: " + l) : Q[l] = this;
                };
                f.__destruct = function() {
                    this === f && L("Pass correct 'this' to __destruct");
                    Ma(this);
                    var l = this.M.O;
                    l = Ia(e, l);
                    Q.hasOwnProperty(l) ? delete Q[l] : L("Tried to unregister unregistered instance: " + l);
                };
                a.prototype = Object.create(f);
                for(var m in c)a.prototype[m] = c[m];
                return Ea(a);
            },
            j: function j(a) {
                var b = Va[a];
                delete Va[a];
                var c = b.fa, d = b.W, e = b.ia, f = e.map(function(g) {
                    return g.ta;
                }).concat(e.map(function(g) {
                    return g.za;
                }));
                V([
                    a
                ], f, function(g) {
                    var k = {};
                    e.forEach(function(m, l) {
                        var n = g[l], p = m.ra, r = m.sa, u = g[l + e.length], t = m.ya, y = m.Aa;
                        k[m.oa] = {
                            read: function(B) {
                                return n.fromWireType(p(r, B));
                            },
                            write: function(B, ba) {
                                var I = [];
                                t(y, B, u.toWireType(I, ba));
                                Wa(I);
                            }
                        };
                    });
                    return [
                        {
                            name: b.name,
                            fromWireType: function fromWireType(m) {
                                var l = {}, n;
                                for(n in k)l[n] = k[n].read(m);
                                d(m);
                                return l;
                            },
                            toWireType: function toWireType(m, l) {
                                for(var n in k)if (!(n in l)) throw new TypeError('Missing field:  "' + n + '"');
                                var p = c();
                                for(n in k)k[n].write(p, l[n]);
                                null !== m && m.push(d, p);
                                return p;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Xa,
                            V: d
                        }
                    ];
                });
            },
            v: function v() {},
            B: function B(a, b, c, d, e) {
                var f = Za(c);
                b = N(b);
                W(a, {
                    name: b,
                    fromWireType: function fromWireType(g) {
                        return !!g;
                    },
                    toWireType: function toWireType(g, k) {
                        return k ? d : e;
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: function readValueFromPointer(g) {
                        if (1 === c) var k = ja;
                        else if (2 === c) k = C;
                        else if (4 === c) k = D;
                        else throw new TypeError("Unknown boolean type size: " + b);
                        return this.fromWireType(k[g >> f]);
                    },
                    V: null
                });
            },
            f: function f(a, b, c, d, e, f, g, k, m, l, n, p, r) {
                n = N(n);
                f = Z(e, f);
                k && (k = Z(g, k));
                l && (l = Z(m, l));
                r = Z(p, r);
                var u = Aa(n);
                bb(u, function() {
                    nb("Cannot construct " + n + " due to unbound types", [
                        d
                    ]);
                });
                V([
                    a,
                    b,
                    c
                ], d ? [
                    d
                ] : [], function(t) {
                    t = t[0];
                    if (d) {
                        var y = t.N;
                        var B = y.X;
                    } else B = X.prototype;
                    t = Ba(u, function() {
                        if (Object.getPrototypeOf(this) !== ba) throw new K("Use 'new' to construct " + n);
                        if (void 0 === I.Y) throw new K(n + " has no accessible constructor");
                        var kb = I.Y[arguments.length];
                        if (void 0 === kb) throw new K("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
                        return kb.apply(this, arguments);
                    });
                    var ba = Object.create(B, {
                        constructor: {
                            value: t
                        }
                    });
                    t.prototype = ba;
                    var I = new cb(n, t, ba, r, y, f, k, l);
                    y = new Y(n, I, true, false);
                    B = new Y(n + "*", I, false, false);
                    var lb = new Y(n + " const*", I, false, true);
                    Qa[a] = {
                        pointerType: B,
                        la: lb
                    };
                    ib(u, t);
                    return [
                        y,
                        B,
                        lb
                    ];
                });
            },
            d: function d(a, b, c, d, e, f, g) {
                var k = pb(c, d);
                b = N(b);
                f = Z(e, f);
                V([], [
                    a
                ], function(m) {
                    function l() {
                        nb("Cannot call " + n + " due to unbound types", k);
                    }
                    m = m[0];
                    var n = m.name + "." + b;
                    b.startsWith("@@") && (b = Symbol[b.substring(2)]);
                    var p = m.N.constructor;
                    void 0 === p[b] ? (l.Z = c - 1, p[b] = l) : (ab(p, b, n), p[b].S[c - 1] = l);
                    V([], k, function(r) {
                        r = ob(n, [
                            r[0],
                            null
                        ].concat(r.slice(1)), null, f, g);
                        void 0 === p[b].S ? (r.Z = c - 1, p[b] = r) : p[b].S[c - 1] = r;
                        return [];
                    });
                    return [];
                });
            },
            p: function p(a, b, c, d, e, f) {
                0 < b || x();
                var g = pb(b, c);
                e = Z(d, e);
                V([], [
                    a
                ], function(k) {
                    k = k[0];
                    var m = "constructor " + k.name;
                    void 0 === k.N.Y && (k.N.Y = []);
                    if (void 0 !== k.N.Y[b - 1]) throw new K("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + k.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                    k.N.Y[b - 1] = function() {
                        nb("Cannot construct " + k.name + " due to unbound types", g);
                    };
                    V([], g, function(l) {
                        l.splice(1, 0, null);
                        k.N.Y[b - 1] = ob(m, l, null, e, f);
                        return [];
                    });
                    return [];
                });
            },
            a: function a(a, b, c, d, e, f, g, k) {
                var m = pb(c, d);
                b = N(b);
                f = Z(e, f);
                V([], [
                    a
                ], function(l) {
                    function n() {
                        nb("Cannot call " + p + " due to unbound types", m);
                    }
                    l = l[0];
                    var p = l.name + "." + b;
                    b.startsWith("@@") && (b = Symbol[b.substring(2)]);
                    k && l.N.ja.push(b);
                    var r = l.N.X, u = r[b];
                    void 0 === u || void 0 === u.S && u.className !== l.name && u.Z === c - 2 ? (n.Z = c - 2, n.className = l.name, r[b] = n) : (ab(r, b, p), r[b].S[c - 2] = n);
                    V([], m, function(t) {
                        t = ob(p, t, l, f, g);
                        void 0 === r[b].S ? (t.Z = c - 2, r[b] = t) : r[b].S[c - 2] = t;
                        return [];
                    });
                    return [];
                });
            },
            A: function A(a, b) {
                b = N(b);
                W(a, {
                    name: b,
                    fromWireType: function fromWireType(c) {
                        var d = M(c);
                        qb(c);
                        return d;
                    },
                    toWireType: function toWireType(c, d) {
                        return Ea(d);
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: Xa,
                    V: null
                });
            },
            n: function n(a, b, c) {
                c = Za(c);
                b = N(b);
                W(a, {
                    name: b,
                    fromWireType: function fromWireType(d) {
                        return d;
                    },
                    toWireType: function toWireType(d, e) {
                        return e;
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: rb(b, c),
                    V: null
                });
            },
            e: function e(a, b, c, d, e) {
                b = N(b);
                -1 === e && (e = 4294967295);
                e = Za(c);
                var f = function(k) {
                    return k;
                };
                if (0 === d) {
                    var g = 32 - 8 * c;
                    f = function(k) {
                        return k << g >>> g;
                    };
                }
                c = b.includes("unsigned") ? function c(k, m) {
                    return m >>> 0;
                } : function(k, m) {
                    return m;
                };
                W(a, {
                    name: b,
                    fromWireType: f,
                    toWireType: c,
                    argPackAdvance: 8,
                    readValueFromPointer: sb(b, e, 0 !== d),
                    V: null
                });
            },
            b: function b(a, b, c) {
                function d(f) {
                    f >>= 2;
                    var g = E;
                    return new e(ia, g[f + 1], g[f]);
                }
                var e = [
                    Int8Array,
                    Uint8Array,
                    Int16Array,
                    Uint16Array,
                    Int32Array,
                    Uint32Array,
                    Float32Array,
                    Float64Array
                ][b];
                c = N(c);
                W(a, {
                    name: c,
                    fromWireType: d,
                    argPackAdvance: 8,
                    readValueFromPointer: d
                }, {
                    ua: true
                });
            },
            o: function o(a, b) {
                b = N(b);
                var c = "std::string" === b;
                W(a, {
                    name: b,
                    fromWireType: function fromWireType(d) {
                        var e = E[d >> 2], f = d + 4;
                        if (c) for(var g = f, k = 0; k <= e; ++k){
                            var m = f + k;
                            if (k == e || 0 == A[m]) {
                                g = g ? z(A, g, m - g) : "";
                                if (void 0 === l) var l = g;
                                else l += String.fromCharCode(0), l += g;
                                g = m + 1;
                            }
                        }
                        else {
                            l = Array(e);
                            for(k = 0; k < e; ++k)l[k] = String.fromCharCode(A[f + k]);
                            l = l.join("");
                        }
                        S(d);
                        return l;
                    },
                    toWireType: function toWireType(d, e) {
                        _instanceof(e, ArrayBuffer) && (e = new Uint8Array(e));
                        var f, g = "string" == typeof e;
                        g || _instanceof(e, Uint8Array) || _instanceof(e, Uint8ClampedArray) || _instanceof(e, Int8Array) || L("Cannot pass non-string to std::string");
                        if (c && g) {
                            var k = 0;
                            for(f = 0; f < e.length; ++f){
                                var m = e.charCodeAt(f);
                                127 >= m ? k++ : 2047 >= m ? k += 2 : 55296 <= m && 57343 >= m ? (k += 4, ++f) : k += 3;
                            }
                            f = k;
                        } else f = e.length;
                        k = Ib(4 + f + 1);
                        m = k + 4;
                        E[k >> 2] = f;
                        if (c && g) {
                            if (g = m, m = f + 1, f = A, 0 < m) {
                                m = g + m - 1;
                                for(var l = 0; l < e.length; ++l){
                                    var n = e.charCodeAt(l);
                                    if (55296 <= n && 57343 >= n) {
                                        var p = e.charCodeAt(++l);
                                        n = 65536 + ((n & 1023) << 10) | p & 1023;
                                    }
                                    if (127 >= n) {
                                        if (g >= m) break;
                                        f[g++] = n;
                                    } else {
                                        if (2047 >= n) {
                                            if (g + 1 >= m) break;
                                            f[g++] = 192 | n >> 6;
                                        } else {
                                            if (65535 >= n) {
                                                if (g + 2 >= m) break;
                                                f[g++] = 224 | n >> 12;
                                            } else {
                                                if (g + 3 >= m) break;
                                                f[g++] = 240 | n >> 18;
                                                f[g++] = 128 | n >> 12 & 63;
                                            }
                                            f[g++] = 128 | n >> 6 & 63;
                                        }
                                        f[g++] = 128 | n & 63;
                                    }
                                }
                                f[g] = 0;
                            }
                        } else if (g) for(g = 0; g < f; ++g)l = e.charCodeAt(g), 255 < l && (S(m), L("String has UTF-16 code units that do not fit in 8 bits")), A[m + g] = l;
                        else for(g = 0; g < f; ++g)A[m + g] = e[g];
                        null !== d && d.push(S, k);
                        return k;
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: Xa,
                    V: function V(d) {
                        S(d);
                    }
                });
            },
            i: function i(a, b, c) {
                c = N(c);
                if (2 === b) {
                    var d = tb;
                    var e = ub;
                    var f = vb;
                    var g = function() {
                        return ka;
                    };
                    var k = 1;
                } else 4 === b && (d = wb, e = xb, f = yb, g = function() {
                    return E;
                }, k = 2);
                W(a, {
                    name: c,
                    fromWireType: function fromWireType(m) {
                        for(var l = E[m >> 2], n = g(), p, r = m + 4, u = 0; u <= l; ++u){
                            var t = m + 4 + u * b;
                            if (u == l || 0 == n[t >> k]) r = d(r, t - r), void 0 === p ? p = r : (p += String.fromCharCode(0), p += r), r = t + b;
                        }
                        S(m);
                        return p;
                    },
                    toWireType: function toWireType(m, l) {
                        "string" != typeof l && L("Cannot pass non-string to C++ string type " + c);
                        var n = f(l), p = Ib(4 + n + b);
                        E[p >> 2] = n >> k;
                        e(l, p + 4, n + b);
                        null !== m && m.push(S, p);
                        return p;
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: Xa,
                    V: function V(m) {
                        S(m);
                    }
                });
            },
            k: function k(a, b, c, d, e, f) {
                Va[a] = {
                    name: N(b),
                    fa: Z(c, d),
                    W: Z(e, f),
                    ia: []
                };
            },
            h: function h(a, b, c, d, e, f, g, k, m, l) {
                Va[a].ia.push({
                    oa: N(b),
                    ta: c,
                    ra: Z(d, e),
                    sa: f,
                    za: g,
                    ya: Z(k, m),
                    Aa: l
                });
            },
            C: function C(a, b) {
                b = N(b);
                W(a, {
                    va: true,
                    name: b,
                    argPackAdvance: 0,
                    fromWireType: function fromWireType() {},
                    toWireType: function toWireType() {}
                });
            },
            s: function s(a, b, c, d, e) {
                a = Bb[a];
                b = M(b);
                c = Ab(c);
                var f = [];
                E[d >> 2] = Ea(f);
                return a(b, c, f, e);
            },
            t: function t(a, b, c, d) {
                a = Bb[a];
                b = M(b);
                c = Ab(c);
                a(b, c, null, d);
            },
            g: qb,
            m: function m(a, b) {
                var c = Db(a, b), d = c[0];
                b = d.name + "_$" + c.slice(1).map(function(g) {
                    return g.name;
                }).join("_") + "$";
                var e = Eb[b];
                if (void 0 !== e) return e;
                var f = Array(a - 1);
                e = Cb(function(g, k, m, l) {
                    for(var n = 0, p = 0; p < a - 1; ++p)f[p] = c[p + 1].readValueFromPointer(l + n), n += c[p + 1].argPackAdvance;
                    g = g[k].apply(g, f);
                    for(p = 0; p < a - 1; ++p)c[p + 1].ma && c[p + 1].ma(f[p]);
                    if (!d.va) return d.toWireType(m, g);
                });
                return Eb[b] = e;
            },
            D: function D(a) {
                4 < a && (J[a].ga += 1);
            },
            r: function r(a) {
                var b = M(a);
                Wa(b);
                qb(a);
            },
            c: function c() {
                x("");
            },
            x: function x(a, b, c) {
                A.copyWithin(a, b, b + c);
            },
            w: function w(a) {
                var b = A.length;
                a >>>= 0;
                if (2147483648 < a) return false;
                for(var c = 1; 4 >= c; c *= 2){
                    var d = b * (1 + .2 / c);
                    d = Math.min(d, a + 100663296);
                    var e = Math;
                    d = Math.max(a, d);
                    e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536);
                    a: {
                        try {
                            fa.grow(e - ia.byteLength + 65535 >>> 16);
                            na();
                            var f = 1;
                            break a;
                        } catch (g) {}
                        f = void 0;
                    }
                    if (f) return true;
                }
                return false;
            },
            z: function z() {
                return 52;
            },
            u: function u() {
                return 70;
            },
            y: function y(a, b, c, d) {
                for(var e = 0, f = 0; f < c; f++){
                    var g = E[b >> 2], k = E[b + 4 >> 2];
                    b += 8;
                    for(var m = 0; m < k; m++){
                        var l = A[g + m], n = Fb[a];
                        0 === l || 10 === l ? ((1 === a ? ea : v)(z(n, 0)), n.length = 0) : n.push(l);
                    }
                    e += k;
                }
                E[d >> 2] = e;
                return 0;
            }
        };
        (function() {
            function a(e) {
                h.asm = e.exports;
                fa = h.asm.E;
                na();
                oa = h.asm.J;
                qa.unshift(h.asm.F);
                F--;
                h.monitorRunDependencies && h.monitorRunDependencies(F);
                0 == F && G && (e = G, G = null, e());
            }
            function b(e) {
                a(e.instance);
            }
            function c(e) {
                return ya().then(function(f) {
                    return WebAssembly.instantiate(f, d);
                }).then(function(f) {
                    return f;
                }).then(e, function(f) {
                    v("failed to asynchronously prepare wasm: " + f);
                    x(f);
                });
            }
            var d = {
                a: Jb
            };
            F++;
            h.monitorRunDependencies && h.monitorRunDependencies(F);
            if (h.instantiateWasm) try {
                return h.instantiateWasm(d, a);
            } catch (e) {
                v("Module.instantiateWasm callback failed with error: " + e), ca(e);
            }
            (function() {
                return w || "function" != typeof WebAssembly.instantiateStreaming || ua(H) || "function" != typeof fetch ? c(b) : fetch(H, {
                    credentials: "same-origin"
                }).then(function(e) {
                    return WebAssembly.instantiateStreaming(e, d).then(b, function(f) {
                        v("wasm streaming compile failed: " + f);
                        v("falling back to ArrayBuffer instantiation");
                        return c(b);
                    });
                });
            })().catch(ca);
            return {};
        })();
        h.___wasm_call_ctors = function() {
            return (h.___wasm_call_ctors = h.asm.F).apply(null, arguments);
        };
        var Ka = h.___getTypeName = function Ka1() {
            return (Ka = h.___getTypeName = h.asm.G).apply(null, arguments);
        };
        h.__embind_initialize_bindings = function() {
            return (h.__embind_initialize_bindings = h.asm.H).apply(null, arguments);
        };
        var Ib = h._malloc = function Ib1() {
            return (Ib = h._malloc = h.asm.I).apply(null, arguments);
        }, S = h._free = function S1() {
            return (S = h._free = h.asm.K).apply(null, arguments);
        };
        h.dynCall_jiji = function() {
            return (h.dynCall_jiji = h.asm.L).apply(null, arguments);
        };
        var Kb;
        G = function Lb() {
            Kb || Mb();
            Kb || (G = Lb);
        };
        function Mb() {
            function a() {
                if (!Kb && (Kb = true, h.calledRun = true, !ha)) {
                    za(qa);
                    aa(h);
                    if (h.onRuntimeInitialized) h.onRuntimeInitialized();
                    if (h.postRun) for("function" == typeof h.postRun && (h.postRun = [
                        h.postRun
                    ]); h.postRun.length;){
                        var b = h.postRun.shift();
                        ra.unshift(b);
                    }
                    za(ra);
                }
            }
            if (!(0 < F)) {
                if (h.preRun) for("function" == typeof h.preRun && (h.preRun = [
                    h.preRun
                ]); h.preRun.length;)sa();
                za(pa);
                0 < F || (h.setStatus ? (h.setStatus("Running..."), setTimeout(function() {
                    setTimeout(function() {
                        h.setStatus("");
                    }, 1);
                    a();
                }, 1)) : a());
            }
        }
        if (h.preInit) for("function" == typeof h.preInit && (h.preInit = [
            h.preInit
        ]); 0 < h.preInit.length;)h.preInit.pop()();
        Mb();
        return loadYoga.ready;
    };
}();
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // @generated by enums.py
var Align = /*#__PURE__*/ function(Align) {
    Align[Align["Auto"] = 0] = "Auto";
    Align[Align["FlexStart"] = 1] = "FlexStart";
    Align[Align["Center"] = 2] = "Center";
    Align[Align["FlexEnd"] = 3] = "FlexEnd";
    Align[Align["Stretch"] = 4] = "Stretch";
    Align[Align["Baseline"] = 5] = "Baseline";
    Align[Align["SpaceBetween"] = 6] = "SpaceBetween";
    Align[Align["SpaceAround"] = 7] = "SpaceAround";
    Align[Align["SpaceEvenly"] = 8] = "SpaceEvenly";
    return Align;
}({});
var BoxSizing = /*#__PURE__*/ function(BoxSizing) {
    BoxSizing[BoxSizing["BorderBox"] = 0] = "BorderBox";
    BoxSizing[BoxSizing["ContentBox"] = 1] = "ContentBox";
    return BoxSizing;
}({});
var Dimension = /*#__PURE__*/ function(Dimension) {
    Dimension[Dimension["Width"] = 0] = "Width";
    Dimension[Dimension["Height"] = 1] = "Height";
    return Dimension;
}({});
var Direction = /*#__PURE__*/ function(Direction) {
    Direction[Direction["Inherit"] = 0] = "Inherit";
    Direction[Direction["LTR"] = 1] = "LTR";
    Direction[Direction["RTL"] = 2] = "RTL";
    return Direction;
}({});
var Display = /*#__PURE__*/ function(Display) {
    Display[Display["Flex"] = 0] = "Flex";
    Display[Display["None"] = 1] = "None";
    Display[Display["Contents"] = 2] = "Contents";
    return Display;
}({});
var Edge = /*#__PURE__*/ function(Edge) {
    Edge[Edge["Left"] = 0] = "Left";
    Edge[Edge["Top"] = 1] = "Top";
    Edge[Edge["Right"] = 2] = "Right";
    Edge[Edge["Bottom"] = 3] = "Bottom";
    Edge[Edge["Start"] = 4] = "Start";
    Edge[Edge["End"] = 5] = "End";
    Edge[Edge["Horizontal"] = 6] = "Horizontal";
    Edge[Edge["Vertical"] = 7] = "Vertical";
    Edge[Edge["All"] = 8] = "All";
    return Edge;
}({});
var Errata = /*#__PURE__*/ function(Errata) {
    Errata[Errata["None"] = 0] = "None";
    Errata[Errata["StretchFlexBasis"] = 1] = "StretchFlexBasis";
    Errata[Errata["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
    Errata[Errata["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
    Errata[Errata["All"] = 2147483647] = "All";
    Errata[Errata["Classic"] = 2147483646] = "Classic";
    return Errata;
}({});
var ExperimentalFeature = /*#__PURE__*/ function(ExperimentalFeature) {
    ExperimentalFeature[ExperimentalFeature["WebFlexBasis"] = 0] = "WebFlexBasis";
    return ExperimentalFeature;
}({});
var FlexDirection = /*#__PURE__*/ function(FlexDirection) {
    FlexDirection[FlexDirection["Column"] = 0] = "Column";
    FlexDirection[FlexDirection["ColumnReverse"] = 1] = "ColumnReverse";
    FlexDirection[FlexDirection["Row"] = 2] = "Row";
    FlexDirection[FlexDirection["RowReverse"] = 3] = "RowReverse";
    return FlexDirection;
}({});
var Gutter = /*#__PURE__*/ function(Gutter) {
    Gutter[Gutter["Column"] = 0] = "Column";
    Gutter[Gutter["Row"] = 1] = "Row";
    Gutter[Gutter["All"] = 2] = "All";
    return Gutter;
}({});
var Justify = /*#__PURE__*/ function(Justify) {
    Justify[Justify["FlexStart"] = 0] = "FlexStart";
    Justify[Justify["Center"] = 1] = "Center";
    Justify[Justify["FlexEnd"] = 2] = "FlexEnd";
    Justify[Justify["SpaceBetween"] = 3] = "SpaceBetween";
    Justify[Justify["SpaceAround"] = 4] = "SpaceAround";
    Justify[Justify["SpaceEvenly"] = 5] = "SpaceEvenly";
    return Justify;
}({});
var LogLevel = /*#__PURE__*/ function(LogLevel) {
    LogLevel[LogLevel["Error"] = 0] = "Error";
    LogLevel[LogLevel["Warn"] = 1] = "Warn";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Debug"] = 3] = "Debug";
    LogLevel[LogLevel["Verbose"] = 4] = "Verbose";
    LogLevel[LogLevel["Fatal"] = 5] = "Fatal";
    return LogLevel;
}({});
var MeasureMode = /*#__PURE__*/ function(MeasureMode) {
    MeasureMode[MeasureMode["Undefined"] = 0] = "Undefined";
    MeasureMode[MeasureMode["Exactly"] = 1] = "Exactly";
    MeasureMode[MeasureMode["AtMost"] = 2] = "AtMost";
    return MeasureMode;
}({});
var NodeType = /*#__PURE__*/ function(NodeType) {
    NodeType[NodeType["Default"] = 0] = "Default";
    NodeType[NodeType["Text"] = 1] = "Text";
    return NodeType;
}({});
var Overflow = /*#__PURE__*/ function(Overflow) {
    Overflow[Overflow["Visible"] = 0] = "Visible";
    Overflow[Overflow["Hidden"] = 1] = "Hidden";
    Overflow[Overflow["Scroll"] = 2] = "Scroll";
    return Overflow;
}({});
var PositionType = /*#__PURE__*/ function(PositionType) {
    PositionType[PositionType["Static"] = 0] = "Static";
    PositionType[PositionType["Relative"] = 1] = "Relative";
    PositionType[PositionType["Absolute"] = 2] = "Absolute";
    return PositionType;
}({});
var Unit = /*#__PURE__*/ function(Unit) {
    Unit[Unit["Undefined"] = 0] = "Undefined";
    Unit[Unit["Point"] = 1] = "Point";
    Unit[Unit["Percent"] = 2] = "Percent";
    Unit[Unit["Auto"] = 3] = "Auto";
    return Unit;
}({});
var Wrap = /*#__PURE__*/ function(Wrap) {
    Wrap[Wrap["NoWrap"] = 0] = "NoWrap";
    Wrap[Wrap["Wrap"] = 1] = "Wrap";
    Wrap[Wrap["WrapReverse"] = 2] = "WrapReverse";
    return Wrap;
}({});
var constants$1 = {
    ALIGN_AUTO: Align.Auto,
    ALIGN_FLEX_START: Align.FlexStart,
    ALIGN_CENTER: Align.Center,
    ALIGN_FLEX_END: Align.FlexEnd,
    ALIGN_STRETCH: Align.Stretch,
    ALIGN_BASELINE: Align.Baseline,
    ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
    ALIGN_SPACE_AROUND: Align.SpaceAround,
    ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
    BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
    BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
    DIMENSION_WIDTH: Dimension.Width,
    DIMENSION_HEIGHT: Dimension.Height,
    DIRECTION_INHERIT: Direction.Inherit,
    DIRECTION_LTR: Direction.LTR,
    DIRECTION_RTL: Direction.RTL,
    DISPLAY_FLEX: Display.Flex,
    DISPLAY_NONE: Display.None,
    DISPLAY_CONTENTS: Display.Contents,
    EDGE_LEFT: Edge.Left,
    EDGE_TOP: Edge.Top,
    EDGE_RIGHT: Edge.Right,
    EDGE_BOTTOM: Edge.Bottom,
    EDGE_START: Edge.Start,
    EDGE_END: Edge.End,
    EDGE_HORIZONTAL: Edge.Horizontal,
    EDGE_VERTICAL: Edge.Vertical,
    EDGE_ALL: Edge.All,
    ERRATA_NONE: Errata.None,
    ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
    ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
    ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
    ERRATA_ALL: Errata.All,
    ERRATA_CLASSIC: Errata.Classic,
    EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
    FLEX_DIRECTION_COLUMN: FlexDirection.Column,
    FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
    FLEX_DIRECTION_ROW: FlexDirection.Row,
    FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
    GUTTER_COLUMN: Gutter.Column,
    GUTTER_ROW: Gutter.Row,
    GUTTER_ALL: Gutter.All,
    JUSTIFY_FLEX_START: Justify.FlexStart,
    JUSTIFY_CENTER: Justify.Center,
    JUSTIFY_FLEX_END: Justify.FlexEnd,
    JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
    JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
    JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
    LOG_LEVEL_ERROR: LogLevel.Error,
    LOG_LEVEL_WARN: LogLevel.Warn,
    LOG_LEVEL_INFO: LogLevel.Info,
    LOG_LEVEL_DEBUG: LogLevel.Debug,
    LOG_LEVEL_VERBOSE: LogLevel.Verbose,
    LOG_LEVEL_FATAL: LogLevel.Fatal,
    MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
    MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
    MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
    NODE_TYPE_DEFAULT: NodeType.Default,
    NODE_TYPE_TEXT: NodeType.Text,
    OVERFLOW_VISIBLE: Overflow.Visible,
    OVERFLOW_HIDDEN: Overflow.Hidden,
    OVERFLOW_SCROLL: Overflow.Scroll,
    POSITION_TYPE_STATIC: PositionType.Static,
    POSITION_TYPE_RELATIVE: PositionType.Relative,
    POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
    UNIT_UNDEFINED: Unit.Undefined,
    UNIT_POINT: Unit.Point,
    UNIT_PERCENT: Unit.Percent,
    UNIT_AUTO: Unit.Auto,
    WRAP_NO_WRAP: Wrap.NoWrap,
    WRAP_WRAP: Wrap.Wrap,
    WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
function wrapAssembly(lib) {
    var _loop = function(_i, _iter) {
        var fnName = _iter[_i];
        var _obj;
        var methods = (_obj = {}, _define_property(_obj, Unit.Point, lib.Node.prototype[fnName]), _define_property(_obj, Unit.Percent, lib.Node.prototype["".concat(fnName, "Percent")]), _define_property(_obj, Unit.Auto, lib.Node.prototype["".concat(fnName, "Auto")]), _obj);
        patch(lib.Node.prototype, fnName, function(original) {
            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                args[_key2 - 1] = arguments[_key2];
            }
            // We patch all these functions to add support for the following calls:
            // .setWidth(100) / .setWidth("100%") / .setWidth(.getWidth()) / .setWidth("auto")
            var value = args.pop();
            var unit, asNumber;
            if (value === 'auto') {
                unit = Unit.Auto;
                asNumber = undefined;
            } else if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === 'object') {
                unit = value.unit;
                asNumber = value.valueOf();
            } else {
                unit = typeof value === 'string' && value.endsWith('%') ? Unit.Percent : Unit.Point;
                asNumber = parseFloat(value);
                if (value !== undefined && !Number.isNaN(value) && Number.isNaN(asNumber)) {
                    throw new Error("Invalid value ".concat(value, " for ").concat(fnName));
                }
            }
            if (!methods[unit]) throw new Error('Failed to execute "'.concat(fnName, "\": Unsupported unit '").concat(value, "'"));
            if (asNumber !== undefined) {
                var _methods_unit;
                return (_methods_unit = methods[unit]).call.apply(_methods_unit, [
                    this
                ].concat(_to_consumable_array(args), [
                    asNumber
                ]));
            } else {
                var _methods_unit1;
                return (_methods_unit1 = methods[unit]).call.apply(_methods_unit1, [
                    this
                ].concat(_to_consumable_array(args)));
            }
        });
    };
    function patch(prototype, name, fn) {
        var original = prototype[name];
        prototype[name] = function() {
            var _fn;
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return (_fn = fn).call.apply(_fn, [
                this,
                original
            ].concat(_to_consumable_array(args)));
        };
    }
    for(var _i = 0, _iter = [
        'setPosition',
        'setMargin',
        'setFlexBasis',
        'setWidth',
        'setHeight',
        'setMinWidth',
        'setMinHeight',
        'setMaxWidth',
        'setMaxHeight',
        'setPadding',
        'setGap'
    ]; _i < _iter.length; _i++)_loop(_i, _iter);
    function wrapMeasureFunction(measureFunction) {
        return lib.MeasureCallback.implement({
            measure: function measure() {
                var _measureFunction_apply = measureFunction.apply(void 0, arguments), width = _measureFunction_apply.width, height = _measureFunction_apply.height;
                return {
                    width: width !== null && width !== void 0 ? width : NaN,
                    height: height !== null && height !== void 0 ? height : NaN
                };
            }
        });
    }
    patch(lib.Node.prototype, 'setMeasureFunc', function(original, measureFunc) {
        // This patch is just a convenience patch, since it helps write more
        // idiomatic source code (such as .setMeasureFunc(null))
        if (measureFunc) {
            return original.call(this, wrapMeasureFunction(measureFunc));
        } else {
            return this.unsetMeasureFunc();
        }
    });
    function wrapDirtiedFunc(dirtiedFunction) {
        return lib.DirtiedCallback.implement({
            dirtied: dirtiedFunction
        });
    }
    patch(lib.Node.prototype, 'setDirtiedFunc', function(original, dirtiedFunc) {
        original.call(this, wrapDirtiedFunc(dirtiedFunc));
    });
    patch(lib.Config.prototype, 'free', function() {
        // Since we handle the memory allocation ourselves (via lib.Config.create),
        // we also need to handle the deallocation
        lib.Config.destroy(this);
    });
    patch(lib.Node, 'create', function(_, config) {
        // We decide the constructor we want to call depending on the parameters
        return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
    });
    patch(lib.Node.prototype, 'free', function() {
        // Since we handle the memory allocation ourselves (via lib.Node.create),
        // we also need to handle the deallocation
        lib.Node.destroy(this);
    });
    patch(lib.Node.prototype, 'freeRecursive', function() {
        for(var t = 0, T = this.getChildCount(); t < T; ++t){
            this.getChild(0).freeRecursive();
        }
        this.free();
    });
    patch(lib.Node.prototype, 'calculateLayout', function(original) {
        var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
        var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
        var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Direction.LTR;
        // Just a small patch to add support for the function default parameters
        return original.call(this, width, height, direction);
    });
    return _object_spread({
        Config: lib.Config,
        Node: lib.Node
    }, constants$1);
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */ var Yoga$1 = null;
loadYoga().then(function(_Y) {
    Yoga$1 = wrapAssembly(_Y);
    _notifyInitialized();
});
var reactReconciler = {
    exports: {}
};
var scheduler = {
    exports: {}
};
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
    if (hasRequiredScheduler_production_min) return scheduler_production_min;
    hasRequiredScheduler_production_min = 1;
    (function(exports1) {
        function f(a, b) {
            var c = a.length;
            a.push(b);
            a: for(; 0 < c;){
                var d = c - 1 >>> 1, e = a[d];
                if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
                else break a;
            }
        }
        function h(a) {
            return 0 === a.length ? null : a[0];
        }
        function k(a) {
            if (0 === a.length) return null;
            var b = a[0], c = a.pop();
            if (c !== b) {
                a[0] = c;
                a: for(var d = 0, e = a.length, w = e >>> 1; d < w;){
                    var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
                    if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
                    else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
                    else break a;
                }
            }
            return b;
        }
        function g(a, b) {
            var c = a.sortIndex - b.sortIndex;
            return 0 !== c ? c : a.id - b.id;
        }
        if ("object" === (typeof performance === "undefined" ? "undefined" : _type_of(performance)) && "function" === typeof performance.now) {
            var l = performance;
            exports1.unstable_now = function() {
                return l.now();
            };
        } else {
            var p = Date, q = p.now();
            exports1.unstable_now = function() {
                return p.now() - q;
            };
        }
        var r = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
        "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function G(a) {
            for(var b = h(t); null !== b;){
                if (null === b.callback) k(t);
                else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
                else break;
                b = h(t);
            }
        }
        function H(a) {
            B = false;
            G(a);
            if (!A) if (null !== h(r)) A = true, I(J);
            else {
                var b = h(t);
                null !== b && K(H, b.startTime - a);
            }
        }
        function J(a, b) {
            A = false;
            B && (B = false, E(L), L = -1);
            z = true;
            var c = y;
            try {
                G(b);
                for(v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());){
                    var d = v.callback;
                    if ("function" === typeof d) {
                        v.callback = null;
                        y = v.priorityLevel;
                        var e = d(v.expirationTime <= b);
                        b = exports1.unstable_now();
                        "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                        G(b);
                    } else k(r);
                    v = h(r);
                }
                if (null !== v) var w = !0;
                else {
                    var m = h(t);
                    null !== m && K(H, m.startTime - b);
                    w = !1;
                }
                return w;
            } finally{
                v = null, y = c, z = false;
            }
        }
        var N = false, O = null, L = -1, P = 5, Q = -1;
        function M() {
            return exports1.unstable_now() - Q < P ? false : true;
        }
        function R() {
            if (null !== O) {
                var a = exports1.unstable_now();
                Q = a;
                var b = true;
                try {
                    b = O(!0, a);
                } finally{
                    b ? S() : (N = false, O = null);
                }
            } else N = false;
        }
        var S;
        if ("function" === typeof F) S = function S() {
            F(R);
        };
        else if ("undefined" !== typeof MessageChannel) {
            var T = new MessageChannel, U = T.port2;
            T.port1.onmessage = R;
            S = function S() {
                U.postMessage(null);
            };
        } else S = function S() {
            D(R, 0);
        };
        function I(a) {
            O = a;
            N || (N = true, S());
        }
        function K(a, b) {
            L = D(function() {
                a(exports1.unstable_now());
            }, b);
        }
        exports1.unstable_IdlePriority = 5;
        exports1.unstable_ImmediatePriority = 1;
        exports1.unstable_LowPriority = 4;
        exports1.unstable_NormalPriority = 3;
        exports1.unstable_Profiling = null;
        exports1.unstable_UserBlockingPriority = 2;
        exports1.unstable_cancelCallback = function(a) {
            a.callback = null;
        };
        exports1.unstable_continueExecution = function() {
            A || z || (A = true, I(J));
        };
        exports1.unstable_forceFrameRate = function(a) {
            0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
        };
        exports1.unstable_getCurrentPriorityLevel = function() {
            return y;
        };
        exports1.unstable_getFirstCallbackNode = function() {
            return h(r);
        };
        exports1.unstable_next = function(a) {
            switch(y){
                case 1:
                case 2:
                case 3:
                    var b = 3;
                    break;
                default:
                    b = y;
            }
            var c = y;
            y = b;
            try {
                return a();
            } finally{
                y = c;
            }
        };
        exports1.unstable_pauseExecution = function() {};
        exports1.unstable_requestPaint = function() {};
        exports1.unstable_runWithPriority = function(a, b) {
            switch(a){
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    a = 3;
            }
            var c = y;
            y = a;
            try {
                return b();
            } finally{
                y = c;
            }
        };
        exports1.unstable_scheduleCallback = function(a, b, c) {
            var d = exports1.unstable_now();
            "object" === (typeof c === "undefined" ? "undefined" : _type_of(c)) && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
            switch(a){
                case 1:
                    var e = -1;
                    break;
                case 2:
                    e = 250;
                    break;
                case 5:
                    e = 1073741823;
                    break;
                case 4:
                    e = 1E4;
                    break;
                default:
                    e = 5E3;
            }
            e = c + e;
            a = {
                id: u++,
                callback: b,
                priorityLevel: a,
                startTime: c,
                expirationTime: e,
                sortIndex: -1
            };
            c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
            return a;
        };
        exports1.unstable_shouldYield = M;
        exports1.unstable_wrapCallback = function(a) {
            var b = y;
            return function() {
                var c = y;
                y = b;
                try {
                    return a.apply(this, arguments);
                } finally{
                    y = c;
                }
            };
        };
    })(scheduler_production_min);
    return scheduler_production_min;
}
var scheduler_development = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_development;
function requireScheduler_development() {
    if (hasRequiredScheduler_development) return scheduler_development;
    hasRequiredScheduler_development = 1;
    (function(exports1) {
        if (process.env.NODE_ENV !== "production") {
            (function() {
                /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
                }
                var enableProfiling = false;
                var frameYieldMs = 5;
                function push(heap, node) {
                    var index = heap.length;
                    heap.push(node);
                    siftUp(heap, node, index);
                }
                function peek(heap) {
                    return heap.length === 0 ? null : heap[0];
                }
                function pop(heap) {
                    if (heap.length === 0) {
                        return null;
                    }
                    var first = heap[0];
                    var last = heap.pop();
                    if (last !== first) {
                        heap[0] = last;
                        siftDown(heap, last, 0);
                    }
                    return first;
                }
                function siftUp(heap, node, i) {
                    var index = i;
                    while(index > 0){
                        var parentIndex = index - 1 >>> 1;
                        var parent = heap[parentIndex];
                        if (compare(parent, node) > 0) {
                            // The parent is larger. Swap positions.
                            heap[parentIndex] = node;
                            heap[index] = parent;
                            index = parentIndex;
                        } else {
                            // The parent is smaller. Exit.
                            return;
                        }
                    }
                }
                function siftDown(heap, node, i) {
                    var index = i;
                    var length = heap.length;
                    var halfLength = length >>> 1;
                    while(index < halfLength){
                        var leftIndex = (index + 1) * 2 - 1;
                        var left = heap[leftIndex];
                        var rightIndex = leftIndex + 1;
                        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.
                        if (compare(left, node) < 0) {
                            if (rightIndex < length && compare(right, left) < 0) {
                                heap[index] = right;
                                heap[rightIndex] = node;
                                index = rightIndex;
                            } else {
                                heap[index] = left;
                                heap[leftIndex] = node;
                                index = leftIndex;
                            }
                        } else if (rightIndex < length && compare(right, node) < 0) {
                            heap[index] = right;
                            heap[rightIndex] = node;
                            index = rightIndex;
                        } else {
                            // Neither child is smaller. Exit.
                            return;
                        }
                    }
                }
                function compare(a, b) {
                    // Compare sort index first, then task id.
                    var diff = a.sortIndex - b.sortIndex;
                    return diff !== 0 ? diff : a.id - b.id;
                }
                // TODO: Use symbols?
                var ImmediatePriority = 1;
                var UserBlockingPriority = 2;
                var NormalPriority = 3;
                var LowPriority = 4;
                var IdlePriority = 5;
                function markTaskErrored(task, ms) {}
                /* eslint-disable no-var */ var hasPerformanceNow = (typeof performance === "undefined" ? "undefined" : _type_of(performance)) === 'object' && typeof performance.now === 'function';
                if (hasPerformanceNow) {
                    var localPerformance = performance;
                    exports1.unstable_now = function() {
                        return localPerformance.now();
                    };
                } else {
                    var localDate = Date;
                    var initialTime = localDate.now();
                    exports1.unstable_now = function() {
                        return localDate.now() - initialTime;
                    };
                } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
                // Math.pow(2, 30) - 1
                // 0b111111111111111111111111111111
                var maxSigned31BitInt = 1073741823; // Times out immediately
                var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out
                var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
                var NORMAL_PRIORITY_TIMEOUT = 5000;
                var LOW_PRIORITY_TIMEOUT = 10000; // Never times out
                var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap
                var taskQueue = [];
                var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.
                var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
                var currentTask = null;
                var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.
                var isPerformingWork = false;
                var isHostCallbackScheduled = false;
                var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.
                var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
                var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
                var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom
                typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
                function advanceTimers(currentTime) {
                    // Check for tasks that are no longer delayed and add them to the queue.
                    var timer = peek(timerQueue);
                    while(timer !== null){
                        if (timer.callback === null) {
                            // Timer was cancelled.
                            pop(timerQueue);
                        } else if (timer.startTime <= currentTime) {
                            // Timer fired. Transfer to the task queue.
                            pop(timerQueue);
                            timer.sortIndex = timer.expirationTime;
                            push(taskQueue, timer);
                        } else {
                            // Remaining timers are pending.
                            return;
                        }
                        timer = peek(timerQueue);
                    }
                }
                function handleTimeout(currentTime) {
                    isHostTimeoutScheduled = false;
                    advanceTimers(currentTime);
                    if (!isHostCallbackScheduled) {
                        if (peek(taskQueue) !== null) {
                            isHostCallbackScheduled = true;
                            requestHostCallback(flushWork);
                        } else {
                            var firstTimer = peek(timerQueue);
                            if (firstTimer !== null) {
                                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                            }
                        }
                    }
                }
                function flushWork(hasTimeRemaining, initialTime) {
                    isHostCallbackScheduled = false;
                    if (isHostTimeoutScheduled) {
                        // We scheduled a timeout but it's no longer needed. Cancel it.
                        isHostTimeoutScheduled = false;
                        cancelHostTimeout();
                    }
                    isPerformingWork = true;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        var currentTime;
                        if (enableProfiling) ;
                        else {
                            // No catch in prod code path.
                            return workLoop(hasTimeRemaining, initialTime);
                        }
                    } finally{
                        currentTask = null;
                        currentPriorityLevel = previousPriorityLevel;
                        isPerformingWork = false;
                    }
                }
                function workLoop(hasTimeRemaining, initialTime) {
                    var currentTime = initialTime;
                    advanceTimers(currentTime);
                    currentTask = peek(taskQueue);
                    while(currentTask !== null && true){
                        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                            break;
                        }
                        var callback = currentTask.callback;
                        if (typeof callback === 'function') {
                            currentTask.callback = null;
                            currentPriorityLevel = currentTask.priorityLevel;
                            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                            var continuationCallback = callback(didUserCallbackTimeout);
                            currentTime = exports1.unstable_now();
                            if (typeof continuationCallback === 'function') {
                                currentTask.callback = continuationCallback;
                            } else {
                                if (currentTask === peek(taskQueue)) {
                                    pop(taskQueue);
                                }
                            }
                            advanceTimers(currentTime);
                        } else {
                            pop(taskQueue);
                        }
                        currentTask = peek(taskQueue);
                    } // Return whether there's additional work
                    if (currentTask !== null) {
                        return true;
                    } else {
                        var firstTimer = peek(timerQueue);
                        if (firstTimer !== null) {
                            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                        }
                        return false;
                    }
                }
                function unstable_runWithPriority(priorityLevel, eventHandler) {
                    switch(priorityLevel){
                        case ImmediatePriority:
                        case UserBlockingPriority:
                        case NormalPriority:
                        case LowPriority:
                        case IdlePriority:
                            break;
                        default:
                            priorityLevel = NormalPriority;
                    }
                    var previousPriorityLevel = currentPriorityLevel;
                    currentPriorityLevel = priorityLevel;
                    try {
                        return eventHandler();
                    } finally{
                        currentPriorityLevel = previousPriorityLevel;
                    }
                }
                function unstable_next(eventHandler) {
                    var priorityLevel;
                    switch(currentPriorityLevel){
                        case ImmediatePriority:
                        case UserBlockingPriority:
                        case NormalPriority:
                            // Shift down to normal priority
                            priorityLevel = NormalPriority;
                            break;
                        default:
                            // Anything lower than normal priority should remain at the current level.
                            priorityLevel = currentPriorityLevel;
                            break;
                    }
                    var previousPriorityLevel = currentPriorityLevel;
                    currentPriorityLevel = priorityLevel;
                    try {
                        return eventHandler();
                    } finally{
                        currentPriorityLevel = previousPriorityLevel;
                    }
                }
                function unstable_wrapCallback(callback) {
                    var parentPriorityLevel = currentPriorityLevel;
                    return function() {
                        // This is a fork of runWithPriority, inlined for performance.
                        var previousPriorityLevel = currentPriorityLevel;
                        currentPriorityLevel = parentPriorityLevel;
                        try {
                            return callback.apply(this, arguments);
                        } finally{
                            currentPriorityLevel = previousPriorityLevel;
                        }
                    };
                }
                function unstable_scheduleCallback(priorityLevel, callback, options) {
                    var currentTime = exports1.unstable_now();
                    var startTime;
                    if ((typeof options === "undefined" ? "undefined" : _type_of(options)) === 'object' && options !== null) {
                        var delay = options.delay;
                        if (typeof delay === 'number' && delay > 0) {
                            startTime = currentTime + delay;
                        } else {
                            startTime = currentTime;
                        }
                    } else {
                        startTime = currentTime;
                    }
                    var timeout;
                    switch(priorityLevel){
                        case ImmediatePriority:
                            timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                            break;
                        case UserBlockingPriority:
                            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                            break;
                        case IdlePriority:
                            timeout = IDLE_PRIORITY_TIMEOUT;
                            break;
                        case LowPriority:
                            timeout = LOW_PRIORITY_TIMEOUT;
                            break;
                        case NormalPriority:
                        default:
                            timeout = NORMAL_PRIORITY_TIMEOUT;
                            break;
                    }
                    var expirationTime = startTime + timeout;
                    var newTask = {
                        id: taskIdCounter++,
                        callback: callback,
                        priorityLevel: priorityLevel,
                        startTime: startTime,
                        expirationTime: expirationTime,
                        sortIndex: -1
                    };
                    if (startTime > currentTime) {
                        // This is a delayed task.
                        newTask.sortIndex = startTime;
                        push(timerQueue, newTask);
                        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                            // All tasks are delayed, and this is the task with the earliest delay.
                            if (isHostTimeoutScheduled) {
                                // Cancel an existing timeout.
                                cancelHostTimeout();
                            } else {
                                isHostTimeoutScheduled = true;
                            } // Schedule a timeout.
                            requestHostTimeout(handleTimeout, startTime - currentTime);
                        }
                    } else {
                        newTask.sortIndex = expirationTime;
                        push(taskQueue, newTask);
                        // wait until the next time we yield.
                        if (!isHostCallbackScheduled && !isPerformingWork) {
                            isHostCallbackScheduled = true;
                            requestHostCallback(flushWork);
                        }
                    }
                    return newTask;
                }
                function unstable_pauseExecution() {}
                function unstable_continueExecution() {
                    if (!isHostCallbackScheduled && !isPerformingWork) {
                        isHostCallbackScheduled = true;
                        requestHostCallback(flushWork);
                    }
                }
                function unstable_getFirstCallbackNode() {
                    return peek(taskQueue);
                }
                function unstable_cancelCallback(task) {
                    // remove from the queue because you can't remove arbitrary nodes from an
                    // array based heap, only the first one.)
                    task.callback = null;
                }
                function unstable_getCurrentPriorityLevel() {
                    return currentPriorityLevel;
                }
                var isMessageLoopRunning = false;
                var scheduledHostCallback = null;
                var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
                // thread, like user events. By default, it yields multiple times per frame.
                // It does not attempt to align with frame boundaries, since most tasks don't
                // need to be frame aligned; for those that do, use requestAnimationFrame.
                var frameInterval = frameYieldMs;
                var startTime = -1;
                function shouldYieldToHost() {
                    var timeElapsed = exports1.unstable_now() - startTime;
                    if (timeElapsed < frameInterval) {
                        // The main thread has only been blocked for a really short amount of time;
                        // smaller than a single frame. Don't yield yet.
                        return false;
                    } // The main thread has been blocked for a non-negligible amount of time. We
                    return true;
                }
                function requestPaint() {}
                function forceFrameRate(fps) {
                    if (fps < 0 || fps > 125) {
                        // Using console['error'] to evade Babel and ESLint
                        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
                        return;
                    }
                    if (fps > 0) {
                        frameInterval = Math.floor(1000 / fps);
                    } else {
                        // reset the framerate
                        frameInterval = frameYieldMs;
                    }
                }
                var performWorkUntilDeadline = function performWorkUntilDeadline() {
                    if (scheduledHostCallback !== null) {
                        var currentTime = exports1.unstable_now(); // Keep track of the start time so we can measure how long the main thread
                        // has been blocked.
                        startTime = currentTime;
                        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the
                        // error can be observed.
                        //
                        // Intentionally not using a try-catch, since that makes some debugging
                        // techniques harder. Instead, if `scheduledHostCallback` errors, then
                        // `hasMoreWork` will remain true, and we'll continue the work loop.
                        var hasMoreWork = true;
                        try {
                            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                        } finally{
                            if (hasMoreWork) {
                                // If there's more work, schedule the next message event at the end
                                // of the preceding one.
                                schedulePerformWorkUntilDeadline();
                            } else {
                                isMessageLoopRunning = false;
                                scheduledHostCallback = null;
                            }
                        }
                    } else {
                        isMessageLoopRunning = false;
                    } // Yielding to the browser will give it a chance to paint, so we can
                };
                var schedulePerformWorkUntilDeadline;
                if (typeof localSetImmediate === 'function') {
                    // Node.js and old IE.
                    // There's a few reasons for why we prefer setImmediate.
                    //
                    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
                    // (Even though this is a DOM fork of the Scheduler, you could get here
                    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
                    // https://github.com/facebook/react/issues/20756
                    //
                    // But also, it runs earlier which is the semantic we want.
                    // If other browsers ever implement it, it's better to use it.
                    // Although both of these would be inferior to native scheduling.
                    schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
                        localSetImmediate(performWorkUntilDeadline);
                    };
                } else if (typeof MessageChannel !== 'undefined') {
                    // DOM and Worker environments.
                    // We prefer MessageChannel because of the 4ms setTimeout clamping.
                    var channel = new MessageChannel();
                    var port = channel.port2;
                    channel.port1.onmessage = performWorkUntilDeadline;
                    schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
                        port.postMessage(null);
                    };
                } else {
                    // We should only fallback here in non-browser environments.
                    schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
                        localSetTimeout(performWorkUntilDeadline, 0);
                    };
                }
                function requestHostCallback(callback) {
                    scheduledHostCallback = callback;
                    if (!isMessageLoopRunning) {
                        isMessageLoopRunning = true;
                        schedulePerformWorkUntilDeadline();
                    }
                }
                function requestHostTimeout(callback, ms) {
                    taskTimeoutID = localSetTimeout(function() {
                        callback(exports1.unstable_now());
                    }, ms);
                }
                function cancelHostTimeout() {
                    localClearTimeout(taskTimeoutID);
                    taskTimeoutID = -1;
                }
                var unstable_requestPaint = requestPaint;
                var unstable_Profiling = null;
                exports1.unstable_IdlePriority = IdlePriority;
                exports1.unstable_ImmediatePriority = ImmediatePriority;
                exports1.unstable_LowPriority = LowPriority;
                exports1.unstable_NormalPriority = NormalPriority;
                exports1.unstable_Profiling = unstable_Profiling;
                exports1.unstable_UserBlockingPriority = UserBlockingPriority;
                exports1.unstable_cancelCallback = unstable_cancelCallback;
                exports1.unstable_continueExecution = unstable_continueExecution;
                exports1.unstable_forceFrameRate = forceFrameRate;
                exports1.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
                exports1.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
                exports1.unstable_next = unstable_next;
                exports1.unstable_pauseExecution = unstable_pauseExecution;
                exports1.unstable_requestPaint = unstable_requestPaint;
                exports1.unstable_runWithPriority = unstable_runWithPriority;
                exports1.unstable_scheduleCallback = unstable_scheduleCallback;
                exports1.unstable_shouldYield = shouldYieldToHost;
                exports1.unstable_wrapCallback = unstable_wrapCallback;
                /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
                }
            })();
        }
    })(scheduler_development);
    return scheduler_development;
}
var hasRequiredScheduler;
function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    if (process.env.NODE_ENV === 'production') {
        scheduler.exports = requireScheduler_production_min();
    } else {
        scheduler.exports = requireScheduler_development();
    }
    return scheduler.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var reactReconciler_production_min;
var hasRequiredReactReconciler_production_min;
function requireReactReconciler_production_min() {
    if (hasRequiredReactReconciler_production_min) return reactReconciler_production_min;
    hasRequiredReactReconciler_production_min = 1;
    reactReconciler_production_min = function $$$reconciler($$$hostConfig) {
        var exports1 = {};
        var aa = _react.default, ba = requireScheduler(), ca = Object.assign;
        function n(a) {
            for(var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)b += "&args[]=" + encodeURIComponent(arguments[c]);
            return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var da = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ea = Symbol.for("react.element"), fa = Symbol.for("react.portal"), ha = Symbol.for("react.fragment"), ia = Symbol.for("react.strict_mode"), ja = Symbol.for("react.profiler"), ka = Symbol.for("react.provider"), la = Symbol.for("react.context"), ma = Symbol.for("react.forward_ref"), na = Symbol.for("react.suspense"), oa = Symbol.for("react.suspense_list"), pa = Symbol.for("react.memo"), qa = Symbol.for("react.lazy");
        var ra = Symbol.for("react.offscreen");
        var sa = Symbol.iterator;
        function ta(a) {
            if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _type_of(a))) return null;
            a = sa && a[sa] || a["@@iterator"];
            return "function" === typeof a ? a : null;
        }
        function ua(a) {
            if (null == a) return null;
            if ("function" === typeof a) return a.displayName || a.name || null;
            if ("string" === typeof a) return a;
            switch(a){
                case ha:
                    return "Fragment";
                case fa:
                    return "Portal";
                case ja:
                    return "Profiler";
                case ia:
                    return "StrictMode";
                case na:
                    return "Suspense";
                case oa:
                    return "SuspenseList";
            }
            if ("object" === (typeof a === "undefined" ? "undefined" : _type_of(a))) switch(a.$$typeof){
                case la:
                    return (a.displayName || "Context") + ".Consumer";
                case ka:
                    return (a._context.displayName || "Context") + ".Provider";
                case ma:
                    var b = a.render;
                    a = a.displayName;
                    a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
                    return a;
                case pa:
                    return b = a.displayName || null, null !== b ? b : ua(a.type) || "Memo";
                case qa:
                    b = a._payload;
                    a = a._init;
                    try {
                        return ua(a(b));
                    } catch (c) {}
            }
            return null;
        }
        function va(a) {
            var b = a.type;
            switch(a.tag){
                case 24:
                    return "Cache";
                case 9:
                    return (b.displayName || "Context") + ".Consumer";
                case 10:
                    return (b._context.displayName || "Context") + ".Provider";
                case 18:
                    return "DehydratedFragment";
                case 11:
                    return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
                case 7:
                    return "Fragment";
                case 5:
                    return b;
                case 4:
                    return "Portal";
                case 3:
                    return "Root";
                case 6:
                    return "Text";
                case 16:
                    return ua(b);
                case 8:
                    return b === ia ? "StrictMode" : "Mode";
                case 22:
                    return "Offscreen";
                case 12:
                    return "Profiler";
                case 21:
                    return "Scope";
                case 13:
                    return "Suspense";
                case 19:
                    return "SuspenseList";
                case 25:
                    return "TracingMarker";
                case 1:
                case 0:
                case 17:
                case 2:
                case 14:
                case 15:
                    if ("function" === typeof b) return b.displayName || b.name || null;
                    if ("string" === typeof b) return b;
            }
            return null;
        }
        function wa(a) {
            var b = a, c = a;
            if (a.alternate) for(; b.return;)b = b.return;
            else {
                a = b;
                do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
                while (a);
            }
            return 3 === b.tag ? c : null;
        }
        function xa(a) {
            if (wa(a) !== a) throw Error(n(188));
        }
        function za(a) {
            var b = a.alternate;
            if (!b) {
                b = wa(a);
                if (null === b) throw Error(n(188));
                return b !== a ? null : a;
            }
            for(var c = a, d = b;;){
                var e = c.return;
                if (null === e) break;
                var f = e.alternate;
                if (null === f) {
                    d = e.return;
                    if (null !== d) {
                        c = d;
                        continue;
                    }
                    break;
                }
                if (e.child === f.child) {
                    for(f = e.child; f;){
                        if (f === c) return xa(e), a;
                        if (f === d) return xa(e), b;
                        f = f.sibling;
                    }
                    throw Error(n(188));
                }
                if (c.return !== d.return) c = e, d = f;
                else {
                    for(var g = false, h = e.child; h;){
                        if (h === c) {
                            g = true;
                            c = e;
                            d = f;
                            break;
                        }
                        if (h === d) {
                            g = true;
                            d = e;
                            c = f;
                            break;
                        }
                        h = h.sibling;
                    }
                    if (!g) {
                        for(h = f.child; h;){
                            if (h === c) {
                                g = true;
                                c = f;
                                d = e;
                                break;
                            }
                            if (h === d) {
                                g = true;
                                d = f;
                                c = e;
                                break;
                            }
                            h = h.sibling;
                        }
                        if (!g) throw Error(n(189));
                    }
                }
                if (c.alternate !== d) throw Error(n(190));
            }
            if (3 !== c.tag) throw Error(n(188));
            return c.stateNode.current === c ? a : b;
        }
        function Aa(a) {
            a = za(a);
            return null !== a ? Ba(a) : null;
        }
        function Ba(a) {
            if (5 === a.tag || 6 === a.tag) return a;
            for(a = a.child; null !== a;){
                var b = Ba(a);
                if (null !== b) return b;
                a = a.sibling;
            }
            return null;
        }
        function Ca(a) {
            if (5 === a.tag || 6 === a.tag) return a;
            for(a = a.child; null !== a;){
                if (4 !== a.tag) {
                    var b = Ca(a);
                    if (null !== b) return b;
                }
                a = a.sibling;
            }
            return null;
        }
        var Da = Array.isArray, Ea = $$$hostConfig.getPublicInstance, Fa = $$$hostConfig.getRootHostContext, Ga = $$$hostConfig.getChildHostContext, Ha = $$$hostConfig.prepareForCommit, Ia = $$$hostConfig.resetAfterCommit, Ja = $$$hostConfig.createInstance, Ka = $$$hostConfig.appendInitialChild, La = $$$hostConfig.finalizeInitialChildren, Ma = $$$hostConfig.prepareUpdate, Na = $$$hostConfig.shouldSetTextContent, Oa = $$$hostConfig.createTextInstance, Pa = $$$hostConfig.scheduleTimeout, Qa = $$$hostConfig.cancelTimeout, Ra = $$$hostConfig.noTimeout, Sa = $$$hostConfig.isPrimaryRenderer, Ta = $$$hostConfig.supportsMutation, Ua = $$$hostConfig.supportsPersistence, Va = $$$hostConfig.supportsHydration, Wa = $$$hostConfig.getInstanceFromNode, Xa = $$$hostConfig.preparePortalMount, Ya = $$$hostConfig.getCurrentEventPriority, Za = $$$hostConfig.detachDeletedInstance, $a = $$$hostConfig.supportsMicrotasks, ab = $$$hostConfig.scheduleMicrotask, bb = $$$hostConfig.supportsTestSelectors, cb = $$$hostConfig.findFiberRoot, db = $$$hostConfig.getBoundingRect, eb = $$$hostConfig.getTextContent, fb = $$$hostConfig.isHiddenSubtree, gb = $$$hostConfig.matchAccessibilityRole, hb = $$$hostConfig.setFocusIfFocusable, ib = $$$hostConfig.setupIntersectionObserver, jb = $$$hostConfig.appendChild, kb = $$$hostConfig.appendChildToContainer, lb = $$$hostConfig.commitTextUpdate, mb = $$$hostConfig.commitMount, nb = $$$hostConfig.commitUpdate, ob = $$$hostConfig.insertBefore, pb = $$$hostConfig.insertInContainerBefore, qb = $$$hostConfig.removeChild, rb = $$$hostConfig.removeChildFromContainer, sb = $$$hostConfig.resetTextContent, tb = $$$hostConfig.hideInstance, ub = $$$hostConfig.hideTextInstance, vb = $$$hostConfig.unhideInstance, wb = $$$hostConfig.unhideTextInstance, xb = $$$hostConfig.clearContainer, yb = $$$hostConfig.cloneInstance, zb = $$$hostConfig.createContainerChildSet, Ab = $$$hostConfig.appendChildToContainerChildSet, Bb = $$$hostConfig.finalizeContainerChildren, Cb = $$$hostConfig.replaceContainerChildren, Eb = $$$hostConfig.cloneHiddenInstance, Fb = $$$hostConfig.cloneHiddenTextInstance, Gb = $$$hostConfig.canHydrateInstance, Hb = $$$hostConfig.canHydrateTextInstance, Ib = $$$hostConfig.canHydrateSuspenseInstance, Jb = $$$hostConfig.isSuspenseInstancePending, Kb = $$$hostConfig.isSuspenseInstanceFallback, Lb = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails, Mb = $$$hostConfig.registerSuspenseInstanceRetry, Nb = $$$hostConfig.getNextHydratableSibling, Ob = $$$hostConfig.getFirstHydratableChild, Pb = $$$hostConfig.getFirstHydratableChildWithinContainer, Qb = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance, Rb = $$$hostConfig.hydrateInstance, Sb = $$$hostConfig.hydrateTextInstance, Tb = $$$hostConfig.hydrateSuspenseInstance, Ub = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, Vb = $$$hostConfig.commitHydratedContainer, Wb = $$$hostConfig.commitHydratedSuspenseInstance, Xb = $$$hostConfig.clearSuspenseBoundary, Yb = $$$hostConfig.clearSuspenseBoundaryFromContainer, Zb = $$$hostConfig.shouldDeleteUnhydratedTailInstances, $b = $$$hostConfig.didNotMatchHydratedContainerTextInstance, ac = $$$hostConfig.didNotMatchHydratedTextInstance, bc;
        function cc(a) {
            if (void 0 === bc) try {
                throw Error();
            } catch (c) {
                var b = c.stack.trim().match(/\n( *(at )?)/);
                bc = b && b[1] || "";
            }
            return "\n" + bc + a;
        }
        var dc = false;
        function ec(a, b) {
            if (!a || dc) return "";
            dc = true;
            var c = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
                if (b) if (b = function b() {
                    throw Error();
                }, Object.defineProperty(b.prototype, "props", {
                    set: function set() {
                        throw Error();
                    }
                }), "object" === (typeof Reflect === "undefined" ? "undefined" : _type_of(Reflect)) && Reflect.construct) {
                    try {
                        Reflect.construct(b, []);
                    } catch (l) {
                        var d = l;
                    }
                    Reflect.construct(a, [], b);
                } else {
                    try {
                        b.call();
                    } catch (l) {
                        d = l;
                    }
                    a.call(b.prototype);
                }
                else {
                    try {
                        throw Error();
                    } catch (l) {
                        d = l;
                    }
                    a();
                }
            } catch (l) {
                if (l && d && "string" === typeof l.stack) {
                    for(var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];)h--;
                    for(; 1 <= g && 0 <= h; g--, h--)if (e[g] !== f[h]) {
                        if (1 !== g || 1 !== h) {
                            do if (g--, h--, 0 > h || e[g] !== f[h]) {
                                var k = "\n" + e[g].replace(" at new ", " at ");
                                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                                return k;
                            }
                            while (1 <= g && 0 <= h);
                        }
                        break;
                    }
                }
            } finally{
                dc = false, Error.prepareStackTrace = c;
            }
            return (a = a ? a.displayName || a.name : "") ? cc(a) : "";
        }
        var fc = Object.prototype.hasOwnProperty, gc = [], hc = -1;
        function ic(a) {
            return {
                current: a
            };
        }
        function q(a) {
            0 > hc || (a.current = gc[hc], gc[hc] = null, hc--);
        }
        function v(a, b) {
            hc++;
            gc[hc] = a.current;
            a.current = b;
        }
        var jc = {}, x = ic(jc), z = ic(false), kc = jc;
        function mc(a, b) {
            var c = a.type.contextTypes;
            if (!c) return jc;
            var d = a.stateNode;
            if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
            var e = {}, f;
            for(f in c)e[f] = b[f];
            d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
            return e;
        }
        function A(a) {
            a = a.childContextTypes;
            return null !== a && void 0 !== a;
        }
        function nc() {
            q(z);
            q(x);
        }
        function oc(a, b, c) {
            if (x.current !== jc) throw Error(n(168));
            v(x, b);
            v(z, c);
        }
        function pc(a, b, c) {
            var d = a.stateNode;
            b = b.childContextTypes;
            if ("function" !== typeof d.getChildContext) return c;
            d = d.getChildContext();
            for(var e in d)if (!(e in b)) throw Error(n(108, va(a) || "Unknown", e));
            return ca({}, c, d);
        }
        function qc(a) {
            a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || jc;
            kc = x.current;
            v(x, a);
            v(z, z.current);
            return true;
        }
        function rc(a, b, c) {
            var d = a.stateNode;
            if (!d) throw Error(n(169));
            c ? (a = pc(a, b, kc), d.__reactInternalMemoizedMergedChildContext = a, q(z), q(x), v(x, a)) : q(z);
            v(z, c);
        }
        var tc = Math.clz32 ? Math.clz32 : sc, uc = Math.log, vc = Math.LN2;
        function sc(a) {
            a >>>= 0;
            return 0 === a ? 32 : 31 - (uc(a) / vc | 0) | 0;
        }
        var wc = 64, xc = 4194304;
        function yc(a) {
            switch(a & -a){
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return a & 4194240;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    return a & 130023424;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 1073741824;
                default:
                    return a;
            }
        }
        function zc(a, b) {
            var c = a.pendingLanes;
            if (0 === c) return 0;
            var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
            if (0 !== g) {
                var h = g & ~e;
                0 !== h ? d = yc(h) : (f &= g, 0 !== f && (d = yc(f)));
            } else g = c & ~e, 0 !== g ? d = yc(g) : 0 !== f && (d = yc(f));
            if (0 === d) return 0;
            if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
            0 !== (d & 4) && (d |= c & 16);
            b = a.entangledLanes;
            if (0 !== b) for(a = a.entanglements, b &= d; 0 < b;)c = 31 - tc(b), e = 1 << c, d |= a[c], b &= ~e;
            return d;
        }
        function Ac(a, b) {
            switch(a){
                case 1:
                case 2:
                case 4:
                    return b + 250;
                case 8:
                case 16:
                case 32:
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return b + 5E3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    return -1;
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1;
            }
        }
        function Bc(a, b) {
            for(var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;){
                var g = 31 - tc(f), h = 1 << g, k = e[g];
                if (-1 === k) {
                    if (0 === (h & c) || 0 !== (h & d)) e[g] = Ac(h, b);
                } else k <= b && (a.expiredLanes |= h);
                f &= ~h;
            }
        }
        function Cc(a) {
            a = a.pendingLanes & -1073741825;
            return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
        }
        function Dc() {
            var a = wc;
            wc <<= 1;
            0 === (wc & 4194240) && (wc = 64);
            return a;
        }
        function Ec(a) {
            for(var b = [], c = 0; 31 > c; c++)b.push(a);
            return b;
        }
        function Fc(a, b, c) {
            a.pendingLanes |= b;
            536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
            a = a.eventTimes;
            b = 31 - tc(b);
            a[b] = c;
        }
        function Gc(a, b) {
            var c = a.pendingLanes & ~b;
            a.pendingLanes = b;
            a.suspendedLanes = 0;
            a.pingedLanes = 0;
            a.expiredLanes &= b;
            a.mutableReadLanes &= b;
            a.entangledLanes &= b;
            b = a.entanglements;
            var d = a.eventTimes;
            for(a = a.expirationTimes; 0 < c;){
                var e = 31 - tc(c), f = 1 << e;
                b[e] = 0;
                d[e] = -1;
                a[e] = -1;
                c &= ~f;
            }
        }
        function Hc(a, b) {
            var c = a.entangledLanes |= b;
            for(a = a.entanglements; c;){
                var d = 31 - tc(c), e = 1 << d;
                e & b | a[d] & b && (a[d] |= b);
                c &= ~e;
            }
        }
        var C = 0;
        function Ic(a) {
            a &= -a;
            return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
        }
        var Jc = ba.unstable_scheduleCallback, Kc = ba.unstable_cancelCallback, Lc = ba.unstable_shouldYield, Mc = ba.unstable_requestPaint, D = ba.unstable_now, Nc = ba.unstable_ImmediatePriority, Oc = ba.unstable_UserBlockingPriority, Pc = ba.unstable_NormalPriority, Qc = ba.unstable_IdlePriority, Rc = null, Sc = null;
        function Tc(a) {
            if (Sc && "function" === typeof Sc.onCommitFiberRoot) try {
                Sc.onCommitFiberRoot(Rc, a, void 0, 128 === (a.current.flags & 128));
            } catch (b) {}
        }
        function Uc(a, b) {
            return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
        }
        var Vc = "function" === typeof Object.is ? Object.is : Uc, Wc = null, Xc = false, Yc = false;
        function Zc(a) {
            null === Wc ? Wc = [
                a
            ] : Wc.push(a);
        }
        function $c(a) {
            Xc = true;
            Zc(a);
        }
        function ad() {
            if (!Yc && null !== Wc) {
                Yc = true;
                var a = 0, b = C;
                try {
                    var c = Wc;
                    for(C = 1; a < c.length; a++){
                        var d = c[a];
                        do d = d(!0);
                        while (null !== d);
                    }
                    Wc = null;
                    Xc = !1;
                } catch (e) {
                    throw null !== Wc && (Wc = Wc.slice(a + 1)), Jc(Nc, ad), e;
                } finally{
                    C = b, Yc = false;
                }
            }
            return null;
        }
        var bd = [], cd = 0, dd = null, ed = 0, fd = [], gd = 0, hd = null, id = 1, jd = "";
        function kd(a, b) {
            bd[cd++] = ed;
            bd[cd++] = dd;
            dd = a;
            ed = b;
        }
        function ld(a, b, c) {
            fd[gd++] = id;
            fd[gd++] = jd;
            fd[gd++] = hd;
            hd = a;
            var d = id;
            a = jd;
            var e = 32 - tc(d) - 1;
            d &= ~(1 << e);
            c += 1;
            var f = 32 - tc(b) + e;
            if (30 < f) {
                var g = e - e % 5;
                f = (d & (1 << g) - 1).toString(32);
                d >>= g;
                e -= g;
                id = 1 << 32 - tc(b) + e | c << e | d;
                jd = f + a;
            } else id = 1 << f | c << e | d, jd = a;
        }
        function md(a) {
            null !== a.return && (kd(a, 1), ld(a, 1, 0));
        }
        function nd(a) {
            for(; a === dd;)dd = bd[--cd], bd[cd] = null, ed = bd[--cd], bd[cd] = null;
            for(; a === hd;)hd = fd[--gd], fd[gd] = null, jd = fd[--gd], fd[gd] = null, id = fd[--gd], fd[gd] = null;
        }
        var od = null, pd = null, F = false, qd = false, rd = null;
        function sd(a, b) {
            var c = td(5, null, null, 0);
            c.elementType = "DELETED";
            c.stateNode = b;
            c.return = a;
            b = a.deletions;
            null === b ? (a.deletions = [
                c
            ], a.flags |= 16) : b.push(c);
        }
        function ud(a, b) {
            switch(a.tag){
                case 5:
                    return b = Gb(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, od = a, pd = Ob(b), true) : false;
                case 6:
                    return b = Hb(b, a.pendingProps), null !== b ? (a.stateNode = b, od = a, pd = null, true) : false;
                case 13:
                    b = Ib(b);
                    if (null !== b) {
                        var c = null !== hd ? {
                            id: id,
                            overflow: jd
                        } : null;
                        a.memoizedState = {
                            dehydrated: b,
                            treeContext: c,
                            retryLane: 1073741824
                        };
                        c = td(18, null, null, 0);
                        c.stateNode = b;
                        c.return = a;
                        a.child = c;
                        od = a;
                        pd = null;
                        return true;
                    }
                    return false;
                default:
                    return false;
            }
        }
        function vd(a) {
            return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
        }
        function wd(a) {
            if (F) {
                var b = pd;
                if (b) {
                    var c = b;
                    if (!ud(a, b)) {
                        if (vd(a)) throw Error(n(418));
                        b = Nb(c);
                        var d = od;
                        b && ud(a, b) ? sd(d, c) : (a.flags = a.flags & -4097 | 2, F = false, od = a);
                    }
                } else {
                    if (vd(a)) throw Error(n(418));
                    a.flags = a.flags & -4097 | 2;
                    F = false;
                    od = a;
                }
            }
        }
        function xd(a) {
            for(a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;)a = a.return;
            od = a;
        }
        function yd(a) {
            if (!Va || a !== od) return false;
            if (!F) return xd(a), F = true, false;
            if (3 !== a.tag && (5 !== a.tag || Zb(a.type) && !Na(a.type, a.memoizedProps))) {
                var b = pd;
                if (b) {
                    if (vd(a)) throw zd(), Error(n(418));
                    for(; b;)sd(a, b), b = Nb(b);
                }
            }
            xd(a);
            if (13 === a.tag) {
                if (!Va) throw Error(n(316));
                a = a.memoizedState;
                a = null !== a ? a.dehydrated : null;
                if (!a) throw Error(n(317));
                pd = Ub(a);
            } else pd = od ? Nb(a.stateNode) : null;
            return true;
        }
        function zd() {
            for(var a = pd; a;)a = Nb(a);
        }
        function Ad() {
            Va && (pd = od = null, qd = F = false);
        }
        function Bd(a) {
            null === rd ? rd = [
                a
            ] : rd.push(a);
        }
        var Cd = da.ReactCurrentBatchConfig;
        function Dd(a, b) {
            if (Vc(a, b)) return true;
            if ("object" !== (typeof a === "undefined" ? "undefined" : _type_of(a)) || null === a || "object" !== (typeof b === "undefined" ? "undefined" : _type_of(b)) || null === b) return false;
            var c = Object.keys(a), d = Object.keys(b);
            if (c.length !== d.length) return false;
            for(d = 0; d < c.length; d++){
                var e = c[d];
                if (!fc.call(b, e) || !Vc(a[e], b[e])) return false;
            }
            return true;
        }
        function Ed(a) {
            switch(a.tag){
                case 5:
                    return cc(a.type);
                case 16:
                    return cc("Lazy");
                case 13:
                    return cc("Suspense");
                case 19:
                    return cc("SuspenseList");
                case 0:
                case 2:
                case 15:
                    return a = ec(a.type, false), a;
                case 11:
                    return a = ec(a.type.render, false), a;
                case 1:
                    return a = ec(a.type, true), a;
                default:
                    return "";
            }
        }
        function Fd(a, b, c) {
            a = c.ref;
            if (null !== a && "function" !== typeof a && "object" !== (typeof a === "undefined" ? "undefined" : _type_of(a))) {
                if (c._owner) {
                    c = c._owner;
                    if (c) {
                        if (1 !== c.tag) throw Error(n(309));
                        var d = c.stateNode;
                    }
                    if (!d) throw Error(n(147, a));
                    var e = d, f = "" + a;
                    if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
                    b = function b(a) {
                        var _$b = e.refs;
                        null === a ? delete _$b[f] : _$b[f] = a;
                    };
                    b._stringRef = f;
                    return b;
                }
                if ("string" !== typeof a) throw Error(n(284));
                if (!c._owner) throw Error(n(290, a));
            }
            return a;
        }
        function Gd(a, b) {
            a = Object.prototype.toString.call(b);
            throw Error(n(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
        }
        function Hd(a) {
            var b = a._init;
            return b(a._payload);
        }
        function Id(a) {
            function b(b, c) {
                if (a) {
                    var d = b.deletions;
                    null === d ? (b.deletions = [
                        c
                    ], b.flags |= 16) : d.push(c);
                }
            }
            function c(c, d) {
                if (!a) return null;
                for(; null !== d;)b(c, d), d = d.sibling;
                return null;
            }
            function d(a, b) {
                for(a = new Map; null !== b;)null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
                return a;
            }
            function e(a, b) {
                a = Jd(a, b);
                a.index = 0;
                a.sibling = null;
                return a;
            }
            function f(b, c, d) {
                b.index = d;
                if (!a) return b.flags |= 1048576, c;
                d = b.alternate;
                if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
                b.flags |= 2;
                return c;
            }
            function g(b) {
                a && null === b.alternate && (b.flags |= 2);
                return b;
            }
            function h(a, b, c, d) {
                if (null === b || 6 !== b.tag) return b = Kd(c, a.mode, d), b.return = a, b;
                b = e(b, c);
                b.return = a;
                return b;
            }
            function k(a, b, c, d) {
                var f = c.type;
                if (f === ha) return m(a, b, c.props.children, d, c.key);
                if (null !== b && (b.elementType === f || "object" === (typeof f === "undefined" ? "undefined" : _type_of(f)) && null !== f && f.$$typeof === qa && Hd(f) === b.type)) return d = e(b, c.props), d.ref = Fd(a, b, c), d.return = a, d;
                d = Ld(c.type, c.key, c.props, null, a.mode, d);
                d.ref = Fd(a, b, c);
                d.return = a;
                return d;
            }
            function l(a, b, c, d) {
                if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Md(c, a.mode, d), b.return = a, b;
                b = e(b, c.children || []);
                b.return = a;
                return b;
            }
            function m(a, b, c, d, f) {
                if (null === b || 7 !== b.tag) return b = Nd(c, a.mode, d, f), b.return = a, b;
                b = e(b, c);
                b.return = a;
                return b;
            }
            function r(a, b, c) {
                if ("string" === typeof b && "" !== b || "number" === typeof b) return b = Kd("" + b, a.mode, c), b.return = a, b;
                if ("object" === (typeof b === "undefined" ? "undefined" : _type_of(b)) && null !== b) {
                    switch(b.$$typeof){
                        case ea:
                            return c = Ld(b.type, b.key, b.props, null, a.mode, c), c.ref = Fd(a, null, b), c.return = a, c;
                        case fa:
                            return b = Md(b, a.mode, c), b.return = a, b;
                        case qa:
                            var d = b._init;
                            return r(a, d(b._payload), c);
                    }
                    if (Da(b) || ta(b)) return b = Nd(b, a.mode, c, null), b.return = a, b;
                    Gd(a, b);
                }
                return null;
            }
            function p(a, b, c, d) {
                var e = null !== b ? b.key : null;
                if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
                if ("object" === (typeof c === "undefined" ? "undefined" : _type_of(c)) && null !== c) {
                    switch(c.$$typeof){
                        case ea:
                            return c.key === e ? k(a, b, c, d) : null;
                        case fa:
                            return c.key === e ? l(a, b, c, d) : null;
                        case qa:
                            return e = c._init, p(a, b, e(c._payload), d);
                    }
                    if (Da(c) || ta(c)) return null !== e ? null : m(a, b, c, d, null);
                    Gd(a, c);
                }
                return null;
            }
            function B(a, b, c, d, e) {
                if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
                if ("object" === (typeof d === "undefined" ? "undefined" : _type_of(d)) && null !== d) {
                    switch(d.$$typeof){
                        case ea:
                            return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
                        case fa:
                            return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
                        case qa:
                            var f = d._init;
                            return B(a, b, c, f(d._payload), e);
                    }
                    if (Da(d) || ta(d)) return a = a.get(c) || null, m(b, a, d, e, null);
                    Gd(b, d);
                }
                return null;
            }
            function w(e, g, h, k) {
                for(var l = null, m = null, u = g, t = g = 0, E = null; null !== u && t < h.length; t++){
                    u.index > t ? (E = u, u = null) : E = u.sibling;
                    var y = p(e, u, h[t], k);
                    if (null === y) {
                        null === u && (u = E);
                        break;
                    }
                    a && u && null === y.alternate && b(e, u);
                    g = f(y, g, t);
                    null === m ? l = y : m.sibling = y;
                    m = y;
                    u = E;
                }
                if (t === h.length) return c(e, u), F && kd(e, t), l;
                if (null === u) {
                    for(; t < h.length; t++)u = r(e, h[t], k), null !== u && (g = f(u, g, t), null === m ? l = u : m.sibling = u, m = u);
                    F && kd(e, t);
                    return l;
                }
                for(u = d(e, u); t < h.length; t++)E = B(u, e, t, h[t], k), null !== E && (a && null !== E.alternate && u.delete(null === E.key ? t : E.key), g = f(E, g, t), null === m ? l = E : m.sibling = E, m = E);
                a && u.forEach(function(a) {
                    return b(e, a);
                });
                F && kd(e, t);
                return l;
            }
            function Y(e, g, h, k) {
                var l = ta(h);
                if ("function" !== typeof l) throw Error(n(150));
                h = l.call(h);
                if (null == h) throw Error(n(151));
                for(var u = l = null, m = g, t = g = 0, E = null, y = h.next(); null !== m && !y.done; t++, y = h.next()){
                    m.index > t ? (E = m, m = null) : E = m.sibling;
                    var w = p(e, m, y.value, k);
                    if (null === w) {
                        null === m && (m = E);
                        break;
                    }
                    a && m && null === w.alternate && b(e, m);
                    g = f(w, g, t);
                    null === u ? l = w : u.sibling = w;
                    u = w;
                    m = E;
                }
                if (y.done) return c(e, m), F && kd(e, t), l;
                if (null === m) {
                    for(; !y.done; t++, y = h.next())y = r(e, y.value, k), null !== y && (g = f(y, g, t), null === u ? l = y : u.sibling = y, u = y);
                    F && kd(e, t);
                    return l;
                }
                for(m = d(e, m); !y.done; t++, y = h.next())y = B(m, e, t, y.value, k), null !== y && (a && null !== y.alternate && m.delete(null === y.key ? t : y.key), g = f(y, g, t), null === u ? l = y : u.sibling = y, u = y);
                a && m.forEach(function(a) {
                    return b(e, a);
                });
                F && kd(e, t);
                return l;
            }
            function ya(a, d, f, h) {
                "object" === (typeof f === "undefined" ? "undefined" : _type_of(f)) && null !== f && f.type === ha && null === f.key && (f = f.props.children);
                if ("object" === (typeof f === "undefined" ? "undefined" : _type_of(f)) && null !== f) {
                    switch(f.$$typeof){
                        case ea:
                            a: {
                                for(var k = f.key, l = d; null !== l;){
                                    if (l.key === k) {
                                        k = f.type;
                                        if (k === ha) {
                                            if (7 === l.tag) {
                                                c(a, l.sibling);
                                                d = e(l, f.props.children);
                                                d.return = a;
                                                a = d;
                                                break a;
                                            }
                                        } else if (l.elementType === k || "object" === (typeof k === "undefined" ? "undefined" : _type_of(k)) && null !== k && k.$$typeof === qa && Hd(k) === l.type) {
                                            c(a, l.sibling);
                                            d = e(l, f.props);
                                            d.ref = Fd(a, l, f);
                                            d.return = a;
                                            a = d;
                                            break a;
                                        }
                                        c(a, l);
                                        break;
                                    } else b(a, l);
                                    l = l.sibling;
                                }
                                f.type === ha ? (d = Nd(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Ld(f.type, f.key, f.props, null, a.mode, h), h.ref = Fd(a, d, f), h.return = a, a = h);
                            }
                            return g(a);
                        case fa:
                            a: {
                                for(l = f.key; null !== d;){
                                    if (d.key === l) if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                                        c(a, d.sibling);
                                        d = e(d, f.children || []);
                                        d.return = a;
                                        a = d;
                                        break a;
                                    } else {
                                        c(a, d);
                                        break;
                                    }
                                    else b(a, d);
                                    d = d.sibling;
                                }
                                d = Md(f, a.mode, h);
                                d.return = a;
                                a = d;
                            }
                            return g(a);
                        case qa:
                            return l = f._init, ya(a, d, l(f._payload), h);
                    }
                    if (Da(f)) return w(a, d, f, h);
                    if (ta(f)) return Y(a, d, f, h);
                    Gd(a, f);
                }
                return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Kd(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
            }
            return ya;
        }
        var Od = Id(true), Pd = Id(false), Qd = ic(null), Rd = null, Sd = null, Td = null;
        function Ud() {
            Td = Sd = Rd = null;
        }
        function Vd(a, b, c) {
            Sa ? (v(Qd, b._currentValue), b._currentValue = c) : (v(Qd, b._currentValue2), b._currentValue2 = c);
        }
        function Wd(a) {
            var b = Qd.current;
            q(Qd);
            Sa ? a._currentValue = b : a._currentValue2 = b;
        }
        function Xd(a, b, c) {
            for(; null !== a;){
                var d = a.alternate;
                (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
                if (a === c) break;
                a = a.return;
            }
        }
        function Yd(a, b) {
            Rd = a;
            Td = Sd = null;
            a = a.dependencies;
            null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (G = true), a.firstContext = null);
        }
        function Zd(a) {
            var b = Sa ? a._currentValue : a._currentValue2;
            if (Td !== a) if (a = {
                context: a,
                memoizedValue: b,
                next: null
            }, null === Sd) {
                if (null === Rd) throw Error(n(308));
                Sd = a;
                Rd.dependencies = {
                    lanes: 0,
                    firstContext: a
                };
            } else Sd = Sd.next = a;
            return b;
        }
        var $d = null;
        function ae(a) {
            null === $d ? $d = [
                a
            ] : $d.push(a);
        }
        function be(a, b, c, d) {
            var e = b.interleaved;
            null === e ? (c.next = c, ae(b)) : (c.next = e.next, e.next = c);
            b.interleaved = c;
            return ce(a, d);
        }
        function ce(a, b) {
            a.lanes |= b;
            var c = a.alternate;
            null !== c && (c.lanes |= b);
            c = a;
            for(a = a.return; null !== a;)a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
            return 3 === c.tag ? c.stateNode : null;
        }
        var de = false;
        function ee(a) {
            a.updateQueue = {
                baseState: a.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    interleaved: null,
                    lanes: 0
                },
                effects: null
            };
        }
        function fe(a, b) {
            a = a.updateQueue;
            b.updateQueue === a && (b.updateQueue = {
                baseState: a.baseState,
                firstBaseUpdate: a.firstBaseUpdate,
                lastBaseUpdate: a.lastBaseUpdate,
                shared: a.shared,
                effects: a.effects
            });
        }
        function ge(a, b) {
            return {
                eventTime: a,
                lane: b,
                tag: 0,
                payload: null,
                callback: null,
                next: null
            };
        }
        function he(a, b, c) {
            var d = a.updateQueue;
            if (null === d) return null;
            d = d.shared;
            if (0 !== (H & 2)) {
                var e = d.pending;
                null === e ? b.next = b : (b.next = e.next, e.next = b);
                d.pending = b;
                return ce(a, c);
            }
            e = d.interleaved;
            null === e ? (b.next = b, ae(d)) : (b.next = e.next, e.next = b);
            d.interleaved = b;
            return ce(a, c);
        }
        function ie(a, b, c) {
            b = b.updateQueue;
            if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
                var d = b.lanes;
                d &= a.pendingLanes;
                c |= d;
                b.lanes = c;
                Hc(a, c);
            }
        }
        function je(a, b) {
            var c = a.updateQueue, d = a.alternate;
            if (null !== d && (d = d.updateQueue, c === d)) {
                var e = null, f = null;
                c = c.firstBaseUpdate;
                if (null !== c) {
                    do {
                        var g = {
                            eventTime: c.eventTime,
                            lane: c.lane,
                            tag: c.tag,
                            payload: c.payload,
                            callback: c.callback,
                            next: null
                        };
                        null === f ? e = f = g : f = f.next = g;
                        c = c.next;
                    }while (null !== c);
                    null === f ? e = f = b : f = f.next = b;
                } else e = f = b;
                c = {
                    baseState: d.baseState,
                    firstBaseUpdate: e,
                    lastBaseUpdate: f,
                    shared: d.shared,
                    effects: d.effects
                };
                a.updateQueue = c;
                return;
            }
            a = c.lastBaseUpdate;
            null === a ? c.firstBaseUpdate = b : a.next = b;
            c.lastBaseUpdate = b;
        }
        function ke(a, b, c, d) {
            var e = a.updateQueue;
            de = false;
            var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
            if (null !== h) {
                e.shared.pending = null;
                var k = h, l = k.next;
                k.next = null;
                null === g ? f = l : g.next = l;
                g = k;
                var m = a.alternate;
                null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
            }
            if (null !== f) {
                var r = e.baseState;
                g = 0;
                m = l = k = null;
                h = f;
                do {
                    var p = h.lane, B = h.eventTime;
                    if ((d & p) === p) {
                        null !== m && (m = m.next = {
                            eventTime: B,
                            lane: 0,
                            tag: h.tag,
                            payload: h.payload,
                            callback: h.callback,
                            next: null
                        });
                        a: {
                            var w = a, Y = h;
                            p = b;
                            B = c;
                            switch(Y.tag){
                                case 1:
                                    w = Y.payload;
                                    if ("function" === typeof w) {
                                        r = w.call(B, r, p);
                                        break a;
                                    }
                                    r = w;
                                    break a;
                                case 3:
                                    w.flags = w.flags & -65537 | 128;
                                case 0:
                                    w = Y.payload;
                                    p = "function" === typeof w ? w.call(B, r, p) : w;
                                    if (null === p || void 0 === p) break a;
                                    r = ca({}, r, p);
                                    break a;
                                case 2:
                                    de = true;
                            }
                        }
                        null !== h.callback && 0 !== h.lane && (a.flags |= 64, p = e.effects, null === p ? e.effects = [
                            h
                        ] : p.push(h));
                    } else B = {
                        eventTime: B,
                        lane: p,
                        tag: h.tag,
                        payload: h.payload,
                        callback: h.callback,
                        next: null
                    }, null === m ? (l = m = B, k = r) : m = m.next = B, g |= p;
                    h = h.next;
                    if (null === h) if (h = e.shared.pending, null === h) break;
                    else p = h, h = p.next, p.next = null, e.lastBaseUpdate = p, e.shared.pending = null;
                }while (1);
                null === m && (k = r);
                e.baseState = k;
                e.firstBaseUpdate = l;
                e.lastBaseUpdate = m;
                b = e.shared.interleaved;
                if (null !== b) {
                    e = b;
                    do g |= e.lane, e = e.next;
                    while (e !== b);
                } else null === f && (e.shared.lanes = 0);
                le |= g;
                a.lanes = g;
                a.memoizedState = r;
            }
        }
        function me(a, b, c) {
            a = b.effects;
            b.effects = null;
            if (null !== a) for(b = 0; b < a.length; b++){
                var d = a[b], e = d.callback;
                if (null !== e) {
                    d.callback = null;
                    d = c;
                    if ("function" !== typeof e) throw Error(n(191, e));
                    e.call(d);
                }
            }
        }
        var ne = {}, oe = ic(ne), pe = ic(ne), qe = ic(ne);
        function re(a) {
            if (a === ne) throw Error(n(174));
            return a;
        }
        function se(a, b) {
            v(qe, b);
            v(pe, a);
            v(oe, ne);
            a = Fa(b);
            q(oe);
            v(oe, a);
        }
        function te() {
            q(oe);
            q(pe);
            q(qe);
        }
        function ue(a) {
            var b = re(qe.current), c = re(oe.current);
            b = Ga(c, a.type, b);
            c !== b && (v(pe, a), v(oe, b));
        }
        function ve(a) {
            pe.current === a && (q(oe), q(pe));
        }
        var I = ic(0);
        function we(a) {
            for(var b = a; null !== b;){
                if (13 === b.tag) {
                    var c = b.memoizedState;
                    if (null !== c && (c = c.dehydrated, null === c || Jb(c) || Kb(c))) return b;
                } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
                    if (0 !== (b.flags & 128)) return b;
                } else if (null !== b.child) {
                    b.child.return = b;
                    b = b.child;
                    continue;
                }
                if (b === a) break;
                for(; null === b.sibling;){
                    if (null === b.return || b.return === a) return null;
                    b = b.return;
                }
                b.sibling.return = b.return;
                b = b.sibling;
            }
            return null;
        }
        var xe = [];
        function ye() {
            for(var a = 0; a < xe.length; a++){
                var b = xe[a];
                Sa ? b._workInProgressVersionPrimary = null : b._workInProgressVersionSecondary = null;
            }
            xe.length = 0;
        }
        var ze = da.ReactCurrentDispatcher, Ae = da.ReactCurrentBatchConfig, Be = 0, J = null, K = null, L = null, Ce = false, De = false, Ee = 0, Fe = 0;
        function M() {
            throw Error(n(321));
        }
        function Ge(a, b) {
            if (null === b) return false;
            for(var c = 0; c < b.length && c < a.length; c++)if (!Vc(a[c], b[c])) return false;
            return true;
        }
        function He(a, b, c, d, e, f) {
            Be = f;
            J = b;
            b.memoizedState = null;
            b.updateQueue = null;
            b.lanes = 0;
            ze.current = null === a || null === a.memoizedState ? Ie : Je;
            a = c(d, e);
            if (De) {
                f = 0;
                do {
                    De = false;
                    Ee = 0;
                    if (25 <= f) throw Error(n(301));
                    f += 1;
                    L = K = null;
                    b.updateQueue = null;
                    ze.current = Ke;
                    a = c(d, e);
                }while (De);
            }
            ze.current = Le;
            b = null !== K && null !== K.next;
            Be = 0;
            L = K = J = null;
            Ce = false;
            if (b) throw Error(n(300));
            return a;
        }
        function Me() {
            var a = 0 !== Ee;
            Ee = 0;
            return a;
        }
        function Ne() {
            var a = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            null === L ? J.memoizedState = L = a : L = L.next = a;
            return L;
        }
        function Oe() {
            if (null === K) {
                var a = J.alternate;
                a = null !== a ? a.memoizedState : null;
            } else a = K.next;
            var b = null === L ? J.memoizedState : L.next;
            if (null !== b) L = b, K = a;
            else {
                if (null === a) throw Error(n(310));
                K = a;
                a = {
                    memoizedState: K.memoizedState,
                    baseState: K.baseState,
                    baseQueue: K.baseQueue,
                    queue: K.queue,
                    next: null
                };
                null === L ? J.memoizedState = L = a : L = L.next = a;
            }
            return L;
        }
        function Pe(a, b) {
            return "function" === typeof b ? b(a) : b;
        }
        function Qe(a) {
            var b = Oe(), c = b.queue;
            if (null === c) throw Error(n(311));
            c.lastRenderedReducer = a;
            var d = K, e = d.baseQueue, f = c.pending;
            if (null !== f) {
                if (null !== e) {
                    var g = e.next;
                    e.next = f.next;
                    f.next = g;
                }
                d.baseQueue = e = f;
                c.pending = null;
            }
            if (null !== e) {
                f = e.next;
                d = d.baseState;
                var h = g = null, k = null, l = f;
                do {
                    var m = l.lane;
                    if ((Be & m) === m) null !== k && (k = k.next = {
                        lane: 0,
                        action: l.action,
                        hasEagerState: l.hasEagerState,
                        eagerState: l.eagerState,
                        next: null
                    }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
                    else {
                        var r = {
                            lane: m,
                            action: l.action,
                            hasEagerState: l.hasEagerState,
                            eagerState: l.eagerState,
                            next: null
                        };
                        null === k ? (h = k = r, g = d) : k = k.next = r;
                        J.lanes |= m;
                        le |= m;
                    }
                    l = l.next;
                }while (null !== l && l !== f);
                null === k ? g = d : k.next = h;
                Vc(d, b.memoizedState) || (G = true);
                b.memoizedState = d;
                b.baseState = g;
                b.baseQueue = k;
                c.lastRenderedState = d;
            }
            a = c.interleaved;
            if (null !== a) {
                e = a;
                do f = e.lane, J.lanes |= f, le |= f, e = e.next;
                while (e !== a);
            } else null === e && (c.lanes = 0);
            return [
                b.memoizedState,
                c.dispatch
            ];
        }
        function Re(a) {
            var b = Oe(), c = b.queue;
            if (null === c) throw Error(n(311));
            c.lastRenderedReducer = a;
            var d = c.dispatch, e = c.pending, f = b.memoizedState;
            if (null !== e) {
                c.pending = null;
                var g = e = e.next;
                do f = a(f, g.action), g = g.next;
                while (g !== e);
                Vc(f, b.memoizedState) || (G = true);
                b.memoizedState = f;
                null === b.baseQueue && (b.baseState = f);
                c.lastRenderedState = f;
            }
            return [
                f,
                d
            ];
        }
        function Se() {}
        function Te(a, b) {
            var c = J, d = Oe(), e = b(), f = !Vc(d.memoizedState, e);
            f && (d.memoizedState = e, G = true);
            d = d.queue;
            Ue(Ve.bind(null, c, d, a), [
                a
            ]);
            if (d.getSnapshot !== b || f || null !== L && L.memoizedState.tag & 1) {
                c.flags |= 2048;
                We(9, Xe.bind(null, c, d, e, b), void 0, null);
                if (null === N) throw Error(n(349));
                0 !== (Be & 30) || Ye(c, b, e);
            }
            return e;
        }
        function Ye(a, b, c) {
            a.flags |= 16384;
            a = {
                getSnapshot: b,
                value: c
            };
            b = J.updateQueue;
            null === b ? (b = {
                lastEffect: null,
                stores: null
            }, J.updateQueue = b, b.stores = [
                a
            ]) : (c = b.stores, null === c ? b.stores = [
                a
            ] : c.push(a));
        }
        function Xe(a, b, c, d) {
            b.value = c;
            b.getSnapshot = d;
            Ze(b) && $e(a);
        }
        function Ve(a, b, c) {
            return c(function() {
                Ze(b) && $e(a);
            });
        }
        function Ze(a) {
            var b = a.getSnapshot;
            a = a.value;
            try {
                var c = b();
                return !Vc(a, c);
            } catch (d) {
                return true;
            }
        }
        function $e(a) {
            var b = ce(a, 1);
            null !== b && af(b, a, 1, -1);
        }
        function bf(a) {
            var b = Ne();
            "function" === typeof a && (a = a());
            b.memoizedState = b.baseState = a;
            a = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Pe,
                lastRenderedState: a
            };
            b.queue = a;
            a = a.dispatch = cf.bind(null, J, a);
            return [
                b.memoizedState,
                a
            ];
        }
        function We(a, b, c, d) {
            a = {
                tag: a,
                create: b,
                destroy: c,
                deps: d,
                next: null
            };
            b = J.updateQueue;
            null === b ? (b = {
                lastEffect: null,
                stores: null
            }, J.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
            return a;
        }
        function df() {
            return Oe().memoizedState;
        }
        function ef(a, b, c, d) {
            var e = Ne();
            J.flags |= a;
            e.memoizedState = We(1 | b, c, void 0, void 0 === d ? null : d);
        }
        function ff(a, b, c, d) {
            var e = Oe();
            d = void 0 === d ? null : d;
            var f = void 0;
            if (null !== K) {
                var g = K.memoizedState;
                f = g.destroy;
                if (null !== d && Ge(d, g.deps)) {
                    e.memoizedState = We(b, c, f, d);
                    return;
                }
            }
            J.flags |= a;
            e.memoizedState = We(1 | b, c, f, d);
        }
        function gf(a, b) {
            return ef(8390656, 8, a, b);
        }
        function Ue(a, b) {
            return ff(2048, 8, a, b);
        }
        function hf(a, b) {
            return ff(4, 2, a, b);
        }
        function jf(a, b) {
            return ff(4, 4, a, b);
        }
        function kf(a, b) {
            if ("function" === typeof b) return a = a(), b(a), function() {
                b(null);
            };
            if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
                b.current = null;
            };
        }
        function lf(a, b, c) {
            c = null !== c && void 0 !== c ? c.concat([
                a
            ]) : null;
            return ff(4, 4, kf.bind(null, b, a), c);
        }
        function mf() {}
        function nf(a, b) {
            var c = Oe();
            b = void 0 === b ? null : b;
            var d = c.memoizedState;
            if (null !== d && null !== b && Ge(b, d[1])) return d[0];
            c.memoizedState = [
                a,
                b
            ];
            return a;
        }
        function of(a, b) {
            var c = Oe();
            b = void 0 === b ? null : b;
            var d = c.memoizedState;
            if (null !== d && null !== b && Ge(b, d[1])) return d[0];
            a = a();
            c.memoizedState = [
                a,
                b
            ];
            return a;
        }
        function pf(a, b, c) {
            if (0 === (Be & 21)) return a.baseState && (a.baseState = false, G = true), a.memoizedState = c;
            Vc(c, b) || (c = Dc(), J.lanes |= c, le |= c, a.baseState = true);
            return b;
        }
        function qf(a, b) {
            var c = C;
            C = 0 !== c && 4 > c ? c : 4;
            a(true);
            var d = Ae.transition;
            Ae.transition = {};
            try {
                a(!1), b();
            } finally{
                C = c, Ae.transition = d;
            }
        }
        function rf() {
            return Oe().memoizedState;
        }
        function sf(a, b, c) {
            var d = tf(a);
            c = {
                lane: d,
                action: c,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (uf(a)) vf(b, c);
            else if (c = be(a, b, c, d), null !== c) {
                var e = O();
                af(c, a, d, e);
                wf(c, b, d);
            }
        }
        function cf(a, b, c) {
            var d = tf(a), e = {
                lane: d,
                action: c,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (uf(a)) vf(b, e);
            else {
                var f = a.alternate;
                if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
                    var g = b.lastRenderedState, h = f(g, c);
                    e.hasEagerState = !0;
                    e.eagerState = h;
                    if (Vc(h, g)) {
                        var k = b.interleaved;
                        null === k ? (e.next = e, ae(b)) : (e.next = k.next, k.next = e);
                        b.interleaved = e;
                        return;
                    }
                } catch (l) {} finally{}
                c = be(a, b, e, d);
                null !== c && (e = O(), af(c, a, d, e), wf(c, b, d));
            }
        }
        function uf(a) {
            var b = a.alternate;
            return a === J || null !== b && b === J;
        }
        function vf(a, b) {
            De = Ce = true;
            var c = a.pending;
            null === c ? b.next = b : (b.next = c.next, c.next = b);
            a.pending = b;
        }
        function wf(a, b, c) {
            if (0 !== (c & 4194240)) {
                var d = b.lanes;
                d &= a.pendingLanes;
                c |= d;
                b.lanes = c;
                Hc(a, c);
            }
        }
        var Le = {
            readContext: Zd,
            useCallback: M,
            useContext: M,
            useEffect: M,
            useImperativeHandle: M,
            useInsertionEffect: M,
            useLayoutEffect: M,
            useMemo: M,
            useReducer: M,
            useRef: M,
            useState: M,
            useDebugValue: M,
            useDeferredValue: M,
            useTransition: M,
            useMutableSource: M,
            useSyncExternalStore: M,
            useId: M,
            unstable_isNewReconciler: false
        }, Ie = {
            readContext: Zd,
            useCallback: function useCallback(a, b) {
                Ne().memoizedState = [
                    a,
                    void 0 === b ? null : b
                ];
                return a;
            },
            useContext: Zd,
            useEffect: gf,
            useImperativeHandle: function useImperativeHandle(a, b, c) {
                c = null !== c && void 0 !== c ? c.concat([
                    a
                ]) : null;
                return ef(4194308, 4, kf.bind(null, b, a), c);
            },
            useLayoutEffect: function useLayoutEffect(a, b) {
                return ef(4194308, 4, a, b);
            },
            useInsertionEffect: function useInsertionEffect(a, b) {
                return ef(4, 2, a, b);
            },
            useMemo: function useMemo(a, b) {
                var c = Ne();
                b = void 0 === b ? null : b;
                a = a();
                c.memoizedState = [
                    a,
                    b
                ];
                return a;
            },
            useReducer: function useReducer(a, b, c) {
                var d = Ne();
                b = void 0 !== c ? c(b) : b;
                d.memoizedState = d.baseState = b;
                a = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: a,
                    lastRenderedState: b
                };
                d.queue = a;
                a = a.dispatch = sf.bind(null, J, a);
                return [
                    d.memoizedState,
                    a
                ];
            },
            useRef: function useRef(a) {
                var b = Ne();
                a = {
                    current: a
                };
                return b.memoizedState = a;
            },
            useState: bf,
            useDebugValue: mf,
            useDeferredValue: function useDeferredValue(a) {
                return Ne().memoizedState = a;
            },
            useTransition: function useTransition() {
                var a = bf(false), b = a[0];
                a = qf.bind(null, a[1]);
                Ne().memoizedState = a;
                return [
                    b,
                    a
                ];
            },
            useMutableSource: function useMutableSource() {},
            useSyncExternalStore: function useSyncExternalStore(a, b, c) {
                var d = J, e = Ne();
                if (F) {
                    if (void 0 === c) throw Error(n(407));
                    c = c();
                } else {
                    c = b();
                    if (null === N) throw Error(n(349));
                    0 !== (Be & 30) || Ye(d, b, c);
                }
                e.memoizedState = c;
                var f = {
                    value: c,
                    getSnapshot: b
                };
                e.queue = f;
                gf(Ve.bind(null, d, f, a), [
                    a
                ]);
                d.flags |= 2048;
                We(9, Xe.bind(null, d, f, c, b), void 0, null);
                return c;
            },
            useId: function useId() {
                var a = Ne(), b = N.identifierPrefix;
                if (F) {
                    var c = jd;
                    var d = id;
                    c = (d & ~(1 << 32 - tc(d) - 1)).toString(32) + c;
                    b = ":" + b + "R" + c;
                    c = Ee++;
                    0 < c && (b += "H" + c.toString(32));
                    b += ":";
                } else c = Fe++, b = ":" + b + "r" + c.toString(32) + ":";
                return a.memoizedState = b;
            },
            unstable_isNewReconciler: false
        }, Je = {
            readContext: Zd,
            useCallback: nf,
            useContext: Zd,
            useEffect: Ue,
            useImperativeHandle: lf,
            useInsertionEffect: hf,
            useLayoutEffect: jf,
            useMemo: of,
            useReducer: Qe,
            useRef: df,
            useState: function useState() {
                return Qe(Pe);
            },
            useDebugValue: mf,
            useDeferredValue: function useDeferredValue(a) {
                var b = Oe();
                return pf(b, K.memoizedState, a);
            },
            useTransition: function useTransition() {
                var a = Qe(Pe)[0], b = Oe().memoizedState;
                return [
                    a,
                    b
                ];
            },
            useMutableSource: Se,
            useSyncExternalStore: Te,
            useId: rf,
            unstable_isNewReconciler: false
        }, Ke = {
            readContext: Zd,
            useCallback: nf,
            useContext: Zd,
            useEffect: Ue,
            useImperativeHandle: lf,
            useInsertionEffect: hf,
            useLayoutEffect: jf,
            useMemo: of,
            useReducer: Re,
            useRef: df,
            useState: function useState() {
                return Re(Pe);
            },
            useDebugValue: mf,
            useDeferredValue: function useDeferredValue(a) {
                var b = Oe();
                return null === K ? b.memoizedState = a : pf(b, K.memoizedState, a);
            },
            useTransition: function useTransition() {
                var a = Re(Pe)[0], b = Oe().memoizedState;
                return [
                    a,
                    b
                ];
            },
            useMutableSource: Se,
            useSyncExternalStore: Te,
            useId: rf,
            unstable_isNewReconciler: false
        };
        function xf(a, b) {
            if (a && a.defaultProps) {
                b = ca({}, b);
                a = a.defaultProps;
                for(var c in a)void 0 === b[c] && (b[c] = a[c]);
                return b;
            }
            return b;
        }
        function yf(a, b, c, d) {
            b = a.memoizedState;
            c = c(d, b);
            c = null === c || void 0 === c ? b : ca({}, b, c);
            a.memoizedState = c;
            0 === a.lanes && (a.updateQueue.baseState = c);
        }
        var zf = {
            isMounted: function isMounted(a) {
                return (a = a._reactInternals) ? wa(a) === a : false;
            },
            enqueueSetState: function enqueueSetState(a, b, c) {
                a = a._reactInternals;
                var d = O(), e = tf(a), f = ge(d, e);
                f.payload = b;
                void 0 !== c && null !== c && (f.callback = c);
                b = he(a, f, e);
                null !== b && (af(b, a, e, d), ie(b, a, e));
            },
            enqueueReplaceState: function enqueueReplaceState(a, b, c) {
                a = a._reactInternals;
                var d = O(), e = tf(a), f = ge(d, e);
                f.tag = 1;
                f.payload = b;
                void 0 !== c && null !== c && (f.callback = c);
                b = he(a, f, e);
                null !== b && (af(b, a, e, d), ie(b, a, e));
            },
            enqueueForceUpdate: function enqueueForceUpdate(a, b) {
                a = a._reactInternals;
                var c = O(), d = tf(a), e = ge(c, d);
                e.tag = 2;
                void 0 !== b && null !== b && (e.callback = b);
                b = he(a, e, d);
                null !== b && (af(b, a, d, c), ie(b, a, d));
            }
        };
        function Af(a, b, c, d, e, f, g) {
            a = a.stateNode;
            return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Dd(c, d) || !Dd(e, f) : true;
        }
        function Bf(a, b, c) {
            var d = false, e = jc;
            var f = b.contextType;
            "object" === (typeof f === "undefined" ? "undefined" : _type_of(f)) && null !== f ? f = Zd(f) : (e = A(b) ? kc : x.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? mc(a, e) : jc);
            b = new b(c, f);
            a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
            b.updater = zf;
            a.stateNode = b;
            b._reactInternals = a;
            d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
            return b;
        }
        function Cf(a, b, c, d) {
            a = b.state;
            "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
            "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
            b.state !== a && zf.enqueueReplaceState(b, b.state, null);
        }
        function Df(a, b, c, d) {
            var e = a.stateNode;
            e.props = c;
            e.state = a.memoizedState;
            e.refs = {};
            ee(a);
            var f = b.contextType;
            "object" === (typeof f === "undefined" ? "undefined" : _type_of(f)) && null !== f ? e.context = Zd(f) : (f = A(b) ? kc : x.current, e.context = mc(a, f));
            e.state = a.memoizedState;
            f = b.getDerivedStateFromProps;
            "function" === typeof f && (yf(a, b, f, c), e.state = a.memoizedState);
            "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && zf.enqueueReplaceState(e, e.state, null), ke(a, c, e, d), e.state = a.memoizedState);
            "function" === typeof e.componentDidMount && (a.flags |= 4194308);
        }
        function Ef(a, b) {
            try {
                var c = "", d = b;
                do c += Ed(d), d = d.return;
                while (d);
                var e = c;
            } catch (f) {
                e = "\nError generating stack: " + f.message + "\n" + f.stack;
            }
            return {
                value: a,
                source: b,
                stack: e,
                digest: null
            };
        }
        function Ff(a, b, c) {
            return {
                value: a,
                source: null,
                stack: null != c ? c : null,
                digest: null != b ? b : null
            };
        }
        function Gf(a, b) {
            try {
                console.error(b.value);
            } catch (c) {
                setTimeout(function() {
                    throw c;
                });
            }
        }
        var Hf = "function" === typeof WeakMap ? WeakMap : Map;
        function If(a, b, c) {
            c = ge(-1, c);
            c.tag = 3;
            c.payload = {
                element: null
            };
            var d = b.value;
            c.callback = function() {
                Jf || (Jf = true, Kf = d);
                Gf(a, b);
            };
            return c;
        }
        function Lf(a, b, c) {
            c = ge(-1, c);
            c.tag = 3;
            var d = a.type.getDerivedStateFromError;
            if ("function" === typeof d) {
                var e = b.value;
                c.payload = function() {
                    return d(e);
                };
                c.callback = function() {
                    Gf(a, b);
                };
            }
            var f = a.stateNode;
            null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
                Gf(a, b);
                "function" !== typeof d && (null === Mf ? Mf = new Set([
                    this
                ]) : Mf.add(this));
                var _$c = b.stack;
                this.componentDidCatch(b.value, {
                    componentStack: null !== _$c ? _$c : ""
                });
            });
            return c;
        }
        function Nf(a, b, c) {
            var d = a.pingCache;
            if (null === d) {
                d = a.pingCache = new Hf;
                var e = new Set;
                d.set(b, e);
            } else e = d.get(b), void 0 === e && (e = new Set, d.set(b, e));
            e.has(c) || (e.add(c), a = Of.bind(null, a, b, c), b.then(a, a));
        }
        function Pf(a) {
            do {
                var b;
                if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
                if (b) return a;
                a = a.return;
            }while (null !== a);
            return null;
        }
        function Qf(a, b, c, d, e) {
            if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ge(-1, 1), b.tag = 2, he(c, b, 1))), c.lanes |= 1), a;
            a.flags |= 65536;
            a.lanes = e;
            return a;
        }
        var Rf = da.ReactCurrentOwner, G = false;
        function P(a, b, c, d) {
            b.child = null === a ? Pd(b, null, c, d) : Od(b, a.child, c, d);
        }
        function Sf(a, b, c, d, e) {
            c = c.render;
            var f = b.ref;
            Yd(b, e);
            d = He(a, b, c, d, f, e);
            c = Me();
            if (null !== a && !G) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Tf(a, b, e);
            F && c && md(b);
            b.flags |= 1;
            P(a, b, d, e);
            return b.child;
        }
        function Uf(a, b, c, d, e) {
            if (null === a) {
                var f = c.type;
                if ("function" === typeof f && !Vf(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, Wf(a, b, f, d, e);
                a = Ld(c.type, null, d, b, b.mode, e);
                a.ref = b.ref;
                a.return = b;
                return b.child = a;
            }
            f = a.child;
            if (0 === (a.lanes & e)) {
                var g = f.memoizedProps;
                c = c.compare;
                c = null !== c ? c : Dd;
                if (c(g, d) && a.ref === b.ref) return Tf(a, b, e);
            }
            b.flags |= 1;
            a = Jd(f, d);
            a.ref = b.ref;
            a.return = b;
            return b.child = a;
        }
        function Wf(a, b, c, d, e) {
            if (null !== a) {
                var f = a.memoizedProps;
                if (Dd(f, d) && a.ref === b.ref) if (G = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (G = true);
                else return b.lanes = a.lanes, Tf(a, b, e);
            }
            return Xf(a, b, c, d, e);
        }
        function Yf(a, b, c) {
            var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
            if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, v(Zf, $f), $f |= c;
            else {
                if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
                    baseLanes: a,
                    cachePool: null,
                    transitions: null
                }, b.updateQueue = null, v(Zf, $f), $f |= a, null;
                b.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                };
                d = null !== f ? f.baseLanes : c;
                v(Zf, $f);
                $f |= d;
            }
            else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, v(Zf, $f), $f |= d;
            P(a, b, e, c);
            return b.child;
        }
        function ag(a, b) {
            var c = b.ref;
            if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
        }
        function Xf(a, b, c, d, e) {
            var f = A(c) ? kc : x.current;
            f = mc(b, f);
            Yd(b, e);
            c = He(a, b, c, d, f, e);
            d = Me();
            if (null !== a && !G) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Tf(a, b, e);
            F && d && md(b);
            b.flags |= 1;
            P(a, b, c, e);
            return b.child;
        }
        function bg(a, b, c, d, e) {
            if (A(c)) {
                var f = true;
                qc(b);
            } else f = false;
            Yd(b, e);
            if (null === b.stateNode) cg(a, b), Bf(b, c, d), Df(b, c, d, e), d = true;
            else if (null === a) {
                var g = b.stateNode, h = b.memoizedProps;
                g.props = h;
                var k = g.context, l = c.contextType;
                "object" === (typeof l === "undefined" ? "undefined" : _type_of(l)) && null !== l ? l = Zd(l) : (l = A(c) ? kc : x.current, l = mc(b, l));
                var m = c.getDerivedStateFromProps, r = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
                r || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Cf(b, g, d, l);
                de = false;
                var p = b.memoizedState;
                g.state = p;
                ke(b, d, g, e);
                k = b.memoizedState;
                h !== d || p !== k || z.current || de ? ("function" === typeof m && (yf(b, c, m, d), k = b.memoizedState), (h = de || Af(b, c, h, d, p, k, l)) ? (r || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
            } else {
                g = b.stateNode;
                fe(a, b);
                h = b.memoizedProps;
                l = b.type === b.elementType ? h : xf(b.type, h);
                g.props = l;
                r = b.pendingProps;
                p = g.context;
                k = c.contextType;
                "object" === (typeof k === "undefined" ? "undefined" : _type_of(k)) && null !== k ? k = Zd(k) : (k = A(c) ? kc : x.current, k = mc(b, k));
                var B = c.getDerivedStateFromProps;
                (m = "function" === typeof B || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== r || p !== k) && Cf(b, g, d, k);
                de = false;
                p = b.memoizedState;
                g.state = p;
                ke(b, d, g, e);
                var w = b.memoizedState;
                h !== r || p !== w || z.current || de ? ("function" === typeof B && (yf(b, c, B, d), w = b.memoizedState), (l = de || Af(b, c, l, d, p, w, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, w, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, w, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = w), g.props = d, g.state = w, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 1024), d = false);
            }
            return dg(a, b, c, d, f, e);
        }
        function dg(a, b, c, d, e, f) {
            ag(a, b);
            var g = 0 !== (b.flags & 128);
            if (!d && !g) return e && rc(b, c, false), Tf(a, b, f);
            d = b.stateNode;
            Rf.current = b;
            var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
            b.flags |= 1;
            null !== a && g ? (b.child = Od(b, a.child, null, f), b.child = Od(b, null, h, f)) : P(a, b, h, f);
            b.memoizedState = d.state;
            e && rc(b, c, true);
            return b.child;
        }
        function eg(a) {
            var b = a.stateNode;
            b.pendingContext ? oc(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oc(a, b.context, false);
            se(a, b.containerInfo);
        }
        function fg(a, b, c, d, e) {
            Ad();
            Bd(e);
            b.flags |= 256;
            P(a, b, c, d);
            return b.child;
        }
        var gg = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0
        };
        function hg(a) {
            return {
                baseLanes: a,
                cachePool: null,
                transitions: null
            };
        }
        function ig(a, b, c) {
            var d = b.pendingProps, e = I.current, f = false, g = 0 !== (b.flags & 128), h;
            (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
            if (h) f = true, b.flags &= -129;
            else if (null === a || null !== a.memoizedState) e |= 1;
            v(I, e & 1);
            if (null === a) {
                wd(b);
                a = b.memoizedState;
                if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : Kb(a) ? b.lanes = 8 : b.lanes = 1073741824, null;
                g = d.children;
                a = d.fallback;
                return f ? (d = b.mode, f = b.child, g = {
                    mode: "hidden",
                    children: g
                }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = jg(g, d, 0, null), a = Nd(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = hg(c), b.memoizedState = gg, a) : kg(b, g);
            }
            e = a.memoizedState;
            if (null !== e && (h = e.dehydrated, null !== h)) return lg(a, b, g, d, h, e, c);
            if (f) {
                f = d.fallback;
                g = b.mode;
                e = a.child;
                h = e.sibling;
                var k = {
                    mode: "hidden",
                    children: d.children
                };
                0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Jd(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
                null !== h ? f = Jd(h, f) : (f = Nd(f, g, c, null), f.flags |= 2);
                f.return = b;
                d.return = b;
                d.sibling = f;
                b.child = d;
                d = f;
                f = b.child;
                g = a.child.memoizedState;
                g = null === g ? hg(c) : {
                    baseLanes: g.baseLanes | c,
                    cachePool: null,
                    transitions: g.transitions
                };
                f.memoizedState = g;
                f.childLanes = a.childLanes & ~c;
                b.memoizedState = gg;
                return d;
            }
            f = a.child;
            a = f.sibling;
            d = Jd(f, {
                mode: "visible",
                children: d.children
            });
            0 === (b.mode & 1) && (d.lanes = c);
            d.return = b;
            d.sibling = null;
            null !== a && (c = b.deletions, null === c ? (b.deletions = [
                a
            ], b.flags |= 16) : c.push(a));
            b.child = d;
            b.memoizedState = null;
            return d;
        }
        function kg(a, b) {
            b = jg({
                mode: "visible",
                children: b
            }, a.mode, 0, null);
            b.return = a;
            return a.child = b;
        }
        function mg(a, b, c, d) {
            null !== d && Bd(d);
            Od(b, a.child, null, c);
            a = kg(b, b.pendingProps.children);
            a.flags |= 2;
            b.memoizedState = null;
            return a;
        }
        function lg(a, b, c, d, e, f, g) {
            if (c) {
                if (b.flags & 256) return b.flags &= -257, d = Ff(Error(n(422))), mg(a, b, g, d);
                if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
                f = d.fallback;
                e = b.mode;
                d = jg({
                    mode: "visible",
                    children: d.children
                }, e, 0, null);
                f = Nd(f, e, g, null);
                f.flags |= 2;
                d.return = b;
                f.return = b;
                d.sibling = f;
                b.child = d;
                0 !== (b.mode & 1) && Od(b, a.child, null, g);
                b.child.memoizedState = hg(g);
                b.memoizedState = gg;
                return f;
            }
            if (0 === (b.mode & 1)) return mg(a, b, g, null);
            if (Kb(e)) return d = Lb(e).digest, f = Error(n(419)), d = Ff(f, d, void 0), mg(a, b, g, d);
            c = 0 !== (g & a.childLanes);
            if (G || c) {
                d = N;
                if (null !== d) {
                    switch(g & -g){
                        case 4:
                            e = 2;
                            break;
                        case 16:
                            e = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            e = 32;
                            break;
                        case 536870912:
                            e = 268435456;
                            break;
                        default:
                            e = 0;
                    }
                    e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
                    0 !== e && e !== f.retryLane && (f.retryLane = e, ce(a, e), af(d, a, e, -1));
                }
                ng();
                d = Ff(Error(n(421)));
                return mg(a, b, g, d);
            }
            if (Jb(e)) return b.flags |= 128, b.child = a.child, b = og.bind(null, a), Mb(e, b), null;
            a = f.treeContext;
            Va && (pd = Qb(e), od = b, F = true, rd = null, qd = false, null !== a && (fd[gd++] = id, fd[gd++] = jd, fd[gd++] = hd, id = a.id, jd = a.overflow, hd = b));
            b = kg(b, d.children);
            b.flags |= 4096;
            return b;
        }
        function pg(a, b, c) {
            a.lanes |= b;
            var d = a.alternate;
            null !== d && (d.lanes |= b);
            Xd(a.return, b, c);
        }
        function qg(a, b, c, d, e) {
            var f = a.memoizedState;
            null === f ? a.memoizedState = {
                isBackwards: b,
                rendering: null,
                renderingStartTime: 0,
                last: d,
                tail: c,
                tailMode: e
            } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
        }
        function rg(a, b, c) {
            var d = b.pendingProps, e = d.revealOrder, f = d.tail;
            P(a, b, d.children, c);
            d = I.current;
            if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
            else {
                if (null !== a && 0 !== (a.flags & 128)) a: for(a = b.child; null !== a;){
                    if (13 === a.tag) null !== a.memoizedState && pg(a, c, b);
                    else if (19 === a.tag) pg(a, c, b);
                    else if (null !== a.child) {
                        a.child.return = a;
                        a = a.child;
                        continue;
                    }
                    if (a === b) break a;
                    for(; null === a.sibling;){
                        if (null === a.return || a.return === b) break a;
                        a = a.return;
                    }
                    a.sibling.return = a.return;
                    a = a.sibling;
                }
                d &= 1;
            }
            v(I, d);
            if (0 === (b.mode & 1)) b.memoizedState = null;
            else switch(e){
                case "forwards":
                    c = b.child;
                    for(e = null; null !== c;)a = c.alternate, null !== a && null === we(a) && (e = c), c = c.sibling;
                    c = e;
                    null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
                    qg(b, false, e, c, f);
                    break;
                case "backwards":
                    c = null;
                    e = b.child;
                    for(b.child = null; null !== e;){
                        a = e.alternate;
                        if (null !== a && null === we(a)) {
                            b.child = e;
                            break;
                        }
                        a = e.sibling;
                        e.sibling = c;
                        c = e;
                        e = a;
                    }
                    qg(b, true, c, null, f);
                    break;
                case "together":
                    qg(b, false, null, null, void 0);
                    break;
                default:
                    b.memoizedState = null;
            }
            return b.child;
        }
        function cg(a, b) {
            0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        }
        function Tf(a, b, c) {
            null !== a && (b.dependencies = a.dependencies);
            le |= b.lanes;
            if (0 === (c & b.childLanes)) return null;
            if (null !== a && b.child !== a.child) throw Error(n(153));
            if (null !== b.child) {
                a = b.child;
                c = Jd(a, a.pendingProps);
                b.child = c;
                for(c.return = b; null !== a.sibling;)a = a.sibling, c = c.sibling = Jd(a, a.pendingProps), c.return = b;
                c.sibling = null;
            }
            return b.child;
        }
        function sg(a, b, c) {
            switch(b.tag){
                case 3:
                    eg(b);
                    Ad();
                    break;
                case 5:
                    ue(b);
                    break;
                case 1:
                    A(b.type) && qc(b);
                    break;
                case 4:
                    se(b, b.stateNode.containerInfo);
                    break;
                case 10:
                    Vd(b, b.type._context, b.memoizedProps.value);
                    break;
                case 13:
                    var d = b.memoizedState;
                    if (null !== d) {
                        if (null !== d.dehydrated) return v(I, I.current & 1), b.flags |= 128, null;
                        if (0 !== (c & b.child.childLanes)) return ig(a, b, c);
                        v(I, I.current & 1);
                        a = Tf(a, b, c);
                        return null !== a ? a.sibling : null;
                    }
                    v(I, I.current & 1);
                    break;
                case 19:
                    d = 0 !== (c & b.childLanes);
                    if (0 !== (a.flags & 128)) {
                        if (d) return rg(a, b, c);
                        b.flags |= 128;
                    }
                    var e = b.memoizedState;
                    null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
                    v(I, I.current);
                    if (d) break;
                    else return null;
                case 22:
                case 23:
                    return b.lanes = 0, Yf(a, b, c);
            }
            return Tf(a, b, c);
        }
        function tg(a) {
            a.flags |= 4;
        }
        function ug(a, b) {
            if (null !== a && a.child === b.child) return true;
            if (0 !== (b.flags & 16)) return false;
            for(a = b.child; null !== a;){
                if (0 !== (a.flags & 12854) || 0 !== (a.subtreeFlags & 12854)) return false;
                a = a.sibling;
            }
            return true;
        }
        var vg, wg, xg, yg;
        if (Ta) vg = function vg(a, b) {
            for(var c = b.child; null !== c;){
                if (5 === c.tag || 6 === c.tag) Ka(a, c.stateNode);
                else if (4 !== c.tag && null !== c.child) {
                    c.child.return = c;
                    c = c.child;
                    continue;
                }
                if (c === b) break;
                for(; null === c.sibling;){
                    if (null === c.return || c.return === b) return;
                    c = c.return;
                }
                c.sibling.return = c.return;
                c = c.sibling;
            }
        }, wg = function wg() {}, xg = function xg(a, b, c, d, e) {
            a = a.memoizedProps;
            if (a !== d) {
                var f = b.stateNode, g = re(oe.current);
                c = Ma(f, c, a, d, e, g);
                (b.updateQueue = c) && tg(b);
            }
        }, yg = function yg(a, b, c, d) {
            c !== d && tg(b);
        };
        else if (Ua) {
            vg = function(a, b, c, d) {
                for(var e = b.child; null !== e;){
                    if (5 === e.tag) {
                        var f = e.stateNode;
                        c && d && (f = Eb(f, e.type, e.memoizedProps, e));
                        Ka(a, f);
                    } else if (6 === e.tag) f = e.stateNode, c && d && (f = Fb(f, e.memoizedProps, e)), Ka(a, f);
                    else if (4 !== e.tag) {
                        if (22 === e.tag && null !== e.memoizedState) f = e.child, null !== f && (f.return = e), vg(a, e, true, true);
                        else if (null !== e.child) {
                            e.child.return = e;
                            e = e.child;
                            continue;
                        }
                    }
                    if (e === b) break;
                    for(; null === e.sibling;){
                        if (null === e.return || e.return === b) return;
                        e = e.return;
                    }
                    e.sibling.return = e.return;
                    e = e.sibling;
                }
            };
            var zg = function zg1(a, b, c, d) {
                for(var e = b.child; null !== e;){
                    if (5 === e.tag) {
                        var f = e.stateNode;
                        c && d && (f = Eb(f, e.type, e.memoizedProps, e));
                        Ab(a, f);
                    } else if (6 === e.tag) f = e.stateNode, c && d && (f = Fb(f, e.memoizedProps, e)), Ab(a, f);
                    else if (4 !== e.tag) {
                        if (22 === e.tag && null !== e.memoizedState) f = e.child, null !== f && (f.return = e), zg(a, e, true, true);
                        else if (null !== e.child) {
                            e.child.return = e;
                            e = e.child;
                            continue;
                        }
                    }
                    if (e === b) break;
                    for(; null === e.sibling;){
                        if (null === e.return || e.return === b) return;
                        e = e.return;
                    }
                    e.sibling.return = e.return;
                    e = e.sibling;
                }
            };
            wg = function wg(a, b) {
                var c = b.stateNode;
                if (!ug(a, b)) {
                    a = c.containerInfo;
                    var d = zb(a);
                    zg(d, b, false, false);
                    c.pendingChildren = d;
                    tg(b);
                    Bb(a, d);
                }
            };
            xg = function xg(a, b, c, d, e) {
                var f = a.stateNode, g = a.memoizedProps;
                if ((a = ug(a, b)) && g === d) b.stateNode = f;
                else {
                    var h = b.stateNode, k = re(oe.current), l = null;
                    g !== d && (l = Ma(h, c, g, d, e, k));
                    a && null === l ? b.stateNode = f : (f = yb(f, l, c, g, d, b, a, h), La(f, c, d, e, k) && tg(b), b.stateNode = f, a ? tg(b) : vg(f, b, false, false));
                }
            };
            yg = function yg(a, b, c, d) {
                c !== d ? (a = re(qe.current), c = re(oe.current), b.stateNode = Oa(d, a, c, b), tg(b)) : b.stateNode = a.stateNode;
            };
        } else wg = function wg() {}, xg = function xg() {}, yg = function yg() {};
        function Ag(a, b) {
            if (!F) switch(a.tailMode){
                case "hidden":
                    b = a.tail;
                    for(var c = null; null !== b;)null !== b.alternate && (c = b), b = b.sibling;
                    null === c ? a.tail = null : c.sibling = null;
                    break;
                case "collapsed":
                    c = a.tail;
                    for(var d = null; null !== c;)null !== c.alternate && (d = c), c = c.sibling;
                    null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
            }
        }
        function Q(a) {
            var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
            if (b) for(var e = a.child; null !== e;)c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
            else for(e = a.child; null !== e;)c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
            a.subtreeFlags |= d;
            a.childLanes = c;
            return b;
        }
        function Bg(a, b, c) {
            var d = b.pendingProps;
            nd(b);
            switch(b.tag){
                case 2:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return Q(b), null;
                case 1:
                    return A(b.type) && nc(), Q(b), null;
                case 3:
                    c = b.stateNode;
                    te();
                    q(z);
                    q(x);
                    ye();
                    c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null);
                    if (null === a || null === a.child) yd(b) ? tg(b) : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== rd && (Cg(rd), rd = null));
                    wg(a, b);
                    Q(b);
                    return null;
                case 5:
                    ve(b);
                    c = re(qe.current);
                    var e = b.type;
                    if (null !== a && null != b.stateNode) xg(a, b, e, d, c), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
                    else {
                        if (!d) {
                            if (null === b.stateNode) throw Error(n(166));
                            Q(b);
                            return null;
                        }
                        a = re(oe.current);
                        if (yd(b)) {
                            if (!Va) throw Error(n(175));
                            a = Rb(b.stateNode, b.type, b.memoizedProps, c, a, b, !qd);
                            b.updateQueue = a;
                            null !== a && tg(b);
                        } else {
                            var f = Ja(e, d, c, a, b);
                            vg(f, b, false, false);
                            b.stateNode = f;
                            La(f, e, d, c, a) && tg(b);
                        }
                        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
                    }
                    Q(b);
                    return null;
                case 6:
                    if (a && null != b.stateNode) yg(a, b, a.memoizedProps, d);
                    else {
                        if ("string" !== typeof d && null === b.stateNode) throw Error(n(166));
                        a = re(qe.current);
                        c = re(oe.current);
                        if (yd(b)) {
                            if (!Va) throw Error(n(176));
                            a = b.stateNode;
                            c = b.memoizedProps;
                            if (d = Sb(a, c, b, !qd)) {
                                if (e = od, null !== e) switch(e.tag){
                                    case 3:
                                        $b(e.stateNode.containerInfo, a, c, 0 !== (e.mode & 1));
                                        break;
                                    case 5:
                                        ac(e.type, e.memoizedProps, e.stateNode, a, c, 0 !== (e.mode & 1));
                                }
                            }
                            d && tg(b);
                        } else b.stateNode = Oa(d, a, c, b);
                    }
                    Q(b);
                    return null;
                case 13:
                    q(I);
                    d = b.memoizedState;
                    if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
                        if (F && null !== pd && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) zd(), Ad(), b.flags |= 98560, e = false;
                        else if (e = yd(b), null !== d && null !== d.dehydrated) {
                            if (null === a) {
                                if (!e) throw Error(n(318));
                                if (!Va) throw Error(n(344));
                                e = b.memoizedState;
                                e = null !== e ? e.dehydrated : null;
                                if (!e) throw Error(n(317));
                                Tb(e, b);
                            } else Ad(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                            Q(b);
                            e = false;
                        } else null !== rd && (Cg(rd), rd = null), e = true;
                        if (!e) return b.flags & 65536 ? b : null;
                    }
                    if (0 !== (b.flags & 128)) return b.lanes = c, b;
                    c = null !== d;
                    c !== (null !== a && null !== a.memoizedState) && c && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (I.current & 1) ? 0 === R && (R = 3) : ng()));
                    null !== b.updateQueue && (b.flags |= 4);
                    Q(b);
                    return null;
                case 4:
                    return te(), wg(a, b), null === a && Xa(b.stateNode.containerInfo), Q(b), null;
                case 10:
                    return Wd(b.type._context), Q(b), null;
                case 17:
                    return A(b.type) && nc(), Q(b), null;
                case 19:
                    q(I);
                    e = b.memoizedState;
                    if (null === e) return Q(b), null;
                    d = 0 !== (b.flags & 128);
                    f = e.rendering;
                    if (null === f) if (d) Ag(e, false);
                    else {
                        if (0 !== R || null !== a && 0 !== (a.flags & 128)) for(a = b.child; null !== a;){
                            f = we(a);
                            if (null !== f) {
                                b.flags |= 128;
                                Ag(e, false);
                                a = f.updateQueue;
                                null !== a && (b.updateQueue = a, b.flags |= 4);
                                b.subtreeFlags = 0;
                                a = c;
                                for(c = b.child; null !== c;)d = c, e = a, d.flags &= 14680066, f = d.alternate, null === f ? (d.childLanes = 0, d.lanes = e, d.child = null, d.subtreeFlags = 0, d.memoizedProps = null, d.memoizedState = null, d.updateQueue = null, d.dependencies = null, d.stateNode = null) : (d.childLanes = f.childLanes, d.lanes = f.lanes, d.child = f.child, d.subtreeFlags = 0, d.deletions = null, d.memoizedProps = f.memoizedProps, d.memoizedState = f.memoizedState, d.updateQueue = f.updateQueue, d.type = f.type, e = f.dependencies, d.dependencies = null === e ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }), c = c.sibling;
                                v(I, I.current & 1 | 2);
                                return b.child;
                            }
                            a = a.sibling;
                        }
                        null !== e.tail && D() > Dg && (b.flags |= 128, d = true, Ag(e, false), b.lanes = 4194304);
                    }
                    else {
                        if (!d) if (a = we(f), null !== a) {
                            if (b.flags |= 128, d = true, a = a.updateQueue, null !== a && (b.updateQueue = a, b.flags |= 4), Ag(e, true), null === e.tail && "hidden" === e.tailMode && !f.alternate && !F) return Q(b), null;
                        } else 2 * D() - e.renderingStartTime > Dg && 1073741824 !== c && (b.flags |= 128, d = true, Ag(e, false), b.lanes = 4194304);
                        e.isBackwards ? (f.sibling = b.child, b.child = f) : (a = e.last, null !== a ? a.sibling = f : b.child = f, e.last = f);
                    }
                    if (null !== e.tail) return b = e.tail, e.rendering = b, e.tail = b.sibling, e.renderingStartTime = D(), b.sibling = null, a = I.current, v(I, d ? a & 1 | 2 : a & 1), b;
                    Q(b);
                    return null;
                case 22:
                case 23:
                    return Eg(), c = null !== b.memoizedState, null !== a && null !== a.memoizedState !== c && (b.flags |= 8192), c && 0 !== (b.mode & 1) ? 0 !== ($f & 1073741824) && (Q(b), Ta && b.subtreeFlags & 6 && (b.flags |= 8192)) : Q(b), null;
                case 24:
                    return null;
                case 25:
                    return null;
            }
            throw Error(n(156, b.tag));
        }
        function Fg(a, b) {
            nd(b);
            switch(b.tag){
                case 1:
                    return A(b.type) && nc(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
                case 3:
                    return te(), q(z), q(x), ye(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
                case 5:
                    return ve(b), null;
                case 13:
                    q(I);
                    a = b.memoizedState;
                    if (null !== a && null !== a.dehydrated) {
                        if (null === b.alternate) throw Error(n(340));
                        Ad();
                    }
                    a = b.flags;
                    return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
                case 19:
                    return q(I), null;
                case 4:
                    return te(), null;
                case 10:
                    return Wd(b.type._context), null;
                case 22:
                case 23:
                    return Eg(), null;
                case 24:
                    return null;
                default:
                    return null;
            }
        }
        var Gg = false, S = false, Hg = "function" === typeof WeakSet ? WeakSet : Set, T = null;
        function Ig(a, b) {
            var c = a.ref;
            if (null !== c) if ("function" === typeof c) try {
                c(null);
            } catch (d) {
                U(a, b, d);
            }
            else c.current = null;
        }
        function Jg(a, b, c) {
            try {
                c();
            } catch (d) {
                U(a, b, d);
            }
        }
        var Kg = false;
        function Lg(a, b) {
            Ha(a.containerInfo);
            for(T = b; null !== T;)if (a = T, b = a.child, 0 !== (a.subtreeFlags & 1028) && null !== b) b.return = a, T = b;
            else for(; null !== T;){
                a = T;
                try {
                    var c = a.alternate;
                    if (0 !== (a.flags & 1024)) switch(a.tag){
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (null !== c) {
                                var d = c.memoizedProps, e = c.memoizedState, f = a.stateNode, g = f.getSnapshotBeforeUpdate(a.elementType === a.type ? d : xf(a.type, d), e);
                                f.__reactInternalSnapshotBeforeUpdate = g;
                            }
                            break;
                        case 3:
                            Ta && xb(a.stateNode.containerInfo);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(n(163));
                    }
                } catch (h) {
                    U(a, a.return, h);
                }
                b = a.sibling;
                if (null !== b) {
                    b.return = a.return;
                    T = b;
                    break;
                }
                T = a.return;
            }
            c = Kg;
            Kg = false;
            return c;
        }
        function Mg(a, b, c) {
            var d = b.updateQueue;
            d = null !== d ? d.lastEffect : null;
            if (null !== d) {
                var e = d = d.next;
                do {
                    if ((e.tag & a) === a) {
                        var f = e.destroy;
                        e.destroy = void 0;
                        void 0 !== f && Jg(b, c, f);
                    }
                    e = e.next;
                }while (e !== d);
            }
        }
        function Ng(a, b) {
            b = b.updateQueue;
            b = null !== b ? b.lastEffect : null;
            if (null !== b) {
                var c = b = b.next;
                do {
                    if ((c.tag & a) === a) {
                        var d = c.create;
                        c.destroy = d();
                    }
                    c = c.next;
                }while (c !== b);
            }
        }
        function Og(a) {
            var b = a.ref;
            if (null !== b) {
                var c = a.stateNode;
                switch(a.tag){
                    case 5:
                        a = Ea(c);
                        break;
                    default:
                        a = c;
                }
                "function" === typeof b ? b(a) : b.current = a;
            }
        }
        function Pg(a) {
            var b = a.alternate;
            null !== b && (a.alternate = null, Pg(b));
            a.child = null;
            a.deletions = null;
            a.sibling = null;
            5 === a.tag && (b = a.stateNode, null !== b && Za(b));
            a.stateNode = null;
            a.return = null;
            a.dependencies = null;
            a.memoizedProps = null;
            a.memoizedState = null;
            a.pendingProps = null;
            a.stateNode = null;
            a.updateQueue = null;
        }
        function Qg(a) {
            return 5 === a.tag || 3 === a.tag || 4 === a.tag;
        }
        function Rg(a) {
            a: for(;;){
                for(; null === a.sibling;){
                    if (null === a.return || Qg(a.return)) return null;
                    a = a.return;
                }
                a.sibling.return = a.return;
                for(a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;){
                    if (a.flags & 2) continue a;
                    if (null === a.child || 4 === a.tag) continue a;
                    else a.child.return = a, a = a.child;
                }
                if (!(a.flags & 2)) return a.stateNode;
            }
        }
        function Sg(a, b, c) {
            var d = a.tag;
            if (5 === d || 6 === d) a = a.stateNode, b ? pb(c, a, b) : kb(c, a);
            else if (4 !== d && (a = a.child, null !== a)) for(Sg(a, b, c), a = a.sibling; null !== a;)Sg(a, b, c), a = a.sibling;
        }
        function Tg(a, b, c) {
            var d = a.tag;
            if (5 === d || 6 === d) a = a.stateNode, b ? ob(c, a, b) : jb(c, a);
            else if (4 !== d && (a = a.child, null !== a)) for(Tg(a, b, c), a = a.sibling; null !== a;)Tg(a, b, c), a = a.sibling;
        }
        var V = null, Ug = false;
        function Vg(a, b, c) {
            for(c = c.child; null !== c;)Wg(a, b, c), c = c.sibling;
        }
        function Wg(a, b, c) {
            if (Sc && "function" === typeof Sc.onCommitFiberUnmount) try {
                Sc.onCommitFiberUnmount(Rc, c);
            } catch (h) {}
            switch(c.tag){
                case 5:
                    S || Ig(c, b);
                case 6:
                    if (Ta) {
                        var d = V, e = Ug;
                        V = null;
                        Vg(a, b, c);
                        V = d;
                        Ug = e;
                        null !== V && (Ug ? rb(V, c.stateNode) : qb(V, c.stateNode));
                    } else Vg(a, b, c);
                    break;
                case 18:
                    Ta && null !== V && (Ug ? Yb(V, c.stateNode) : Xb(V, c.stateNode));
                    break;
                case 4:
                    Ta ? (d = V, e = Ug, V = c.stateNode.containerInfo, Ug = true, Vg(a, b, c), V = d, Ug = e) : (Ua && (d = c.stateNode.containerInfo, e = zb(d), Cb(d, e)), Vg(a, b, c));
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    if (!S && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
                        e = d = d.next;
                        do {
                            var f = e, g = f.destroy;
                            f = f.tag;
                            void 0 !== g && (0 !== (f & 2) ? Jg(c, b, g) : 0 !== (f & 4) && Jg(c, b, g));
                            e = e.next;
                        }while (e !== d);
                    }
                    Vg(a, b, c);
                    break;
                case 1:
                    if (!S && (Ig(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
                        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
                    } catch (h) {
                        U(c, b, h);
                    }
                    Vg(a, b, c);
                    break;
                case 21:
                    Vg(a, b, c);
                    break;
                case 22:
                    c.mode & 1 ? (S = (d = S) || null !== c.memoizedState, Vg(a, b, c), S = d) : Vg(a, b, c);
                    break;
                default:
                    Vg(a, b, c);
            }
        }
        function Xg(a) {
            var b = a.updateQueue;
            if (null !== b) {
                a.updateQueue = null;
                var c = a.stateNode;
                null === c && (c = a.stateNode = new Hg);
                b.forEach(function(b) {
                    var d = Yg.bind(null, a, b);
                    c.has(b) || (c.add(b), b.then(d, d));
                });
            }
        }
        function Zg(a, b) {
            var c = b.deletions;
            if (null !== c) for(var d = 0; d < c.length; d++){
                var e = c[d];
                try {
                    var f = a, g = b;
                    if (Ta) {
                        var h = g;
                        a: for(; null !== h;){
                            switch(h.tag){
                                case 5:
                                    V = h.stateNode;
                                    Ug = !1;
                                    break a;
                                case 3:
                                    V = h.stateNode.containerInfo;
                                    Ug = !0;
                                    break a;
                                case 4:
                                    V = h.stateNode.containerInfo;
                                    Ug = !0;
                                    break a;
                            }
                            h = h.return;
                        }
                        if (null === V) throw Error(n(160));
                        Wg(f, g, e);
                        V = null;
                        Ug = !1;
                    } else Wg(f, g, e);
                    var k = e.alternate;
                    null !== k && (k.return = null);
                    e.return = null;
                } catch (l) {
                    U(e, b, l);
                }
            }
            if (b.subtreeFlags & 12854) for(b = b.child; null !== b;)$g(b, a), b = b.sibling;
        }
        function $g(a, b) {
            var c = a.alternate, d = a.flags;
            switch(a.tag){
                case 0:
                case 11:
                case 14:
                case 15:
                    Zg(b, a);
                    ah(a);
                    if (d & 4) {
                        try {
                            Mg(3, a, a.return), Ng(3, a);
                        } catch (p) {
                            U(a, a.return, p);
                        }
                        try {
                            Mg(5, a, a.return);
                        } catch (p) {
                            U(a, a.return, p);
                        }
                    }
                    break;
                case 1:
                    Zg(b, a);
                    ah(a);
                    d & 512 && null !== c && Ig(c, c.return);
                    break;
                case 5:
                    Zg(b, a);
                    ah(a);
                    d & 512 && null !== c && Ig(c, c.return);
                    if (Ta) {
                        if (a.flags & 32) {
                            var e = a.stateNode;
                            try {
                                sb(e);
                            } catch (p) {
                                U(a, a.return, p);
                            }
                        }
                        if (d & 4 && (e = a.stateNode, null != e)) {
                            var f = a.memoizedProps;
                            c = null !== c ? c.memoizedProps : f;
                            d = a.type;
                            b = a.updateQueue;
                            a.updateQueue = null;
                            if (null !== b) try {
                                nb(e, b, d, c, f, a);
                            } catch (p) {
                                U(a, a.return, p);
                            }
                        }
                    }
                    break;
                case 6:
                    Zg(b, a);
                    ah(a);
                    if (d & 4 && Ta) {
                        if (null === a.stateNode) throw Error(n(162));
                        e = a.stateNode;
                        f = a.memoizedProps;
                        c = null !== c ? c.memoizedProps : f;
                        try {
                            lb(e, c, f);
                        } catch (p) {
                            U(a, a.return, p);
                        }
                    }
                    break;
                case 3:
                    Zg(b, a);
                    ah(a);
                    if (d & 4) {
                        if (Ta && Va && null !== c && c.memoizedState.isDehydrated) try {
                            Vb(b.containerInfo);
                        } catch (p) {
                            U(a, a.return, p);
                        }
                        if (Ua) {
                            e = b.containerInfo;
                            f = b.pendingChildren;
                            try {
                                Cb(e, f);
                            } catch (p) {
                                U(a, a.return, p);
                            }
                        }
                    }
                    break;
                case 4:
                    Zg(b, a);
                    ah(a);
                    if (d & 4 && Ua) {
                        f = a.stateNode;
                        e = f.containerInfo;
                        f = f.pendingChildren;
                        try {
                            Cb(e, f);
                        } catch (p) {
                            U(a, a.return, p);
                        }
                    }
                    break;
                case 13:
                    Zg(b, a);
                    ah(a);
                    e = a.child;
                    e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (bh = D()));
                    d & 4 && Xg(a);
                    break;
                case 22:
                    var g = null !== c && null !== c.memoizedState;
                    a.mode & 1 ? (S = (c = S) || g, Zg(b, a), S = c) : Zg(b, a);
                    ah(a);
                    if (d & 8192) {
                        c = null !== a.memoizedState;
                        if ((a.stateNode.isHidden = c) && !g && 0 !== (a.mode & 1)) for(T = a, d = a.child; null !== d;){
                            for(b = T = d; null !== T;){
                                g = T;
                                var h = g.child;
                                switch(g.tag){
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        Mg(4, g, g.return);
                                        break;
                                    case 1:
                                        Ig(g, g.return);
                                        var k = g.stateNode;
                                        if ("function" === typeof k.componentWillUnmount) {
                                            var l = g, m = g.return;
                                            try {
                                                var r = l;
                                                k.props = r.memoizedProps;
                                                k.state = r.memoizedState;
                                                k.componentWillUnmount();
                                            } catch (p) {
                                                U(l, m, p);
                                            }
                                        }
                                        break;
                                    case 5:
                                        Ig(g, g.return);
                                        break;
                                    case 22:
                                        if (null !== g.memoizedState) {
                                            ch(b);
                                            continue;
                                        }
                                }
                                null !== h ? (h.return = g, T = h) : ch(b);
                            }
                            d = d.sibling;
                        }
                        if (Ta) {
                            a: if (d = null, Ta) for(b = a;;){
                                if (5 === b.tag) {
                                    if (null === d) {
                                        d = b;
                                        try {
                                            e = b.stateNode, c ? tb(e) : vb(b.stateNode, b.memoizedProps);
                                        } catch (p) {
                                            U(a, a.return, p);
                                        }
                                    }
                                } else if (6 === b.tag) {
                                    if (null === d) try {
                                        f = b.stateNode, c ? ub(f) : wb(f, b.memoizedProps);
                                    } catch (p) {
                                        U(a, a.return, p);
                                    }
                                } else if ((22 !== b.tag && 23 !== b.tag || null === b.memoizedState || b === a) && null !== b.child) {
                                    b.child.return = b;
                                    b = b.child;
                                    continue;
                                }
                                if (b === a) break a;
                                for(; null === b.sibling;){
                                    if (null === b.return || b.return === a) break a;
                                    d === b && (d = null);
                                    b = b.return;
                                }
                                d === b && (d = null);
                                b.sibling.return = b.return;
                                b = b.sibling;
                            }
                        }
                    }
                    break;
                case 19:
                    Zg(b, a);
                    ah(a);
                    d & 4 && Xg(a);
                    break;
                case 21:
                    break;
                default:
                    Zg(b, a), ah(a);
            }
        }
        function ah(a) {
            var b = a.flags;
            if (b & 2) {
                try {
                    if (Ta) {
                        b: {
                            for(var c = a.return; null !== c;){
                                if (Qg(c)) {
                                    var d = c;
                                    break b;
                                }
                                c = c.return;
                            }
                            throw Error(n(160));
                        }
                        switch(d.tag){
                            case 5:
                                var e = d.stateNode;
                                d.flags & 32 && (sb(e), d.flags &= -33);
                                var f = Rg(a);
                                Tg(a, f, e);
                                break;
                            case 3:
                            case 4:
                                var g = d.stateNode.containerInfo, h = Rg(a);
                                Sg(a, h, g);
                                break;
                            default:
                                throw Error(n(161));
                        }
                    }
                } catch (k) {
                    U(a, a.return, k);
                }
                a.flags &= -3;
            }
            b & 4096 && (a.flags &= -4097);
        }
        function dh(a, b, c) {
            T = a;
            eh(a);
        }
        function eh(a, b, c) {
            for(var d = 0 !== (a.mode & 1); null !== T;){
                var e = T, f = e.child;
                if (22 === e.tag && d) {
                    var g = null !== e.memoizedState || Gg;
                    if (!g) {
                        var h = e.alternate, k = null !== h && null !== h.memoizedState || S;
                        h = Gg;
                        var l = S;
                        Gg = g;
                        if ((S = k) && !l) for(T = e; null !== T;)g = T, k = g.child, 22 === g.tag && null !== g.memoizedState ? fh(e) : null !== k ? (k.return = g, T = k) : fh(e);
                        for(; null !== f;)T = f, eh(f), f = f.sibling;
                        T = e;
                        Gg = h;
                        S = l;
                    }
                    gh(a);
                } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, T = f) : gh(a);
            }
        }
        function gh(a) {
            for(; null !== T;){
                var b = T;
                if (0 !== (b.flags & 8772)) {
                    var c = b.alternate;
                    try {
                        if (0 !== (b.flags & 8772)) switch(b.tag){
                            case 0:
                            case 11:
                            case 15:
                                S || Ng(5, b);
                                break;
                            case 1:
                                var d = b.stateNode;
                                if (b.flags & 4 && !S) if (null === c) d.componentDidMount();
                                else {
                                    var e = b.elementType === b.type ? c.memoizedProps : xf(b.type, c.memoizedProps);
                                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                                }
                                var f = b.updateQueue;
                                null !== f && me(b, f, d);
                                break;
                            case 3:
                                var g = b.updateQueue;
                                if (null !== g) {
                                    c = null;
                                    if (null !== b.child) switch(b.child.tag){
                                        case 5:
                                            c = Ea(b.child.stateNode);
                                            break;
                                        case 1:
                                            c = b.child.stateNode;
                                    }
                                    me(b, g, c);
                                }
                                break;
                            case 5:
                                var h = b.stateNode;
                                null === c && b.flags & 4 && mb(h, b.type, b.memoizedProps, b);
                                break;
                            case 6:
                                break;
                            case 4:
                                break;
                            case 12:
                                break;
                            case 13:
                                if (Va && null === b.memoizedState) {
                                    var k = b.alternate;
                                    if (null !== k) {
                                        var l = k.memoizedState;
                                        if (null !== l) {
                                            var m = l.dehydrated;
                                            null !== m && Wb(m);
                                        }
                                    }
                                }
                                break;
                            case 19:
                            case 17:
                            case 21:
                            case 22:
                            case 23:
                            case 25:
                                break;
                            default:
                                throw Error(n(163));
                        }
                        S || b.flags & 512 && Og(b);
                    } catch (r) {
                        U(b, b.return, r);
                    }
                }
                if (b === a) {
                    T = null;
                    break;
                }
                c = b.sibling;
                if (null !== c) {
                    c.return = b.return;
                    T = c;
                    break;
                }
                T = b.return;
            }
        }
        function ch(a) {
            for(; null !== T;){
                var b = T;
                if (b === a) {
                    T = null;
                    break;
                }
                var c = b.sibling;
                if (null !== c) {
                    c.return = b.return;
                    T = c;
                    break;
                }
                T = b.return;
            }
        }
        function fh(a) {
            for(; null !== T;){
                var b = T;
                try {
                    switch(b.tag){
                        case 0:
                        case 11:
                        case 15:
                            var c = b.return;
                            try {
                                Ng(4, b);
                            } catch (k) {
                                U(b, c, k);
                            }
                            break;
                        case 1:
                            var d = b.stateNode;
                            if ("function" === typeof d.componentDidMount) {
                                var e = b.return;
                                try {
                                    d.componentDidMount();
                                } catch (k) {
                                    U(b, e, k);
                                }
                            }
                            var f = b.return;
                            try {
                                Og(b);
                            } catch (k) {
                                U(b, f, k);
                            }
                            break;
                        case 5:
                            var g = b.return;
                            try {
                                Og(b);
                            } catch (k) {
                                U(b, g, k);
                            }
                    }
                } catch (k) {
                    U(b, b.return, k);
                }
                if (b === a) {
                    T = null;
                    break;
                }
                var h = b.sibling;
                if (null !== h) {
                    h.return = b.return;
                    T = h;
                    break;
                }
                T = b.return;
            }
        }
        var hh = 0, ih = 1, jh = 2, kh = 3, lh = 4;
        if ("function" === typeof Symbol && Symbol.for) {
            var mh = Symbol.for;
            hh = mh("selector.component");
            ih = mh("selector.has_pseudo_class");
            jh = mh("selector.role");
            kh = mh("selector.test_id");
            lh = mh("selector.text");
        }
        function nh(a) {
            var b = Wa(a);
            if (null != b) {
                if ("string" !== typeof b.memoizedProps["data-testname"]) throw Error(n(364));
                return b;
            }
            a = cb(a);
            if (null === a) throw Error(n(362));
            return a.stateNode.current;
        }
        function oh(a, b) {
            switch(b.$$typeof){
                case hh:
                    if (a.type === b.value) return true;
                    break;
                case ih:
                    a: {
                        b = b.value;
                        a = [
                            a,
                            0
                        ];
                        for(var c = 0; c < a.length;){
                            var d = a[c++], e = a[c++], f = b[e];
                            if (5 !== d.tag || !fb(d)) {
                                for(; null != f && oh(d, f);)e++, f = b[e];
                                if (e === b.length) {
                                    b = true;
                                    break a;
                                } else for(d = d.child; null !== d;)a.push(d, e), d = d.sibling;
                            }
                        }
                        b = false;
                    }
                    return b;
                case jh:
                    if (5 === a.tag && gb(a.stateNode, b.value)) return true;
                    break;
                case lh:
                    if (5 === a.tag || 6 === a.tag) {
                        if (a = eb(a), null !== a && 0 <= a.indexOf(b.value)) return true;
                    }
                    break;
                case kh:
                    if (5 === a.tag && (a = a.memoizedProps["data-testname"], "string" === typeof a && a.toLowerCase() === b.value.toLowerCase())) return true;
                    break;
                default:
                    throw Error(n(365));
            }
            return false;
        }
        function ph(a) {
            switch(a.$$typeof){
                case hh:
                    return "<" + (ua(a.value) || "Unknown") + ">";
                case ih:
                    return ":has(" + (ph(a) || "") + ")";
                case jh:
                    return '[role="' + a.value + '"]';
                case lh:
                    return '"' + a.value + '"';
                case kh:
                    return '[data-testname="' + a.value + '"]';
                default:
                    throw Error(n(365));
            }
        }
        function qh(a, b) {
            var c = [];
            a = [
                a,
                0
            ];
            for(var d = 0; d < a.length;){
                var e = a[d++], f = a[d++], g = b[f];
                if (5 !== e.tag || !fb(e)) {
                    for(; null != g && oh(e, g);)f++, g = b[f];
                    if (f === b.length) c.push(e);
                    else for(e = e.child; null !== e;)a.push(e, f), e = e.sibling;
                }
            }
            return c;
        }
        function rh(a, b) {
            if (!bb) throw Error(n(363));
            a = nh(a);
            a = qh(a, b);
            b = [];
            a = Array.from(a);
            for(var c = 0; c < a.length;){
                var d = a[c++];
                if (5 === d.tag) fb(d) || b.push(d.stateNode);
                else for(d = d.child; null !== d;)a.push(d), d = d.sibling;
            }
            return b;
        }
        var sh = Math.ceil, th = da.ReactCurrentDispatcher, uh = da.ReactCurrentOwner, W = da.ReactCurrentBatchConfig, H = 0, N = null, X = null, Z = 0, $f = 0, Zf = ic(0), R = 0, vh = null, le = 0, wh = 0, xh = 0, yh = null, zh = null, bh = 0, Dg = Infinity, Ah = null;
        function Bh() {
            Dg = D() + 500;
        }
        var Jf = false, Kf = null, Mf = null, Ch = false, Dh = null, Eh = 0, Fh = 0, Gh = null, Hh = -1, Ih = 0;
        function O() {
            return 0 !== (H & 6) ? D() : -1 !== Hh ? Hh : Hh = D();
        }
        function tf(a) {
            if (0 === (a.mode & 1)) return 1;
            if (0 !== (H & 2) && 0 !== Z) return Z & -Z;
            if (null !== Cd.transition) return 0 === Ih && (Ih = Dc()), Ih;
            a = C;
            return 0 !== a ? a : Ya();
        }
        function af(a, b, c, d) {
            if (50 < Fh) throw Fh = 0, Gh = null, Error(n(185));
            Fc(a, c, d);
            if (0 === (H & 2) || a !== N) a === N && (0 === (H & 2) && (wh |= c), 4 === R && Jh(a, Z)), Kh(a, d), 1 === c && 0 === H && 0 === (b.mode & 1) && (Bh(), Xc && ad());
        }
        function Kh(a, b) {
            var c = a.callbackNode;
            Bc(a, b);
            var d = zc(a, a === N ? Z : 0);
            if (0 === d) null !== c && Kc(c), a.callbackNode = null, a.callbackPriority = 0;
            else if (b = d & -d, a.callbackPriority !== b) {
                null != c && Kc(c);
                if (1 === b) 0 === a.tag ? $c(Lh.bind(null, a)) : Zc(Lh.bind(null, a)), $a ? ab(function() {
                    0 === (H & 6) && ad();
                }) : Jc(Nc, ad), c = null;
                else {
                    switch(Ic(d)){
                        case 1:
                            c = Nc;
                            break;
                        case 4:
                            c = Oc;
                            break;
                        case 16:
                            c = Pc;
                            break;
                        case 536870912:
                            c = Qc;
                            break;
                        default:
                            c = Pc;
                    }
                    c = Mh(c, Nh.bind(null, a));
                }
                a.callbackPriority = b;
                a.callbackNode = c;
            }
        }
        function Nh(a, b) {
            Hh = -1;
            Ih = 0;
            if (0 !== (H & 6)) throw Error(n(327));
            var c = a.callbackNode;
            if (Oh() && a.callbackNode !== c) return null;
            var d = zc(a, a === N ? Z : 0);
            if (0 === d) return null;
            if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ph(a, d);
            else {
                b = d;
                var e = H;
                H |= 2;
                var f = Qh();
                if (N !== a || Z !== b) Ah = null, Bh(), Rh(a, b);
                do try {
                    Sh();
                    break;
                } catch (h) {
                    Th(a, h);
                }
                while (1);
                Ud();
                th.current = f;
                H = e;
                null !== X ? b = 0 : (N = null, Z = 0, b = R);
            }
            if (0 !== b) {
                2 === b && (e = Cc(a), 0 !== e && (d = e, b = Uh(a, e)));
                if (1 === b) throw c = vh, Rh(a, 0), Jh(a, d), Kh(a, D()), c;
                if (6 === b) Jh(a, d);
                else {
                    e = a.current.alternate;
                    if (0 === (d & 30) && !Vh(e) && (b = Ph(a, d), 2 === b && (f = Cc(a), 0 !== f && (d = f, b = Uh(a, f))), 1 === b)) throw c = vh, Rh(a, 0), Jh(a, d), Kh(a, D()), c;
                    a.finishedWork = e;
                    a.finishedLanes = d;
                    switch(b){
                        case 0:
                        case 1:
                            throw Error(n(345));
                        case 2:
                            Wh(a, zh, Ah);
                            break;
                        case 3:
                            Jh(a, d);
                            if ((d & 130023424) === d && (b = bh + 500 - D(), 10 < b)) {
                                if (0 !== zc(a, 0)) break;
                                e = a.suspendedLanes;
                                if ((e & d) !== d) {
                                    O();
                                    a.pingedLanes |= a.suspendedLanes & e;
                                    break;
                                }
                                a.timeoutHandle = Pa(Wh.bind(null, a, zh, Ah), b);
                                break;
                            }
                            Wh(a, zh, Ah);
                            break;
                        case 4:
                            Jh(a, d);
                            if ((d & 4194240) === d) break;
                            b = a.eventTimes;
                            for(e = -1; 0 < d;){
                                var g = 31 - tc(d);
                                f = 1 << g;
                                g = b[g];
                                g > e && (e = g);
                                d &= ~f;
                            }
                            d = e;
                            d = D() - d;
                            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * sh(d / 1960)) - d;
                            if (10 < d) {
                                a.timeoutHandle = Pa(Wh.bind(null, a, zh, Ah), d);
                                break;
                            }
                            Wh(a, zh, Ah);
                            break;
                        case 5:
                            Wh(a, zh, Ah);
                            break;
                        default:
                            throw Error(n(329));
                    }
                }
            }
            Kh(a, D());
            return a.callbackNode === c ? Nh.bind(null, a) : null;
        }
        function Uh(a, b) {
            var c = yh;
            a.current.memoizedState.isDehydrated && (Rh(a, b).flags |= 256);
            a = Ph(a, b);
            2 !== a && (b = zh, zh = c, null !== b && Cg(b));
            return a;
        }
        function Cg(a) {
            null === zh ? zh = a : zh.push.apply(zh, a);
        }
        function Vh(a) {
            for(var b = a;;){
                if (b.flags & 16384) {
                    var c = b.updateQueue;
                    if (null !== c && (c = c.stores, null !== c)) for(var d = 0; d < c.length; d++){
                        var e = c[d], f = e.getSnapshot;
                        e = e.value;
                        try {
                            if (!Vc(f(), e)) return !1;
                        } catch (g) {
                            return false;
                        }
                    }
                }
                c = b.child;
                if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
                else {
                    if (b === a) break;
                    for(; null === b.sibling;){
                        if (null === b.return || b.return === a) return true;
                        b = b.return;
                    }
                    b.sibling.return = b.return;
                    b = b.sibling;
                }
            }
            return true;
        }
        function Jh(a, b) {
            b &= ~xh;
            b &= ~wh;
            a.suspendedLanes |= b;
            a.pingedLanes &= ~b;
            for(a = a.expirationTimes; 0 < b;){
                var c = 31 - tc(b), d = 1 << c;
                a[c] = -1;
                b &= ~d;
            }
        }
        function Lh(a) {
            if (0 !== (H & 6)) throw Error(n(327));
            Oh();
            var b = zc(a, 0);
            if (0 === (b & 1)) return Kh(a, D()), null;
            var c = Ph(a, b);
            if (0 !== a.tag && 2 === c) {
                var d = Cc(a);
                0 !== d && (b = d, c = Uh(a, d));
            }
            if (1 === c) throw c = vh, Rh(a, 0), Jh(a, b), Kh(a, D()), c;
            if (6 === c) throw Error(n(345));
            a.finishedWork = a.current.alternate;
            a.finishedLanes = b;
            Wh(a, zh, Ah);
            Kh(a, D());
            return null;
        }
        function Xh(a) {
            null !== Dh && 0 === Dh.tag && 0 === (H & 6) && Oh();
            var b = H;
            H |= 1;
            var c = W.transition, d = C;
            try {
                if (W.transition = null, C = 1, a) return a();
            } finally{
                C = d, W.transition = c, H = b, 0 === (H & 6) && ad();
            }
        }
        function Eg() {
            $f = Zf.current;
            q(Zf);
        }
        function Rh(a, b) {
            a.finishedWork = null;
            a.finishedLanes = 0;
            var c = a.timeoutHandle;
            c !== Ra && (a.timeoutHandle = Ra, Qa(c));
            if (null !== X) for(c = X.return; null !== c;){
                var d = c;
                nd(d);
                switch(d.tag){
                    case 1:
                        d = d.type.childContextTypes;
                        null !== d && void 0 !== d && nc();
                        break;
                    case 3:
                        te();
                        q(z);
                        q(x);
                        ye();
                        break;
                    case 5:
                        ve(d);
                        break;
                    case 4:
                        te();
                        break;
                    case 13:
                        q(I);
                        break;
                    case 19:
                        q(I);
                        break;
                    case 10:
                        Wd(d.type._context);
                        break;
                    case 22:
                    case 23:
                        Eg();
                }
                c = c.return;
            }
            N = a;
            X = a = Jd(a.current, null);
            Z = $f = b;
            R = 0;
            vh = null;
            xh = wh = le = 0;
            zh = yh = null;
            if (null !== $d) {
                for(b = 0; b < $d.length; b++)if (c = $d[b], d = c.interleaved, null !== d) {
                    c.interleaved = null;
                    var e = d.next, f = c.pending;
                    if (null !== f) {
                        var g = f.next;
                        f.next = e;
                        d.next = g;
                    }
                    c.pending = d;
                }
                $d = null;
            }
            return a;
        }
        function Th(a, b) {
            do {
                var c = X;
                try {
                    Ud();
                    ze.current = Le;
                    if (Ce) {
                        for(var d = J.memoizedState; null !== d;){
                            var e = d.queue;
                            null !== e && (e.pending = null);
                            d = d.next;
                        }
                        Ce = !1;
                    }
                    Be = 0;
                    L = K = J = null;
                    De = !1;
                    Ee = 0;
                    uh.current = null;
                    if (null === c || null === c.return) {
                        R = 1;
                        vh = b;
                        X = null;
                        break;
                    }
                    a: {
                        var f = a, g = c.return, h = c, k = b;
                        b = Z;
                        h.flags |= 32768;
                        if (null !== k && "object" === (typeof k === "undefined" ? "undefined" : _type_of(k)) && "function" === typeof k.then) {
                            var l = k, m = h, r = m.tag;
                            if (0 === (m.mode & 1) && (0 === r || 11 === r || 15 === r)) {
                                var p = m.alternate;
                                p ? (m.updateQueue = p.updateQueue, m.memoizedState = p.memoizedState, m.lanes = p.lanes) : (m.updateQueue = null, m.memoizedState = null);
                            }
                            var B = Pf(g);
                            if (null !== B) {
                                B.flags &= -257;
                                Qf(B, g, h, f, b);
                                B.mode & 1 && Nf(f, l, b);
                                b = B;
                                k = l;
                                var w = b.updateQueue;
                                if (null === w) {
                                    var Y = new Set;
                                    Y.add(k);
                                    b.updateQueue = Y;
                                } else w.add(k);
                                break a;
                            } else {
                                if (0 === (b & 1)) {
                                    Nf(f, l, b);
                                    ng();
                                    break a;
                                }
                                k = Error(n(426));
                            }
                        } else if (F && h.mode & 1) {
                            var ya = Pf(g);
                            if (null !== ya) {
                                0 === (ya.flags & 65536) && (ya.flags |= 256);
                                Qf(ya, g, h, f, b);
                                Bd(Ef(k, h));
                                break a;
                            }
                        }
                        f = k = Ef(k, h);
                        4 !== R && (R = 2);
                        null === yh ? yh = [
                            f
                        ] : yh.push(f);
                        f = g;
                        do {
                            switch(f.tag){
                                case 3:
                                    f.flags |= 65536;
                                    b &= -b;
                                    f.lanes |= b;
                                    var E = If(f, k, b);
                                    je(f, E);
                                    break a;
                                case 1:
                                    h = k;
                                    var u = f.type, t = f.stateNode;
                                    if (0 === (f.flags & 128) && ("function" === typeof u.getDerivedStateFromError || null !== t && "function" === typeof t.componentDidCatch && (null === Mf || !Mf.has(t)))) {
                                        f.flags |= 65536;
                                        b &= -b;
                                        f.lanes |= b;
                                        var Db = Lf(f, h, b);
                                        je(f, Db);
                                        break a;
                                    }
                            }
                            f = f.return;
                        }while (null !== f);
                    }
                    Yh(c);
                } catch (lc) {
                    b = lc;
                    X === c && null !== c && (X = c = c.return);
                    continue;
                }
                break;
            }while (1);
        }
        function Qh() {
            var a = th.current;
            th.current = Le;
            return null === a ? Le : a;
        }
        function ng() {
            if (0 === R || 3 === R || 2 === R) R = 4;
            null === N || 0 === (le & 268435455) && 0 === (wh & 268435455) || Jh(N, Z);
        }
        function Ph(a, b) {
            var c = H;
            H |= 2;
            var d = Qh();
            if (N !== a || Z !== b) Ah = null, Rh(a, b);
            do try {
                Zh();
                break;
            } catch (e) {
                Th(a, e);
            }
            while (1);
            Ud();
            H = c;
            th.current = d;
            if (null !== X) throw Error(n(261));
            N = null;
            Z = 0;
            return R;
        }
        function Zh() {
            for(; null !== X;)$h(X);
        }
        function Sh() {
            for(; null !== X && !Lc();)$h(X);
        }
        function $h(a) {
            var b = ai(a.alternate, a, $f);
            a.memoizedProps = a.pendingProps;
            null === b ? Yh(a) : X = b;
            uh.current = null;
        }
        function Yh(a) {
            var b = a;
            do {
                var c = b.alternate;
                a = b.return;
                if (0 === (b.flags & 32768)) {
                    if (c = Bg(c, b, $f), null !== c) {
                        X = c;
                        return;
                    }
                } else {
                    c = Fg(c, b);
                    if (null !== c) {
                        c.flags &= 32767;
                        X = c;
                        return;
                    }
                    if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
                    else {
                        R = 6;
                        X = null;
                        return;
                    }
                }
                b = b.sibling;
                if (null !== b) {
                    X = b;
                    return;
                }
                X = b = a;
            }while (null !== b);
            0 === R && (R = 5);
        }
        function Wh(a, b, c) {
            var d = C, e = W.transition;
            try {
                W.transition = null, C = 1, bi(a, b, c, d);
            } finally{
                W.transition = e, C = d;
            }
            return null;
        }
        function bi(a, b, c, d) {
            do Oh();
            while (null !== Dh);
            if (0 !== (H & 6)) throw Error(n(327));
            c = a.finishedWork;
            var e = a.finishedLanes;
            if (null === c) return null;
            a.finishedWork = null;
            a.finishedLanes = 0;
            if (c === a.current) throw Error(n(177));
            a.callbackNode = null;
            a.callbackPriority = 0;
            var f = c.lanes | c.childLanes;
            Gc(a, f);
            a === N && (X = N = null, Z = 0);
            0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || Ch || (Ch = true, Mh(Pc, function() {
                Oh();
                return null;
            }));
            f = 0 !== (c.flags & 15990);
            if (0 !== (c.subtreeFlags & 15990) || f) {
                f = W.transition;
                W.transition = null;
                var g = C;
                C = 1;
                var h = H;
                H |= 4;
                uh.current = null;
                Lg(a, c);
                $g(c, a);
                Ia(a.containerInfo);
                a.current = c;
                dh(c);
                Mc();
                H = h;
                C = g;
                W.transition = f;
            } else a.current = c;
            Ch && (Ch = false, Dh = a, Eh = e);
            f = a.pendingLanes;
            0 === f && (Mf = null);
            Tc(c.stateNode);
            Kh(a, D());
            if (null !== b) for(d = a.onRecoverableError, c = 0; c < b.length; c++)e = b[c], d(e.value, {
                componentStack: e.stack,
                digest: e.digest
            });
            if (Jf) throw Jf = false, a = Kf, Kf = null, a;
            0 !== (Eh & 1) && 0 !== a.tag && Oh();
            f = a.pendingLanes;
            0 !== (f & 1) ? a === Gh ? Fh++ : (Fh = 0, Gh = a) : Fh = 0;
            ad();
            return null;
        }
        function Oh() {
            if (null !== Dh) {
                var a = Ic(Eh), b = W.transition, c = C;
                try {
                    W.transition = null;
                    C = 16 > a ? 16 : a;
                    if (null === Dh) var d = !1;
                    else {
                        a = Dh;
                        Dh = null;
                        Eh = 0;
                        if (0 !== (H & 6)) throw Error(n(331));
                        var e = H;
                        H |= 4;
                        for(T = a.current; null !== T;){
                            var f = T, g = f.child;
                            if (0 !== (T.flags & 16)) {
                                var h = f.deletions;
                                if (null !== h) {
                                    for(var k = 0; k < h.length; k++){
                                        var l = h[k];
                                        for(T = l; null !== T;){
                                            var m = T;
                                            switch(m.tag){
                                                case 0:
                                                case 11:
                                                case 15:
                                                    Mg(8, m, f);
                                            }
                                            var r = m.child;
                                            if (null !== r) r.return = m, T = r;
                                            else for(; null !== T;){
                                                m = T;
                                                var p = m.sibling, B = m.return;
                                                Pg(m);
                                                if (m === l) {
                                                    T = null;
                                                    break;
                                                }
                                                if (null !== p) {
                                                    p.return = B;
                                                    T = p;
                                                    break;
                                                }
                                                T = B;
                                            }
                                        }
                                    }
                                    var w = f.alternate;
                                    if (null !== w) {
                                        var Y = w.child;
                                        if (null !== Y) {
                                            w.child = null;
                                            do {
                                                var ya = Y.sibling;
                                                Y.sibling = null;
                                                Y = ya;
                                            }while (null !== Y);
                                        }
                                    }
                                    T = f;
                                }
                            }
                            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, T = g;
                            else b: for(; null !== T;){
                                f = T;
                                if (0 !== (f.flags & 2048)) switch(f.tag){
                                    case 0:
                                    case 11:
                                    case 15:
                                        Mg(9, f, f.return);
                                }
                                var E = f.sibling;
                                if (null !== E) {
                                    E.return = f.return;
                                    T = E;
                                    break b;
                                }
                                T = f.return;
                            }
                        }
                        var u = a.current;
                        for(T = u; null !== T;){
                            g = T;
                            var t = g.child;
                            if (0 !== (g.subtreeFlags & 2064) && null !== t) t.return = g, T = t;
                            else b: for(g = u; null !== T;){
                                h = T;
                                if (0 !== (h.flags & 2048)) try {
                                    switch(h.tag){
                                        case 0:
                                        case 11:
                                        case 15:
                                            Ng(9, h);
                                    }
                                } catch (lc) {
                                    U(h, h.return, lc);
                                }
                                if (h === g) {
                                    T = null;
                                    break b;
                                }
                                var Db = h.sibling;
                                if (null !== Db) {
                                    Db.return = h.return;
                                    T = Db;
                                    break b;
                                }
                                T = h.return;
                            }
                        }
                        H = e;
                        ad();
                        if (Sc && "function" === typeof Sc.onPostCommitFiberRoot) try {
                            Sc.onPostCommitFiberRoot(Rc, a);
                        } catch (lc) {}
                        d = !0;
                    }
                    return d;
                } finally{
                    C = c, W.transition = b;
                }
            }
            return false;
        }
        function ci(a, b, c) {
            b = Ef(c, b);
            b = If(a, b, 1);
            a = he(a, b, 1);
            b = O();
            null !== a && (Fc(a, 1, b), Kh(a, b));
        }
        function U(a, b, c) {
            if (3 === a.tag) ci(a, a, c);
            else for(; null !== b;){
                if (3 === b.tag) {
                    ci(b, a, c);
                    break;
                } else if (1 === b.tag) {
                    var d = b.stateNode;
                    if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Mf || !Mf.has(d))) {
                        a = Ef(c, a);
                        a = Lf(b, a, 1);
                        b = he(b, a, 1);
                        a = O();
                        null !== b && (Fc(b, 1, a), Kh(b, a));
                        break;
                    }
                }
                b = b.return;
            }
        }
        function Of(a, b, c) {
            var d = a.pingCache;
            null !== d && d.delete(b);
            b = O();
            a.pingedLanes |= a.suspendedLanes & c;
            N === a && (Z & c) === c && (4 === R || 3 === R && (Z & 130023424) === Z && 500 > D() - bh ? Rh(a, 0) : xh |= c);
            Kh(a, b);
        }
        function di(a, b) {
            0 === b && (0 === (a.mode & 1) ? b = 1 : (b = xc, xc <<= 1, 0 === (xc & 130023424) && (xc = 4194304)));
            var c = O();
            a = ce(a, b);
            null !== a && (Fc(a, b, c), Kh(a, c));
        }
        function og(a) {
            var b = a.memoizedState, c = 0;
            null !== b && (c = b.retryLane);
            di(a, c);
        }
        function Yg(a, b) {
            var c = 0;
            switch(a.tag){
                case 13:
                    var d = a.stateNode;
                    var e = a.memoizedState;
                    null !== e && (c = e.retryLane);
                    break;
                case 19:
                    d = a.stateNode;
                    break;
                default:
                    throw Error(n(314));
            }
            null !== d && d.delete(b);
            di(a, c);
        }
        var ai;
        ai = function ai(a, b, c) {
            if (null !== a) if (a.memoizedProps !== b.pendingProps || z.current) G = true;
            else {
                if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return G = false, sg(a, b, c);
                G = 0 !== (a.flags & 131072) ? true : false;
            }
            else G = false, F && 0 !== (b.flags & 1048576) && ld(b, ed, b.index);
            b.lanes = 0;
            switch(b.tag){
                case 2:
                    var d = b.type;
                    cg(a, b);
                    a = b.pendingProps;
                    var e = mc(b, x.current);
                    Yd(b, c);
                    e = He(null, b, d, a, e, c);
                    var f = Me();
                    b.flags |= 1;
                    "object" === (typeof e === "undefined" ? "undefined" : _type_of(e)) && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, A(d) ? (f = true, qc(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ee(b), e.updater = zf, b.stateNode = e, e._reactInternals = b, Df(b, d, a, c), b = dg(null, b, d, true, f, c)) : (b.tag = 0, F && f && md(b), P(null, b, e, c), b = b.child);
                    return b;
                case 16:
                    d = b.elementType;
                    a: {
                        cg(a, b);
                        a = b.pendingProps;
                        e = d._init;
                        d = e(d._payload);
                        b.type = d;
                        e = b.tag = ei(d);
                        a = xf(d, a);
                        switch(e){
                            case 0:
                                b = Xf(null, b, d, a, c);
                                break a;
                            case 1:
                                b = bg(null, b, d, a, c);
                                break a;
                            case 11:
                                b = Sf(null, b, d, a, c);
                                break a;
                            case 14:
                                b = Uf(null, b, d, xf(d.type, a), c);
                                break a;
                        }
                        throw Error(n(306, d, ""));
                    }
                    return b;
                case 0:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), Xf(a, b, d, e, c);
                case 1:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), bg(a, b, d, e, c);
                case 3:
                    a: {
                        eg(b);
                        if (null === a) throw Error(n(387));
                        d = b.pendingProps;
                        f = b.memoizedState;
                        e = f.element;
                        fe(a, b);
                        ke(b, d, null, c);
                        var g = b.memoizedState;
                        d = g.element;
                        if (Va && f.isDehydrated) if (f = {
                            element: d,
                            isDehydrated: false,
                            cache: g.cache,
                            pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                            transitions: g.transitions
                        }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                            e = Ef(Error(n(423)), b);
                            b = fg(a, b, d, c, e);
                            break a;
                        } else if (d !== e) {
                            e = Ef(Error(n(424)), b);
                            b = fg(a, b, d, c, e);
                            break a;
                        } else for(Va && (pd = Pb(b.stateNode.containerInfo), od = b, F = true, rd = null, qd = false), c = Pd(b, null, d, c), b.child = c; c;)c.flags = c.flags & -3 | 4096, c = c.sibling;
                        else {
                            Ad();
                            if (d === e) {
                                b = Tf(a, b, c);
                                break a;
                            }
                            P(a, b, d, c);
                        }
                        b = b.child;
                    }
                    return b;
                case 5:
                    return ue(b), null === a && wd(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Na(d, e) ? g = null : null !== f && Na(d, f) && (b.flags |= 32), ag(a, b), P(a, b, g, c), b.child;
                case 6:
                    return null === a && wd(b), null;
                case 13:
                    return ig(a, b, c);
                case 4:
                    return se(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Od(b, null, d, c) : P(a, b, d, c), b.child;
                case 11:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), Sf(a, b, d, e, c);
                case 7:
                    return P(a, b, b.pendingProps, c), b.child;
                case 8:
                    return P(a, b, b.pendingProps.children, c), b.child;
                case 12:
                    return P(a, b, b.pendingProps.children, c), b.child;
                case 10:
                    a: {
                        d = b.type._context;
                        e = b.pendingProps;
                        f = b.memoizedProps;
                        g = e.value;
                        Vd(b, d, g);
                        if (null !== f) if (Vc(f.value, g)) {
                            if (f.children === e.children && !z.current) {
                                b = Tf(a, b, c);
                                break a;
                            }
                        } else for(f = b.child, null !== f && (f.return = b); null !== f;){
                            var h = f.dependencies;
                            if (null !== h) {
                                g = f.child;
                                for(var k = h.firstContext; null !== k;){
                                    if (k.context === d) {
                                        if (1 === f.tag) {
                                            k = ge(-1, c & -c);
                                            k.tag = 2;
                                            var l = f.updateQueue;
                                            if (null !== l) {
                                                l = l.shared;
                                                var m = l.pending;
                                                null === m ? k.next = k : (k.next = m.next, m.next = k);
                                                l.pending = k;
                                            }
                                        }
                                        f.lanes |= c;
                                        k = f.alternate;
                                        null !== k && (k.lanes |= c);
                                        Xd(f.return, c, b);
                                        h.lanes |= c;
                                        break;
                                    }
                                    k = k.next;
                                }
                            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                            else if (18 === f.tag) {
                                g = f.return;
                                if (null === g) throw Error(n(341));
                                g.lanes |= c;
                                h = g.alternate;
                                null !== h && (h.lanes |= c);
                                Xd(g, c, b);
                                g = f.sibling;
                            } else g = f.child;
                            if (null !== g) g.return = f;
                            else for(g = f; null !== g;){
                                if (g === b) {
                                    g = null;
                                    break;
                                }
                                f = g.sibling;
                                if (null !== f) {
                                    f.return = g.return;
                                    g = f;
                                    break;
                                }
                                g = g.return;
                            }
                            f = g;
                        }
                        P(a, b, e.children, c);
                        b = b.child;
                    }
                    return b;
                case 9:
                    return e = b.type, d = b.pendingProps.children, Yd(b, c), e = Zd(e), d = d(e), b.flags |= 1, P(a, b, d, c), b.child;
                case 14:
                    return d = b.type, e = xf(d, b.pendingProps), e = xf(d.type, e), Uf(a, b, d, e, c);
                case 15:
                    return Wf(a, b, b.type, b.pendingProps, c);
                case 17:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), cg(a, b), b.tag = 1, A(d) ? (a = true, qc(b)) : a = false, Yd(b, c), Bf(b, d, e), Df(b, d, e, c), dg(null, b, d, true, a, c);
                case 19:
                    return rg(a, b, c);
                case 22:
                    return Yf(a, b, c);
            }
            throw Error(n(156, b.tag));
        };
        function Mh(a, b) {
            return Jc(a, b);
        }
        function fi(a, b, c, d) {
            this.tag = a;
            this.key = c;
            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = b;
            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
            this.mode = d;
            this.subtreeFlags = this.flags = 0;
            this.deletions = null;
            this.childLanes = this.lanes = 0;
            this.alternate = null;
        }
        function td(a, b, c, d) {
            return new fi(a, b, c, d);
        }
        function Vf(a) {
            a = a.prototype;
            return !(!a || !a.isReactComponent);
        }
        function ei(a) {
            if ("function" === typeof a) return Vf(a) ? 1 : 0;
            if (void 0 !== a && null !== a) {
                a = a.$$typeof;
                if (a === ma) return 11;
                if (a === pa) return 14;
            }
            return 2;
        }
        function Jd(a, b) {
            var c = a.alternate;
            null === c ? (c = td(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
            c.flags = a.flags & 14680064;
            c.childLanes = a.childLanes;
            c.lanes = a.lanes;
            c.child = a.child;
            c.memoizedProps = a.memoizedProps;
            c.memoizedState = a.memoizedState;
            c.updateQueue = a.updateQueue;
            b = a.dependencies;
            c.dependencies = null === b ? null : {
                lanes: b.lanes,
                firstContext: b.firstContext
            };
            c.sibling = a.sibling;
            c.index = a.index;
            c.ref = a.ref;
            return c;
        }
        function Ld(a, b, c, d, e, f) {
            var g = 2;
            d = a;
            if ("function" === typeof a) Vf(a) && (g = 1);
            else if ("string" === typeof a) g = 5;
            else a: switch(a){
                case ha:
                    return Nd(c.children, e, f, b);
                case ia:
                    g = 8;
                    e |= 8;
                    break;
                case ja:
                    return a = td(12, c, b, e | 2), a.elementType = ja, a.lanes = f, a;
                case na:
                    return a = td(13, c, b, e), a.elementType = na, a.lanes = f, a;
                case oa:
                    return a = td(19, c, b, e), a.elementType = oa, a.lanes = f, a;
                case ra:
                    return jg(c, e, f, b);
                default:
                    if ("object" === (typeof a === "undefined" ? "undefined" : _type_of(a)) && null !== a) switch(a.$$typeof){
                        case ka:
                            g = 10;
                            break a;
                        case la:
                            g = 9;
                            break a;
                        case ma:
                            g = 11;
                            break a;
                        case pa:
                            g = 14;
                            break a;
                        case qa:
                            g = 16;
                            d = null;
                            break a;
                    }
                    throw Error(n(130, null == a ? a : typeof a === "undefined" ? "undefined" : _type_of(a), ""));
            }
            b = td(g, c, b, e);
            b.elementType = a;
            b.type = d;
            b.lanes = f;
            return b;
        }
        function Nd(a, b, c, d) {
            a = td(7, a, d, b);
            a.lanes = c;
            return a;
        }
        function jg(a, b, c, d) {
            a = td(22, a, d, b);
            a.elementType = ra;
            a.lanes = c;
            a.stateNode = {
                isHidden: false
            };
            return a;
        }
        function Kd(a, b, c) {
            a = td(6, a, null, b);
            a.lanes = c;
            return a;
        }
        function Md(a, b, c) {
            b = td(4, null !== a.children ? a.children : [], a.key, b);
            b.lanes = c;
            b.stateNode = {
                containerInfo: a.containerInfo,
                pendingChildren: null,
                implementation: a.implementation
            };
            return b;
        }
        function gi(a, b, c, d, e) {
            this.tag = b;
            this.containerInfo = a;
            this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
            this.timeoutHandle = Ra;
            this.callbackNode = this.pendingContext = this.context = null;
            this.callbackPriority = 0;
            this.eventTimes = Ec(0);
            this.expirationTimes = Ec(-1);
            this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
            this.entanglements = Ec(0);
            this.identifierPrefix = d;
            this.onRecoverableError = e;
            Va && (this.mutableSourceEagerHydrationData = null);
        }
        function hi(a, b, c, d, e, f, g, h, k) {
            a = new gi(a, b, c, h, k);
            1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
            f = td(3, null, null, b);
            a.current = f;
            f.stateNode = a;
            f.memoizedState = {
                element: d,
                isDehydrated: c,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null
            };
            ee(f);
            return a;
        }
        function ii(a) {
            if (!a) return jc;
            a = a._reactInternals;
            a: {
                if (wa(a) !== a || 1 !== a.tag) throw Error(n(170));
                var b = a;
                do {
                    switch(b.tag){
                        case 3:
                            b = b.stateNode.context;
                            break a;
                        case 1:
                            if (A(b.type)) {
                                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                                break a;
                            }
                    }
                    b = b.return;
                }while (null !== b);
                throw Error(n(171));
            }
            if (1 === a.tag) {
                var c = a.type;
                if (A(c)) return pc(a, c, b);
            }
            return b;
        }
        function ji(a) {
            var b = a._reactInternals;
            if (void 0 === b) {
                if ("function" === typeof a.render) throw Error(n(188));
                a = Object.keys(a).join(",");
                throw Error(n(268, a));
            }
            a = Aa(b);
            return null === a ? null : a.stateNode;
        }
        function ki(a, b) {
            a = a.memoizedState;
            if (null !== a && null !== a.dehydrated) {
                var c = a.retryLane;
                a.retryLane = 0 !== c && c < b ? c : b;
            }
        }
        function li(a, b) {
            ki(a, b);
            (a = a.alternate) && ki(a, b);
        }
        function mi(a) {
            a = Aa(a);
            return null === a ? null : a.stateNode;
        }
        function ni() {
            return null;
        }
        exports1.attemptContinuousHydration = function(a) {
            if (13 === a.tag) {
                var b = ce(a, 134217728);
                if (null !== b) {
                    var c = O();
                    af(b, a, 134217728, c);
                }
                li(a, 134217728);
            }
        };
        exports1.attemptDiscreteHydration = function(a) {
            if (13 === a.tag) {
                var b = ce(a, 1);
                if (null !== b) {
                    var c = O();
                    af(b, a, 1, c);
                }
                li(a, 1);
            }
        };
        exports1.attemptHydrationAtCurrentPriority = function(a) {
            if (13 === a.tag) {
                var b = tf(a), c = ce(a, b);
                if (null !== c) {
                    var d = O();
                    af(c, a, b, d);
                }
                li(a, b);
            }
        };
        exports1.attemptSynchronousHydration = function(a) {
            switch(a.tag){
                case 3:
                    var b = a.stateNode;
                    if (b.current.memoizedState.isDehydrated) {
                        var c = yc(b.pendingLanes);
                        0 !== c && (Hc(b, c | 1), Kh(b, D()), 0 === (H & 6) && (Bh(), ad()));
                    }
                    break;
                case 13:
                    Xh(function() {
                        var b = ce(a, 1);
                        if (null !== b) {
                            var c = O();
                            af(b, a, 1, c);
                        }
                    }), li(a, 1);
            }
        };
        exports1.batchedUpdates = function(a, b) {
            var c = H;
            H |= 1;
            try {
                return a(b);
            } finally{
                H = c, 0 === H && (Bh(), Xc && ad());
            }
        };
        exports1.createComponentSelector = function(a) {
            return {
                $$typeof: hh,
                value: a
            };
        };
        exports1.createContainer = function(a, b, c, d, e, f, g) {
            return hi(a, b, false, null, c, d, e, f, g);
        };
        exports1.createHasPseudoClassSelector = function(a) {
            return {
                $$typeof: ih,
                value: a
            };
        };
        exports1.createHydrationContainer = function(a, b, c, d, e, f, g, h, k) {
            a = hi(c, d, true, a, e, f, g, h, k);
            a.context = ii(null);
            c = a.current;
            d = O();
            e = tf(c);
            f = ge(d, e);
            f.callback = void 0 !== b && null !== b ? b : null;
            he(c, f, e);
            a.current.lanes = e;
            Fc(a, e, d);
            Kh(a, d);
            return a;
        };
        exports1.createPortal = function(a, b, c) {
            var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            return {
                $$typeof: fa,
                key: null == d ? null : "" + d,
                children: a,
                containerInfo: b,
                implementation: c
            };
        };
        exports1.createRoleSelector = function(a) {
            return {
                $$typeof: jh,
                value: a
            };
        };
        exports1.createTestNameSelector = function(a) {
            return {
                $$typeof: kh,
                value: a
            };
        };
        exports1.createTextSelector = function(a) {
            return {
                $$typeof: lh,
                value: a
            };
        };
        exports1.deferredUpdates = function(a) {
            var b = C, c = W.transition;
            try {
                return W.transition = null, C = 16, a();
            } finally{
                C = b, W.transition = c;
            }
        };
        exports1.discreteUpdates = function(a, b, c, d, e) {
            var f = C, g = W.transition;
            try {
                return W.transition = null, C = 1, a(b, c, d, e);
            } finally{
                C = f, W.transition = g, 0 === H && Bh();
            }
        };
        exports1.findAllNodes = rh;
        exports1.findBoundingRects = function(a, b) {
            if (!bb) throw Error(n(363));
            b = rh(a, b);
            a = [];
            for(var c = 0; c < b.length; c++)a.push(db(b[c]));
            for(b = a.length - 1; 0 < b; b--){
                c = a[b];
                for(var d = c.x, e = d + c.width, f = c.y, g = f + c.height, h = b - 1; 0 <= h; h--)if (b !== h) {
                    var k = a[h], l = k.x, m = l + k.width, r = k.y, p = r + k.height;
                    if (d >= l && f >= r && e <= m && g <= p) {
                        a.splice(b, 1);
                        break;
                    } else if (!(d !== l || c.width !== k.width || p < f || r > g)) {
                        r > f && (k.height += r - f, k.y = f);
                        p < g && (k.height = g - r);
                        a.splice(b, 1);
                        break;
                    } else if (!(f !== r || c.height !== k.height || m < d || l > e)) {
                        l > d && (k.width += l - d, k.x = d);
                        m < e && (k.width = e - l);
                        a.splice(b, 1);
                        break;
                    }
                }
            }
            return a;
        };
        exports1.findHostInstance = ji;
        exports1.findHostInstanceWithNoPortals = function(a) {
            a = za(a);
            a = null !== a ? Ca(a) : null;
            return null === a ? null : a.stateNode;
        };
        exports1.findHostInstanceWithWarning = function(a) {
            return ji(a);
        };
        exports1.flushControlled = function(a) {
            var b = H;
            H |= 1;
            var c = W.transition, d = C;
            try {
                W.transition = null, C = 1, a();
            } finally{
                C = d, W.transition = c, H = b, 0 === H && (Bh(), ad());
            }
        };
        exports1.flushPassiveEffects = Oh;
        exports1.flushSync = Xh;
        exports1.focusWithin = function(a, b) {
            if (!bb) throw Error(n(363));
            a = nh(a);
            b = qh(a, b);
            b = Array.from(b);
            for(a = 0; a < b.length;){
                var c = b[a++];
                if (!fb(c)) {
                    if (5 === c.tag && hb(c.stateNode)) return true;
                    for(c = c.child; null !== c;)b.push(c), c = c.sibling;
                }
            }
            return false;
        };
        exports1.getCurrentUpdatePriority = function() {
            return C;
        };
        exports1.getFindAllNodesFailureDescription = function(a, b) {
            if (!bb) throw Error(n(363));
            var c = 0, d = [];
            a = [
                nh(a),
                0
            ];
            for(var e = 0; e < a.length;){
                var f = a[e++], g = a[e++], h = b[g];
                if (5 !== f.tag || !fb(f)) {
                    if (oh(f, h) && (d.push(ph(h)), g++, g > c && (c = g)), g < b.length) for(f = f.child; null !== f;)a.push(f, g), f = f.sibling;
                }
            }
            if (c < b.length) {
                for(a = []; c < b.length; c++)a.push(ph(b[c]));
                return "findAllNodes was able to match part of the selector:\n  " + (d.join(" > ") + "\n\nNo matching component was found for:\n  ") + a.join(" > ");
            }
            return null;
        };
        exports1.getPublicRootInstance = function(a) {
            a = a.current;
            if (!a.child) return null;
            switch(a.child.tag){
                case 5:
                    return Ea(a.child.stateNode);
                default:
                    return a.child.stateNode;
            }
        };
        exports1.injectIntoDevTools = function(a) {
            a = {
                bundleType: a.bundleType,
                version: a.version,
                rendererPackageName: a.rendererPackageName,
                rendererConfig: a.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: da.ReactCurrentDispatcher,
                findHostInstanceByFiber: mi,
                findFiberByHostInstance: a.findFiberByHostInstance || ni,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.3.1"
            };
            if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) a = false;
            else {
                var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (b.isDisabled || !b.supportsFiber) a = true;
                else {
                    try {
                        Rc = b.inject(a), Sc = b;
                    } catch (c) {}
                    a = b.checkDCE ? true : false;
                }
            }
            return a;
        };
        exports1.isAlreadyRendering = function() {
            return false;
        };
        exports1.observeVisibleRects = function(a, b, c, d) {
            if (!bb) throw Error(n(363));
            a = rh(a, b);
            var e = ib(a, c, d).disconnect;
            return {
                disconnect: function disconnect() {
                    e();
                }
            };
        };
        exports1.registerMutableSourceForHydration = function(a, b) {
            var c = b._getVersion;
            c = c(b._source);
            null == a.mutableSourceEagerHydrationData ? a.mutableSourceEagerHydrationData = [
                b,
                c
            ] : a.mutableSourceEagerHydrationData.push(b, c);
        };
        exports1.runWithPriority = function(a, b) {
            var c = C;
            try {
                return C = a, b();
            } finally{
                C = c;
            }
        };
        exports1.shouldError = function() {
            return null;
        };
        exports1.shouldSuspend = function() {
            return false;
        };
        exports1.updateContainer = function(a, b, c, d) {
            var e = b.current, f = O(), g = tf(e);
            c = ii(c);
            null === b.context ? b.context = c : b.pendingContext = c;
            b = ge(f, g);
            b.payload = {
                element: a
            };
            d = void 0 === d ? null : d;
            null !== d && (b.callback = d);
            a = he(e, b, g);
            null !== a && (af(a, e, g, f), ie(a, e, g));
            return g;
        };
        return exports1;
    };
    return reactReconciler_production_min;
}
var reactReconciler_development = {
    exports: {}
};
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactReconciler_development;
function requireReactReconciler_development() {
    if (hasRequiredReactReconciler_development) return reactReconciler_development.exports;
    hasRequiredReactReconciler_development = 1;
    if (process.env.NODE_ENV !== "production") {
        reactReconciler_development.exports = function $$$reconciler($$$hostConfig) {
            var exports1 = {};
            var React$1 = _react.default;
            var Scheduler = requireScheduler();
            var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
            var suppressWarning = false;
            function setSuppressWarning(newSuppressWarning) {
                {
                    suppressWarning = newSuppressWarning;
                }
            } // In DEV, calls to console.warn and console.error get replaced
            // by calls to these methods by a Babel plugin.
            //
            // In PROD (or in packages without access to React internals),
            // they are left as they are instead.
            function warn(format) {
                {
                    if (!suppressWarning) {
                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                            args[_key - 1] = arguments[_key];
                        }
                        printWarning('warn', format, args);
                    }
                }
            }
            function error(format) {
                {
                    if (!suppressWarning) {
                        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                            args[_key2 - 1] = arguments[_key2];
                        }
                        printWarning('error', format, args);
                    }
                }
            }
            function printWarning(level, format, args) {
                // When changing this logic, you might want to also
                // update consoleWithStackDev.www.js as well.
                {
                    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                    var stack = ReactDebugCurrentFrame.getStackAddendum();
                    if (stack !== '') {
                        format += '%s';
                        args = args.concat([
                            stack
                        ]);
                    } // eslint-disable-next-line react-internal/safe-string-coercion
                    var argsWithFormat = args.map(function(item) {
                        return String(item);
                    }); // Careful: RN currently depends on this prefix
                    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
                    // breaks IE9: https://github.com/facebook/react/issues/13610
                    // eslint-disable-next-line react-internal/no-production-logging
                    Function.prototype.apply.call(console[level], console, argsWithFormat);
                }
            }
            var assign = Object.assign;
            /**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 *
	 * Note that this module is currently shared and assumed to be stateless.
	 * If this becomes an actual Map, that will break.
	 */ function get(key) {
                return key._reactInternals;
            }
            function set(key, value) {
                key._reactInternals = value;
            }
            // -----------------------------------------------------------------------------
            // the react-reconciler package.
            var enableNewReconciler = false; // Support legacy Primer support on internal FB www
            var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.
            var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
            var warnAboutStringRefs = true; // -----------------------------------------------------------------------------
            // Debugging and DevTools
            // -----------------------------------------------------------------------------
            // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
            // for an experimental timeline tool.
            var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState
            var enableProfilerTimer = true; // Record durations for commit and passive effects phases.
            var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an "update" and a "cascading-update".
            var FunctionComponent = 0;
            var ClassComponent = 1;
            var IndeterminateComponent = 2; // Before we know whether it is function or class
            var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
            var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
            var HostComponent = 5;
            var HostText = 6;
            var Fragment = 7;
            var Mode = 8;
            var ContextConsumer = 9;
            var ContextProvider = 10;
            var ForwardRef = 11;
            var Profiler = 12;
            var SuspenseComponent = 13;
            var MemoComponent = 14;
            var SimpleMemoComponent = 15;
            var LazyComponent = 16;
            var IncompleteClassComponent = 17;
            var DehydratedFragment = 18;
            var SuspenseListComponent = 19;
            var ScopeComponent = 21;
            var OffscreenComponent = 22;
            var LegacyHiddenComponent = 23;
            var CacheComponent = 24;
            var TracingMarkerComponent = 25;
            // ATTENTION
            // When adding new symbols to this file,
            // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
            // The Symbol used to tag the ReactElement-like types.
            var REACT_ELEMENT_TYPE = Symbol.for('react.element');
            var REACT_PORTAL_TYPE = Symbol.for('react.portal');
            var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
            var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
            var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
            var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
            var REACT_CONTEXT_TYPE = Symbol.for('react.context');
            var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
            var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
            var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
            var REACT_MEMO_TYPE = Symbol.for('react.memo');
            var REACT_LAZY_TYPE = Symbol.for('react.lazy');
            var REACT_SCOPE_TYPE = Symbol.for('react.scope');
            var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
            var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
            var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
            var REACT_CACHE_TYPE = Symbol.for('react.cache');
            var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');
            var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator';
            function getIteratorFn(maybeIterable) {
                if (maybeIterable === null || (typeof maybeIterable === "undefined" ? "undefined" : _type_of(maybeIterable)) !== 'object') {
                    return null;
                }
                var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
                if (typeof maybeIterator === 'function') {
                    return maybeIterator;
                }
                return null;
            }
            function getWrappedName(outerType, innerType, wrapperName) {
                var displayName = outerType.displayName;
                if (displayName) {
                    return displayName;
                }
                var functionName = innerType.displayName || innerType.name || '';
                return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
            } // Keep in sync with react-reconciler/getComponentNameFromFiber
            function getContextName(type) {
                return type.displayName || 'Context';
            } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
            function getComponentNameFromType(type) {
                if (type == null) {
                    // Host root, text node or just invalid type.
                    return null;
                }
                {
                    if (typeof type.tag === 'number') {
                        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                    }
                }
                if (typeof type === 'function') {
                    return type.displayName || type.name || null;
                }
                if (typeof type === 'string') {
                    return type;
                }
                switch(type){
                    case REACT_FRAGMENT_TYPE:
                        return 'Fragment';
                    case REACT_PORTAL_TYPE:
                        return 'Portal';
                    case REACT_PROFILER_TYPE:
                        return 'Profiler';
                    case REACT_STRICT_MODE_TYPE:
                        return 'StrictMode';
                    case REACT_SUSPENSE_TYPE:
                        return 'Suspense';
                    case REACT_SUSPENSE_LIST_TYPE:
                        return 'SuspenseList';
                }
                if ((typeof type === "undefined" ? "undefined" : _type_of(type)) === 'object') {
                    switch(type.$$typeof){
                        case REACT_CONTEXT_TYPE:
                            var context = type;
                            return getContextName(context) + '.Consumer';
                        case REACT_PROVIDER_TYPE:
                            var provider = type;
                            return getContextName(provider._context) + '.Provider';
                        case REACT_FORWARD_REF_TYPE:
                            return getWrappedName(type, type.render, 'ForwardRef');
                        case REACT_MEMO_TYPE:
                            var outerName = type.displayName || null;
                            if (outerName !== null) {
                                return outerName;
                            }
                            return getComponentNameFromType(type.type) || 'Memo';
                        case REACT_LAZY_TYPE:
                            {
                                var lazyComponent = type;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    return getComponentNameFromType(init(payload));
                                } catch (x) {
                                    return null;
                                }
                            }
                    }
                }
                return null;
            }
            function getWrappedName$1(outerType, innerType, wrapperName) {
                var functionName = innerType.displayName || innerType.name || '';
                return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
            } // Keep in sync with shared/getComponentNameFromType
            function getContextName$1(type) {
                return type.displayName || 'Context';
            }
            function getComponentNameFromFiber(fiber) {
                var tag = fiber.tag, type = fiber.type;
                switch(tag){
                    case CacheComponent:
                        return 'Cache';
                    case ContextConsumer:
                        var context = type;
                        return getContextName$1(context) + '.Consumer';
                    case ContextProvider:
                        var provider = type;
                        return getContextName$1(provider._context) + '.Provider';
                    case DehydratedFragment:
                        return 'DehydratedFragment';
                    case ForwardRef:
                        return getWrappedName$1(type, type.render, 'ForwardRef');
                    case Fragment:
                        return 'Fragment';
                    case HostComponent:
                        // Host component type is the display name (e.g. "div", "View")
                        return type;
                    case HostPortal:
                        return 'Portal';
                    case HostRoot:
                        return 'Root';
                    case HostText:
                        return 'Text';
                    case LazyComponent:
                        // Name comes from the type in this case; we don't have a tag.
                        return getComponentNameFromType(type);
                    case Mode:
                        if (type === REACT_STRICT_MODE_TYPE) {
                            // Don't be less specific than shared/getComponentNameFromType
                            return 'StrictMode';
                        }
                        return 'Mode';
                    case OffscreenComponent:
                        return 'Offscreen';
                    case Profiler:
                        return 'Profiler';
                    case ScopeComponent:
                        return 'Scope';
                    case SuspenseComponent:
                        return 'Suspense';
                    case SuspenseListComponent:
                        return 'SuspenseList';
                    case TracingMarkerComponent:
                        return 'TracingMarker';
                    // The display name for this tags come from the user-provided type:
                    case ClassComponent:
                    case FunctionComponent:
                    case IncompleteClassComponent:
                    case IndeterminateComponent:
                    case MemoComponent:
                    case SimpleMemoComponent:
                        if (typeof type === 'function') {
                            return type.displayName || type.name || null;
                        }
                        if (typeof type === 'string') {
                            return type;
                        }
                        break;
                }
                return null;
            }
            // Don't change these two values. They're used by React Dev Tools.
            var NoFlags = /*                      */ 0;
            var PerformedWork = /*                */ 1; // You can change the rest (and add more).
            var Placement = /*                    */ 2;
            var Update = /*                       */ 4;
            var ChildDeletion = /*                */ 16;
            var ContentReset = /*                 */ 32;
            var Callback = /*                     */ 64;
            var DidCapture = /*                   */ 128;
            var ForceClientRender = /*            */ 256;
            var Ref = /*                          */ 512;
            var Snapshot = /*                     */ 1024;
            var Passive = /*                      */ 2048;
            var Hydrating = /*                    */ 4096;
            var Visibility = /*                   */ 8192;
            var StoreConsistency = /*             */ 16384;
            var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.
            var Incomplete = /*                   */ 32768;
            var ShouldCapture = /*                */ 65536;
            var ForceUpdateForLegacySuspense = /* */ 131072;
            var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,
            // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
            // This enables us to defer more work in the unmount case,
            // since we can defer traversing the tree during layout to look for Passive effects,
            // and instead rely on the static flag as a signal that there may be cleanup work.
            var RefStatic = /*                    */ 2097152;
            var LayoutStatic = /*                 */ 4194304;
            var PassiveStatic = /*                */ 8388608; // These flags allow us to traverse to fibers that have effects on mount
            // without traversing the entire tree after every commit for
            // double invoking
            var MountLayoutDev = /*               */ 16777216;
            var MountPassiveDev = /*              */ 33554432; // Groups of flags that are used in the commit phase to skip over trees that
            // don't contain effects, by checking subtreeFlags.
            var BeforeMutationMask = // flag logic (see #20043)
            Update | Snapshot | 0;
            var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
            var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask
            var PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.
            // This allows certain concepts to persist without recalculating them,
            // e.g. whether a subtree contains passive effects or portals.
            var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
            var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
            function getNearestMountedFiber(fiber) {
                var node = fiber;
                var nearestMounted = fiber;
                if (!fiber.alternate) {
                    // If there is no alternate, this might be a new tree that isn't inserted
                    // yet. If it is, then it will have a pending insertion effect on it.
                    var nextNode = node;
                    do {
                        node = nextNode;
                        if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                            // This is an insertion or in-progress hydration. The nearest possible
                            // mounted fiber is the parent but we need to continue to figure out
                            // if that one is still mounted.
                            nearestMounted = node.return;
                        }
                        nextNode = node.return;
                    }while (nextNode);
                } else {
                    while(node.return){
                        node = node.return;
                    }
                }
                if (node.tag === HostRoot) {
                    // TODO: Check if this was a nested HostRoot when used with
                    // renderContainerIntoSubtree.
                    return nearestMounted;
                } // If we didn't hit the root, that means that we're in an disconnected tree
                // that has been unmounted.
                return null;
            }
            function isFiberMounted(fiber) {
                return getNearestMountedFiber(fiber) === fiber;
            }
            function isMounted(component) {
                {
                    var owner = ReactCurrentOwner.current;
                    if (owner !== null && owner.tag === ClassComponent) {
                        var ownerFiber = owner;
                        var instance = ownerFiber.stateNode;
                        if (!instance._warnedAboutRefsInRender) {
                            error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');
                        }
                        instance._warnedAboutRefsInRender = true;
                    }
                }
                var fiber = get(component);
                if (!fiber) {
                    return false;
                }
                return getNearestMountedFiber(fiber) === fiber;
            }
            function assertIsMounted(fiber) {
                if (getNearestMountedFiber(fiber) !== fiber) {
                    throw new Error('Unable to find node on an unmounted component.');
                }
            }
            function findCurrentFiberUsingSlowPath(fiber) {
                var alternate = fiber.alternate;
                if (!alternate) {
                    // If there is no alternate, then we only need to check if it is mounted.
                    var nearestMounted = getNearestMountedFiber(fiber);
                    if (nearestMounted === null) {
                        throw new Error('Unable to find node on an unmounted component.');
                    }
                    if (nearestMounted !== fiber) {
                        return null;
                    }
                    return fiber;
                } // If we have two possible branches, we'll walk backwards up to the root
                // to see what path the root points to. On the way we may hit one of the
                // special cases and we'll deal with them.
                var a = fiber;
                var b = alternate;
                while(true){
                    var parentA = a.return;
                    if (parentA === null) {
                        break;
                    }
                    var parentB = parentA.alternate;
                    if (parentB === null) {
                        // There is no alternate. This is an unusual case. Currently, it only
                        // happens when a Suspense component is hidden. An extra fragment fiber
                        // is inserted in between the Suspense fiber and its children. Skip
                        // over this extra fragment fiber and proceed to the next parent.
                        var nextParent = parentA.return;
                        if (nextParent !== null) {
                            a = b = nextParent;
                            continue;
                        } // If there's no parent, we're at the root.
                        break;
                    } // If both copies of the parent fiber point to the same child, we can
                    // assume that the child is current. This happens when we bailout on low
                    // priority: the bailed out fiber's child reuses the current child.
                    if (parentA.child === parentB.child) {
                        var child = parentA.child;
                        while(child){
                            if (child === a) {
                                // We've determined that A is the current branch.
                                assertIsMounted(parentA);
                                return fiber;
                            }
                            if (child === b) {
                                // We've determined that B is the current branch.
                                assertIsMounted(parentA);
                                return alternate;
                            }
                            child = child.sibling;
                        } // We should never have an alternate for any mounting node. So the only
                        // way this could possibly happen is if this was unmounted, if at all.
                        throw new Error('Unable to find node on an unmounted component.');
                    }
                    if (a.return !== b.return) {
                        // The return pointer of A and the return pointer of B point to different
                        // fibers. We assume that return pointers never criss-cross, so A must
                        // belong to the child set of A.return, and B must belong to the child
                        // set of B.return.
                        a = parentA;
                        b = parentB;
                    } else {
                        // The return pointers point to the same fiber. We'll have to use the
                        // default, slow path: scan the child sets of each parent alternate to see
                        // which child belongs to which set.
                        //
                        // Search parent A's child set
                        var didFindChild = false;
                        var _child = parentA.child;
                        while(_child){
                            if (_child === a) {
                                didFindChild = true;
                                a = parentA;
                                b = parentB;
                                break;
                            }
                            if (_child === b) {
                                didFindChild = true;
                                b = parentA;
                                a = parentB;
                                break;
                            }
                            _child = _child.sibling;
                        }
                        if (!didFindChild) {
                            // Search parent B's child set
                            _child = parentB.child;
                            while(_child){
                                if (_child === a) {
                                    didFindChild = true;
                                    a = parentB;
                                    b = parentA;
                                    break;
                                }
                                if (_child === b) {
                                    didFindChild = true;
                                    b = parentB;
                                    a = parentA;
                                    break;
                                }
                                _child = _child.sibling;
                            }
                            if (!didFindChild) {
                                throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
                            }
                        }
                    }
                    if (a.alternate !== b) {
                        throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
                    }
                } // If the root is not a host container, we're in a disconnected tree. I.e.
                // unmounted.
                if (a.tag !== HostRoot) {
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (a.stateNode.current === a) {
                    // We've determined that A is the current branch.
                    return fiber;
                } // Otherwise B has to be current branch.
                return alternate;
            }
            function findCurrentHostFiber(parent) {
                var currentParent = findCurrentFiberUsingSlowPath(parent);
                return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
            }
            function findCurrentHostFiberImpl(node) {
                // Next we'll drill down this component to find the first HostComponent/Text.
                if (node.tag === HostComponent || node.tag === HostText) {
                    return node;
                }
                var child = node.child;
                while(child !== null){
                    var match = findCurrentHostFiberImpl(child);
                    if (match !== null) {
                        return match;
                    }
                    child = child.sibling;
                }
                return null;
            }
            function findCurrentHostFiberWithNoPortals(parent) {
                var currentParent = findCurrentFiberUsingSlowPath(parent);
                return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
            }
            function findCurrentHostFiberWithNoPortalsImpl(node) {
                // Next we'll drill down this component to find the first HostComponent/Text.
                if (node.tag === HostComponent || node.tag === HostText) {
                    return node;
                }
                var child = node.child;
                while(child !== null){
                    if (child.tag !== HostPortal) {
                        var match = findCurrentHostFiberWithNoPortalsImpl(child);
                        if (match !== null) {
                            return match;
                        }
                    }
                    child = child.sibling;
                }
                return null;
            }
            var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
            function isArray(a) {
                return isArrayImpl(a);
            }
            // This is a host config that's used for the `react-reconciler` package on npm.
            // It is only used by third-party renderers.
            //
            // Its API lets you pass the host config as an argument.
            // However, inside the `react-reconciler` we treat host config as a module.
            // This file is a shim between two worlds.
            //
            // It works because the `react-reconciler` bundle is wrapped in something like:
            //
            // module.exports = function ($$$config) {
            //   /* reconciler code */
            // }
            //
            // So `$$$config` looks like a global variable, but it's
            // really an argument to a top-level wrapping function.
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            // eslint-disable-line no-undef
            var getPublicInstance = $$$hostConfig.getPublicInstance;
            var getRootHostContext = $$$hostConfig.getRootHostContext;
            var getChildHostContext = $$$hostConfig.getChildHostContext;
            var prepareForCommit = $$$hostConfig.prepareForCommit;
            var resetAfterCommit = $$$hostConfig.resetAfterCommit;
            var createInstance = $$$hostConfig.createInstance;
            var appendInitialChild = $$$hostConfig.appendInitialChild;
            var finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;
            var prepareUpdate = $$$hostConfig.prepareUpdate;
            var shouldSetTextContent = $$$hostConfig.shouldSetTextContent;
            var createTextInstance = $$$hostConfig.createTextInstance;
            var scheduleTimeout = $$$hostConfig.scheduleTimeout;
            var cancelTimeout = $$$hostConfig.cancelTimeout;
            var noTimeout = $$$hostConfig.noTimeout;
            var isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;
            var warnsIfNotActing = $$$hostConfig.warnsIfNotActing;
            var supportsMutation = $$$hostConfig.supportsMutation;
            var supportsPersistence = $$$hostConfig.supportsPersistence;
            var supportsHydration = $$$hostConfig.supportsHydration;
            var getInstanceFromNode = $$$hostConfig.getInstanceFromNode;
            $$$hostConfig.beforeActiveInstanceBlur;
            $$$hostConfig.afterActiveInstanceBlur;
            var preparePortalMount = $$$hostConfig.preparePortalMount;
            $$$hostConfig.prepareScopeUpdate;
            $$$hostConfig.getInstanceFromScope;
            var getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;
            var detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------
            //      Microtasks
            //     (optional)
            // -------------------
            var supportsMicrotasks = $$$hostConfig.supportsMicrotasks;
            var scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------
            //      Test selectors
            //     (optional)
            // -------------------
            var supportsTestSelectors = $$$hostConfig.supportsTestSelectors;
            var findFiberRoot = $$$hostConfig.findFiberRoot;
            var getBoundingRect = $$$hostConfig.getBoundingRect;
            var getTextContent = $$$hostConfig.getTextContent;
            var isHiddenSubtree = $$$hostConfig.isHiddenSubtree;
            var matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;
            var setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;
            var setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------
            //      Mutation
            //     (optional)
            // -------------------
            var appendChild = $$$hostConfig.appendChild;
            var appendChildToContainer = $$$hostConfig.appendChildToContainer;
            var commitTextUpdate = $$$hostConfig.commitTextUpdate;
            var commitMount = $$$hostConfig.commitMount;
            var commitUpdate = $$$hostConfig.commitUpdate;
            var insertBefore = $$$hostConfig.insertBefore;
            var insertInContainerBefore = $$$hostConfig.insertInContainerBefore;
            var removeChild = $$$hostConfig.removeChild;
            var removeChildFromContainer = $$$hostConfig.removeChildFromContainer;
            var resetTextContent = $$$hostConfig.resetTextContent;
            var hideInstance = $$$hostConfig.hideInstance;
            var hideTextInstance = $$$hostConfig.hideTextInstance;
            var unhideInstance = $$$hostConfig.unhideInstance;
            var unhideTextInstance = $$$hostConfig.unhideTextInstance;
            var clearContainer = $$$hostConfig.clearContainer; // -------------------
            //     Persistence
            //     (optional)
            // -------------------
            var cloneInstance = $$$hostConfig.cloneInstance;
            var createContainerChildSet = $$$hostConfig.createContainerChildSet;
            var appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;
            var finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;
            var replaceContainerChildren = $$$hostConfig.replaceContainerChildren;
            var cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;
            var cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------
            //     Hydration
            //     (optional)
            // -------------------
            var canHydrateInstance = $$$hostConfig.canHydrateInstance;
            var canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;
            var canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;
            var isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;
            var isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;
            var getSuspenseInstanceFallbackErrorDetails = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails;
            var registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;
            var getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;
            var getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;
            var getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;
            var getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;
            var hydrateInstance = $$$hostConfig.hydrateInstance;
            var hydrateTextInstance = $$$hostConfig.hydrateTextInstance;
            var hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;
            var getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;
            var commitHydratedContainer = $$$hostConfig.commitHydratedContainer;
            var commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;
            var clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;
            var clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;
            var shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;
            var didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;
            var didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;
            var didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;
            var didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;
            var didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;
            var didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;
            var didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;
            var didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;
            var didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;
            var didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;
            var didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;
            var didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;
            var didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;
            var didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;
            var errorHydratingContainer = $$$hostConfig.errorHydratingContainer;
            // Helpers to patch console.logs to avoid logging during side-effect free
            // replaying on render function. This currently only patches the object
            // lazily which won't cover if the log function was extracted eagerly.
            // We could also eagerly patch the method.
            var disabledDepth = 0;
            var prevLog;
            var prevInfo;
            var prevWarn;
            var prevError;
            var prevGroup;
            var prevGroupCollapsed;
            var prevGroupEnd;
            function disabledLog() {}
            disabledLog.__reactDisabledLog = true;
            function disableLogs() {
                {
                    if (disabledDepth === 0) {
                        /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
                        prevInfo = console.info;
                        prevWarn = console.warn;
                        prevError = console.error;
                        prevGroup = console.group;
                        prevGroupCollapsed = console.groupCollapsed;
                        prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
                        var props = {
                            configurable: true,
                            enumerable: true,
                            value: disabledLog,
                            writable: true
                        }; // $FlowFixMe Flow thinks console is immutable.
                        Object.defineProperties(console, {
                            info: props,
                            log: props,
                            warn: props,
                            error: props,
                            group: props,
                            groupCollapsed: props,
                            groupEnd: props
                        });
                    /* eslint-enable react-internal/no-production-logging */ }
                    disabledDepth++;
                }
            }
            function reenableLogs() {
                {
                    disabledDepth--;
                    if (disabledDepth === 0) {
                        /* eslint-disable react-internal/no-production-logging */ var props = {
                            configurable: true,
                            enumerable: true,
                            writable: true
                        }; // $FlowFixMe Flow thinks console is immutable.
                        Object.defineProperties(console, {
                            log: assign({}, props, {
                                value: prevLog
                            }),
                            info: assign({}, props, {
                                value: prevInfo
                            }),
                            warn: assign({}, props, {
                                value: prevWarn
                            }),
                            error: assign({}, props, {
                                value: prevError
                            }),
                            group: assign({}, props, {
                                value: prevGroup
                            }),
                            groupCollapsed: assign({}, props, {
                                value: prevGroupCollapsed
                            }),
                            groupEnd: assign({}, props, {
                                value: prevGroupEnd
                            })
                        });
                    /* eslint-enable react-internal/no-production-logging */ }
                    if (disabledDepth < 0) {
                        error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                    }
                }
            }
            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
            var prefix;
            function describeBuiltInComponentFrame(name, source, ownerFn) {
                {
                    if (prefix === undefined) {
                        // Extract the VM specific prefix used by each line.
                        try {
                            throw Error();
                        } catch (x) {
                            var match = x.stack.trim().match(/\n( *(at )?)/);
                            prefix = match && match[1] || '';
                        }
                    } // We use the prefix to ensure our stacks line up with native stack frames.
                    return '\n' + prefix + name;
                }
            }
            var reentry = false;
            var componentFrameCache;
            {
                var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
                componentFrameCache = new PossiblyWeakMap();
            }
            function describeNativeComponentFrame(fn, construct) {
                // If something asked for a stack inside a fake render, it should get ignored.
                if (!fn || reentry) {
                    return '';
                }
                {
                    var frame = componentFrameCache.get(fn);
                    if (frame !== undefined) {
                        return frame;
                    }
                }
                var control;
                reentry = true;
                var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
                Error.prepareStackTrace = undefined;
                var previousDispatcher;
                {
                    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
                    // for warnings.
                    ReactCurrentDispatcher.current = null;
                    disableLogs();
                }
                try {
                    // This should throw.
                    if (construct) {
                        // Something should be setting the props in the constructor.
                        var Fake = function Fake() {
                            throw Error();
                        }; // $FlowFixMe
                        Object.defineProperty(Fake.prototype, 'props', {
                            set: function set() {
                                // We use a throwing setter instead of frozen or non-writable props
                                // because that won't throw in a non-strict mode function.
                                throw Error();
                            }
                        });
                        if ((typeof Reflect === "undefined" ? "undefined" : _type_of(Reflect)) === 'object' && Reflect.construct) {
                            // We construct a different control for this case to include any extra
                            // frames added by the construct call.
                            try {
                                Reflect.construct(Fake, []);
                            } catch (x) {
                                control = x;
                            }
                            Reflect.construct(fn, [], Fake);
                        } else {
                            try {
                                Fake.call();
                            } catch (x) {
                                control = x;
                            }
                            fn.call(Fake.prototype);
                        }
                    } else {
                        try {
                            throw Error();
                        } catch (x) {
                            control = x;
                        }
                        fn();
                    }
                } catch (sample) {
                    // This is inlined manually because closure doesn't do it for us.
                    if (sample && control && typeof sample.stack === 'string') {
                        // This extracts the first frame from the sample that isn't also in the control.
                        // Skipping one frame that we assume is the frame that calls the two.
                        var sampleLines = sample.stack.split('\n');
                        var controlLines = control.stack.split('\n');
                        var s = sampleLines.length - 1;
                        var c = controlLines.length - 1;
                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                            // We expect at least one stack frame to be shared.
                            // Typically this will be the root most one. However, stack frames may be
                            // cut off due to maximum stack limits. In this case, one maybe cut off
                            // earlier than the other. We assume that the sample is longer or the same
                            // and there for cut off earlier. So we should find the root most frame in
                            // the sample somewhere in the control.
                            c--;
                        }
                        for(; s >= 1 && c >= 0; s--, c--){
                            // Next we find the first one that isn't the same which should be the
                            // frame that called our sample function and the control.
                            if (sampleLines[s] !== controlLines[c]) {
                                // In V8, the first line is describing the message but other VMs don't.
                                // If we're about to return the first line, and the control is also on the same
                                // line, that's a pretty good indicator that our sample threw at same line as
                                // the control. I.e. before we entered the sample frame. So we ignore this result.
                                // This can happen if you passed a class to function component, or non-function.
                                if (s !== 1 || c !== 1) {
                                    do {
                                        s--;
                                        c--; // We may still have similar intermediate frames from the construct call.
                                        // The next one that isn't the same should be our match though.
                                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                                            // but we have a user-provided "displayName"
                                            // splice it in to make the stack more readable.
                                            if (fn.displayName && _frame.includes('<anonymous>')) {
                                                _frame = _frame.replace('<anonymous>', fn.displayName);
                                            }
                                            {
                                                if (typeof fn === 'function') {
                                                    componentFrameCache.set(fn, _frame);
                                                }
                                            }
                                            return _frame;
                                        }
                                    }while (s >= 1 && c >= 0);
                                }
                                break;
                            }
                        }
                    }
                } finally{
                    reentry = false;
                    {
                        ReactCurrentDispatcher.current = previousDispatcher;
                        reenableLogs();
                    }
                    Error.prepareStackTrace = previousPrepareStackTrace;
                } // Fallback to just using the name if we couldn't make it throw.
                var name = fn ? fn.displayName || fn.name : '';
                var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
                {
                    if (typeof fn === 'function') {
                        componentFrameCache.set(fn, syntheticFrame);
                    }
                }
                return syntheticFrame;
            }
            function describeClassComponentFrame(ctor, source, ownerFn) {
                {
                    return describeNativeComponentFrame(ctor, true);
                }
            }
            function describeFunctionComponentFrame(fn, source, ownerFn) {
                {
                    return describeNativeComponentFrame(fn, false);
                }
            }
            function shouldConstruct(Component) {
                var prototype = Component.prototype;
                return !!(prototype && prototype.isReactComponent);
            }
            function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
                if (type == null) {
                    return '';
                }
                if (typeof type === 'function') {
                    {
                        return describeNativeComponentFrame(type, shouldConstruct(type));
                    }
                }
                if (typeof type === 'string') {
                    return describeBuiltInComponentFrame(type);
                }
                switch(type){
                    case REACT_SUSPENSE_TYPE:
                        return describeBuiltInComponentFrame('Suspense');
                    case REACT_SUSPENSE_LIST_TYPE:
                        return describeBuiltInComponentFrame('SuspenseList');
                }
                if ((typeof type === "undefined" ? "undefined" : _type_of(type)) === 'object') {
                    switch(type.$$typeof){
                        case REACT_FORWARD_REF_TYPE:
                            return describeFunctionComponentFrame(type.render);
                        case REACT_MEMO_TYPE:
                            // Memo may contain any component type so we recursively resolve it.
                            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                        case REACT_LAZY_TYPE:
                            {
                                var lazyComponent = type;
                                var payload = lazyComponent._payload;
                                var init = lazyComponent._init;
                                try {
                                    // Lazy may contain any component type so we recursively resolve it.
                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                                } catch (x) {}
                            }
                    }
                }
                return '';
            }
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var loggedTypeFailures = {};
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            function setCurrentlyValidatingElement(element) {
                {
                    if (element) {
                        var owner = element._owner;
                        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                        ReactDebugCurrentFrame.setExtraStackFrame(stack);
                    } else {
                        ReactDebugCurrentFrame.setExtraStackFrame(null);
                    }
                }
            }
            function checkPropTypes(typeSpecs, values, location, componentName, element) {
                {
                    // $FlowFixMe This is okay but Flow doesn't know it.
                    var has = Function.call.bind(hasOwnProperty);
                    for(var typeSpecName in typeSpecs){
                        if (has(typeSpecs, typeSpecName)) {
                            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
                            // fail the render phase where it didn't fail before. So we log it.
                            // After these have been cleaned up, we'll let them throw.
                            try {
                                // This is intentionally an invariant that gets caught. It's the same
                                // behavior as without this statement except with a better message.
                                if (typeof typeSpecs[typeSpecName] !== 'function') {
                                    // eslint-disable-next-line react-internal/prod-error-codes
                                    var _$err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _type_of(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                                    _$err.name = 'Invariant Violation';
                                    throw _$err;
                                }
                                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
                            } catch (ex) {
                                error$1 = ex;
                            }
                            if (error$1 && !_instanceof(error$1, Error)) {
                                setCurrentlyValidatingElement(element);
                                error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1 === "undefined" ? "undefined" : _type_of(error$1));
                                setCurrentlyValidatingElement(null);
                            }
                            if (_instanceof(error$1, Error) && !(error$1.message in loggedTypeFailures)) {
                                // Only monitor this failure once because there tends to be a lot of the
                                // same error.
                                loggedTypeFailures[error$1.message] = true;
                                setCurrentlyValidatingElement(element);
                                error('Failed %s type: %s', location, error$1.message);
                                setCurrentlyValidatingElement(null);
                            }
                        }
                    }
                }
            }
            var valueStack = [];
            var fiberStack;
            {
                fiberStack = [];
            }
            var index = -1;
            function createCursor(defaultValue) {
                return {
                    current: defaultValue
                };
            }
            function pop(cursor, fiber) {
                if (index < 0) {
                    {
                        error('Unexpected pop.');
                    }
                    return;
                }
                {
                    if (fiber !== fiberStack[index]) {
                        error('Unexpected Fiber popped.');
                    }
                }
                cursor.current = valueStack[index];
                valueStack[index] = null;
                {
                    fiberStack[index] = null;
                }
                index--;
            }
            function push(cursor, value, fiber) {
                index++;
                valueStack[index] = cursor.current;
                {
                    fiberStack[index] = fiber;
                }
                cursor.current = value;
            }
            var warnedAboutMissingGetChildContext;
            {
                warnedAboutMissingGetChildContext = {};
            }
            var emptyContextObject = {};
            {
                Object.freeze(emptyContextObject);
            }
            var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.
            var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
            // We use this to get access to the parent context after we have already
            // pushed the next context provider, and now need to merge their contexts.
            var previousContext = emptyContextObject;
            function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
                {
                    if (didPushOwnContextIfProvider && isContextProvider(Component)) {
                        // If the fiber is a context provider itself, when we read its context
                        // we may have already pushed its own child context on the stack. A context
                        // provider should not "see" its own child context. Therefore we read the
                        // previous (parent) context instead for a context provider.
                        return previousContext;
                    }
                    return contextStackCursor.current;
                }
            }
            function cacheContext(workInProgress, unmaskedContext, maskedContext) {
                {
                    var instance = workInProgress.stateNode;
                    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
                    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
                }
            }
            function getMaskedContext(workInProgress, unmaskedContext) {
                {
                    var type = workInProgress.type;
                    var contextTypes = type.contextTypes;
                    if (!contextTypes) {
                        return emptyContextObject;
                    } // Avoid recreating masked context unless unmasked context has changed.
                    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
                    // This may trigger infinite loops if componentWillReceiveProps calls setState.
                    var instance = workInProgress.stateNode;
                    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                        return instance.__reactInternalMemoizedMaskedChildContext;
                    }
                    var context = {};
                    for(var key in contextTypes){
                        context[key] = unmaskedContext[key];
                    }
                    {
                        var name = getComponentNameFromFiber(workInProgress) || 'Unknown';
                        checkPropTypes(contextTypes, context, 'context', name);
                    }
                    // Context is created before the class component is instantiated so check for instance.
                    if (instance) {
                        cacheContext(workInProgress, unmaskedContext, context);
                    }
                    return context;
                }
            }
            function hasContextChanged() {
                {
                    return didPerformWorkStackCursor.current;
                }
            }
            function isContextProvider(type) {
                {
                    var childContextTypes = type.childContextTypes;
                    return childContextTypes !== null && childContextTypes !== undefined;
                }
            }
            function popContext(fiber) {
                {
                    pop(didPerformWorkStackCursor, fiber);
                    pop(contextStackCursor, fiber);
                }
            }
            function popTopLevelContextObject(fiber) {
                {
                    pop(didPerformWorkStackCursor, fiber);
                    pop(contextStackCursor, fiber);
                }
            }
            function pushTopLevelContextObject(fiber, context, didChange) {
                {
                    if (contextStackCursor.current !== emptyContextObject) {
                        throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    }
                    push(contextStackCursor, context, fiber);
                    push(didPerformWorkStackCursor, didChange, fiber);
                }
            }
            function processChildContext(fiber, type, parentContext) {
                {
                    var instance = fiber.stateNode;
                    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
                    // It has only been added in Fiber to match the (unintentional) behavior in Stack.
                    if (typeof instance.getChildContext !== 'function') {
                        {
                            var componentName = getComponentNameFromFiber(fiber) || 'Unknown';
                            if (!warnedAboutMissingGetChildContext[componentName]) {
                                warnedAboutMissingGetChildContext[componentName] = true;
                                error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
                            }
                        }
                        return parentContext;
                    }
                    var childContext = instance.getChildContext();
                    for(var contextKey in childContext){
                        if (!(contextKey in childContextTypes)) {
                            throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
                        }
                    }
                    {
                        var name = getComponentNameFromFiber(fiber) || 'Unknown';
                        checkPropTypes(childContextTypes, childContext, 'child context', name);
                    }
                    return assign({}, parentContext, childContext);
                }
            }
            function pushContextProvider(workInProgress) {
                {
                    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
                    // If the instance does not exist yet, we will push null at first,
                    // and replace it on the stack later when invalidating the context.
                    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
                    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
                    previousContext = contextStackCursor.current;
                    push(contextStackCursor, memoizedMergedChildContext, workInProgress);
                    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
                    return true;
                }
            }
            function invalidateContextProvider(workInProgress, type, didChange) {
                {
                    var instance = workInProgress.stateNode;
                    if (!instance) {
                        throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    }
                    if (didChange) {
                        // Merge parent and own context.
                        // Skip this if we're not updating due to sCU.
                        // This avoids unnecessarily recomputing memoized values.
                        var mergedContext = processChildContext(workInProgress, type, previousContext);
                        instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
                        // It is important to unwind the context in the reverse order.
                        pop(didPerformWorkStackCursor, workInProgress);
                        pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.
                        push(contextStackCursor, mergedContext, workInProgress);
                        push(didPerformWorkStackCursor, didChange, workInProgress);
                    } else {
                        pop(didPerformWorkStackCursor, workInProgress);
                        push(didPerformWorkStackCursor, didChange, workInProgress);
                    }
                }
            }
            function findCurrentUnmaskedContext(fiber) {
                {
                    // Currently this is only used with renderSubtreeIntoContainer; not sure if it
                    // makes sense elsewhere
                    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                        throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    }
                    var node = fiber;
                    do {
                        switch(node.tag){
                            case HostRoot:
                                return node.stateNode.context;
                            case ClassComponent:
                                {
                                    var Component = node.type;
                                    if (isContextProvider(Component)) {
                                        return node.stateNode.__reactInternalMemoizedMergedChildContext;
                                    }
                                    break;
                                }
                        }
                        node = node.return;
                    }while (node !== null);
                    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
            }
            var LegacyRoot = 0;
            var ConcurrentRoot = 1;
            var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead
            var ConcurrentMode = /*                 */ 1;
            var ProfileMode = /*                    */ 2;
            var StrictLegacyMode = /*               */ 8;
            var StrictEffectsMode = /*              */ 16;
            // TODO: This is pretty well supported by browsers. Maybe we can drop it.
            var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.
            // Based on:
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
            var log = Math.log;
            var LN2 = Math.LN2;
            function clz32Fallback(x) {
                var asUint = x >>> 0;
                if (asUint === 0) {
                    return 32;
                }
                return 31 - (log(asUint) / LN2 | 0) | 0;
            }
            // If those values are changed that package should be rebuilt and redeployed.
            var TotalLanes = 31;
            var NoLanes = /*                        */ 0;
            var NoLane = /*                          */ 0;
            var SyncLane = /*                        */ 1;
            var InputContinuousHydrationLane = /*    */ 2;
            var InputContinuousLane = /*             */ 4;
            var DefaultHydrationLane = /*            */ 8;
            var DefaultLane = /*                     */ 16;
            var TransitionHydrationLane = /*                */ 32;
            var TransitionLanes = /*                       */ 4194240;
            var TransitionLane1 = /*                        */ 64;
            var TransitionLane2 = /*                        */ 128;
            var TransitionLane3 = /*                        */ 256;
            var TransitionLane4 = /*                        */ 512;
            var TransitionLane5 = /*                        */ 1024;
            var TransitionLane6 = /*                        */ 2048;
            var TransitionLane7 = /*                        */ 4096;
            var TransitionLane8 = /*                        */ 8192;
            var TransitionLane9 = /*                        */ 16384;
            var TransitionLane10 = /*                       */ 32768;
            var TransitionLane11 = /*                       */ 65536;
            var TransitionLane12 = /*                       */ 131072;
            var TransitionLane13 = /*                       */ 262144;
            var TransitionLane14 = /*                       */ 524288;
            var TransitionLane15 = /*                       */ 1048576;
            var TransitionLane16 = /*                       */ 2097152;
            var RetryLanes = /*                            */ 130023424;
            var RetryLane1 = /*                             */ 4194304;
            var RetryLane2 = /*                             */ 8388608;
            var RetryLane3 = /*                             */ 16777216;
            var RetryLane4 = /*                             */ 33554432;
            var RetryLane5 = /*                             */ 67108864;
            var SomeRetryLane = RetryLane1;
            var SelectiveHydrationLane = /*          */ 134217728;
            var NonIdleLanes = /*                          */ 268435455;
            var IdleHydrationLane = /*               */ 268435456;
            var IdleLane = /*                        */ 536870912;
            var OffscreenLane = /*                   */ 1073741824; // This function is used for the experimental timeline (react-devtools-timeline)
            // It should be kept in sync with the Lanes values above.
            function getLabelForLane(lane) {
                {
                    if (lane & SyncLane) {
                        return 'Sync';
                    }
                    if (lane & InputContinuousHydrationLane) {
                        return 'InputContinuousHydration';
                    }
                    if (lane & InputContinuousLane) {
                        return 'InputContinuous';
                    }
                    if (lane & DefaultHydrationLane) {
                        return 'DefaultHydration';
                    }
                    if (lane & DefaultLane) {
                        return 'Default';
                    }
                    if (lane & TransitionHydrationLane) {
                        return 'TransitionHydration';
                    }
                    if (lane & TransitionLanes) {
                        return 'Transition';
                    }
                    if (lane & RetryLanes) {
                        return 'Retry';
                    }
                    if (lane & SelectiveHydrationLane) {
                        return 'SelectiveHydration';
                    }
                    if (lane & IdleHydrationLane) {
                        return 'IdleHydration';
                    }
                    if (lane & IdleLane) {
                        return 'Idle';
                    }
                    if (lane & OffscreenLane) {
                        return 'Offscreen';
                    }
                }
            }
            var NoTimestamp = -1;
            var nextTransitionLane = TransitionLane1;
            var nextRetryLane = RetryLane1;
            function getHighestPriorityLanes(lanes) {
                switch(getHighestPriorityLane(lanes)){
                    case SyncLane:
                        return SyncLane;
                    case InputContinuousHydrationLane:
                        return InputContinuousHydrationLane;
                    case InputContinuousLane:
                        return InputContinuousLane;
                    case DefaultHydrationLane:
                        return DefaultHydrationLane;
                    case DefaultLane:
                        return DefaultLane;
                    case TransitionHydrationLane:
                        return TransitionHydrationLane;
                    case TransitionLane1:
                    case TransitionLane2:
                    case TransitionLane3:
                    case TransitionLane4:
                    case TransitionLane5:
                    case TransitionLane6:
                    case TransitionLane7:
                    case TransitionLane8:
                    case TransitionLane9:
                    case TransitionLane10:
                    case TransitionLane11:
                    case TransitionLane12:
                    case TransitionLane13:
                    case TransitionLane14:
                    case TransitionLane15:
                    case TransitionLane16:
                        return lanes & TransitionLanes;
                    case RetryLane1:
                    case RetryLane2:
                    case RetryLane3:
                    case RetryLane4:
                    case RetryLane5:
                        return lanes & RetryLanes;
                    case SelectiveHydrationLane:
                        return SelectiveHydrationLane;
                    case IdleHydrationLane:
                        return IdleHydrationLane;
                    case IdleLane:
                        return IdleLane;
                    case OffscreenLane:
                        return OffscreenLane;
                    default:
                        {
                            error('Should have found matching lanes. This is a bug in React.');
                        }
                        return lanes;
                }
            }
            function getNextLanes(root, wipLanes) {
                // Early bailout if there's no pending work left.
                var pendingLanes = root.pendingLanes;
                if (pendingLanes === NoLanes) {
                    return NoLanes;
                }
                var nextLanes = NoLanes;
                var suspendedLanes = root.suspendedLanes;
                var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,
                // even if the work is suspended.
                var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
                if (nonIdlePendingLanes !== NoLanes) {
                    var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                    if (nonIdleUnblockedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                    } else {
                        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                        if (nonIdlePingedLanes !== NoLanes) {
                            nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                        }
                    }
                } else {
                    // The only remaining work is Idle.
                    var unblockedLanes = pendingLanes & ~suspendedLanes;
                    if (unblockedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(unblockedLanes);
                    } else {
                        if (pingedLanes !== NoLanes) {
                            nextLanes = getHighestPriorityLanes(pingedLanes);
                        }
                    }
                }
                if (nextLanes === NoLanes) {
                    // This should only be reachable if we're suspended
                    // TODO: Consider warning in this path if a fallback timer is not scheduled.
                    return NoLanes;
                } // If we're already in the middle of a render, switching lanes will interrupt
                // it and we'll lose our progress. We should only do this if the new lanes are
                // higher priority.
                if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
                // bother waiting until the root is complete.
                (wipLanes & suspendedLanes) === NoLanes) {
                    var nextLane = getHighestPriorityLane(nextLanes);
                    var wipLane = getHighestPriorityLane(wipLanes);
                    if (// one. This works because the bits decrease in priority as you go left.
                    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                    // only difference between default updates and transition updates is that
                    // default updates do not support refresh transitions.
                    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                        // Keep working on the existing in-progress tree. Do not interrupt.
                        return wipLanes;
                    }
                }
                if ((nextLanes & InputContinuousLane) !== NoLanes) {
                    // When updates are sync by default, we entangle continuous priority updates
                    // and default updates, so they render in the same batch. The only reason
                    // they use separate lanes is because continuous updates should interrupt
                    // transitions, but default updates should not.
                    nextLanes |= pendingLanes & DefaultLane;
                } // Check for entangled lanes and add them to the batch.
                //
                // A lane is said to be entangled with another when it's not allowed to render
                // in a batch that does not also include the other lane. Typically we do this
                // when multiple updates have the same source, and we only want to respond to
                // the most recent event from that source.
                //
                // Note that we apply entanglements *after* checking for partial work above.
                // This means that if a lane is entangled during an interleaved event while
                // it's already rendering, we won't interrupt it. This is intentional, since
                // entanglement is usually "best effort": we'll try our best to render the
                // lanes in the same batch, but it's not worth throwing out partially
                // completed work in order to do it.
                // TODO: Reconsider this. The counter-argument is that the partial work
                // represents an intermediate state, which we don't want to show to the user.
                // And by spending extra time finishing it, we're increasing the amount of
                // time it takes to show the final state, which is what they are actually
                // waiting for.
                //
                // For those exceptions where entanglement is semantically important, like
                // useMutableSource, we should ensure that there is no partial work at the
                // time we apply the entanglement.
                var entangledLanes = root.entangledLanes;
                if (entangledLanes !== NoLanes) {
                    var entanglements = root.entanglements;
                    var lanes = nextLanes & entangledLanes;
                    while(lanes > 0){
                        var index = pickArbitraryLaneIndex(lanes);
                        var lane = 1 << index;
                        nextLanes |= entanglements[index];
                        lanes &= ~lane;
                    }
                }
                return nextLanes;
            }
            function getMostRecentEventTime(root, lanes) {
                var eventTimes = root.eventTimes;
                var mostRecentEventTime = NoTimestamp;
                while(lanes > 0){
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    var eventTime = eventTimes[index];
                    if (eventTime > mostRecentEventTime) {
                        mostRecentEventTime = eventTime;
                    }
                    lanes &= ~lane;
                }
                return mostRecentEventTime;
            }
            function computeExpirationTime(lane, currentTime) {
                switch(lane){
                    case SyncLane:
                    case InputContinuousHydrationLane:
                    case InputContinuousLane:
                        // User interactions should expire slightly more quickly.
                        //
                        // NOTE: This is set to the corresponding constant as in Scheduler.js.
                        // When we made it larger, a product metric in www regressed, suggesting
                        // there's a user interaction that's being starved by a series of
                        // synchronous updates. If that theory is correct, the proper solution is
                        // to fix the starvation. However, this scenario supports the idea that
                        // expiration times are an important safeguard when starvation
                        // does happen.
                        return currentTime + 250;
                    case DefaultHydrationLane:
                    case DefaultLane:
                    case TransitionHydrationLane:
                    case TransitionLane1:
                    case TransitionLane2:
                    case TransitionLane3:
                    case TransitionLane4:
                    case TransitionLane5:
                    case TransitionLane6:
                    case TransitionLane7:
                    case TransitionLane8:
                    case TransitionLane9:
                    case TransitionLane10:
                    case TransitionLane11:
                    case TransitionLane12:
                    case TransitionLane13:
                    case TransitionLane14:
                    case TransitionLane15:
                    case TransitionLane16:
                        return currentTime + 5000;
                    case RetryLane1:
                    case RetryLane2:
                    case RetryLane3:
                    case RetryLane4:
                    case RetryLane5:
                        // TODO: Retries should be allowed to expire if they are CPU bound for
                        // too long, but when I made this change it caused a spike in browser
                        // crashes. There must be some other underlying bug; not super urgent but
                        // ideally should figure out why and fix it. Unfortunately we don't have
                        // a repro for the crashes, only detected via production metrics.
                        return NoTimestamp;
                    case SelectiveHydrationLane:
                    case IdleHydrationLane:
                    case IdleLane:
                    case OffscreenLane:
                        // Anything idle priority or lower should never expire.
                        return NoTimestamp;
                    default:
                        {
                            error('Should have found matching lanes. This is a bug in React.');
                        }
                        return NoTimestamp;
                }
            }
            function markStarvedLanesAsExpired(root, currentTime) {
                // TODO: This gets called every time we yield. We can optimize by storing
                // the earliest expiration time on the root. Then use that to quickly bail out
                // of this function.
                var pendingLanes = root.pendingLanes;
                var suspendedLanes = root.suspendedLanes;
                var pingedLanes = root.pingedLanes;
                var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
                // expiration time. If so, we'll assume the update is being starved and mark
                // it as expired to force it to finish.
                var lanes = pendingLanes;
                while(lanes > 0){
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    var expirationTime = expirationTimes[index];
                    if (expirationTime === NoTimestamp) {
                        // Found a pending lane with no expiration time. If it's not suspended, or
                        // if it's pinged, assume it's CPU-bound. Compute a new expiration time
                        // using the current time.
                        if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                            // Assumes timestamps are monotonically increasing.
                            expirationTimes[index] = computeExpirationTime(lane, currentTime);
                        }
                    } else if (expirationTime <= currentTime) {
                        // This lane expired
                        root.expiredLanes |= lane;
                    }
                    lanes &= ~lane;
                }
            } // This returns the highest priority pending lanes regardless of whether they
            // are suspended.
            function getHighestPriorityPendingLanes(root) {
                return getHighestPriorityLanes(root.pendingLanes);
            }
            function getLanesToRetrySynchronouslyOnError(root) {
                var everythingButOffscreen = root.pendingLanes & -1073741825;
                if (everythingButOffscreen !== NoLanes) {
                    return everythingButOffscreen;
                }
                if (everythingButOffscreen & OffscreenLane) {
                    return OffscreenLane;
                }
                return NoLanes;
            }
            function includesSyncLane(lanes) {
                return (lanes & SyncLane) !== NoLanes;
            }
            function includesNonIdleWork(lanes) {
                return (lanes & NonIdleLanes) !== NoLanes;
            }
            function includesOnlyRetries(lanes) {
                return (lanes & RetryLanes) === lanes;
            }
            function includesOnlyNonUrgentLanes(lanes) {
                var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
                return (lanes & UrgentLanes) === NoLanes;
            }
            function includesOnlyTransitions(lanes) {
                return (lanes & TransitionLanes) === lanes;
            }
            function includesBlockingLane(root, lanes) {
                var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
                return (lanes & SyncDefaultLanes) !== NoLanes;
            }
            function includesExpiredLane(root, lanes) {
                // This is a separate check from includesBlockingLane because a lane can
                // expire after a render has already started.
                return (lanes & root.expiredLanes) !== NoLanes;
            }
            function isTransitionLane(lane) {
                return (lane & TransitionLanes) !== NoLanes;
            }
            function claimNextTransitionLane() {
                // Cycle through the lanes, assigning each new transition to the next lane.
                // In most cases, this means every transition gets its own lane, until we
                // run out of lanes and cycle back to the beginning.
                var lane = nextTransitionLane;
                nextTransitionLane <<= 1;
                if ((nextTransitionLane & TransitionLanes) === NoLanes) {
                    nextTransitionLane = TransitionLane1;
                }
                return lane;
            }
            function claimNextRetryLane() {
                var lane = nextRetryLane;
                nextRetryLane <<= 1;
                if ((nextRetryLane & RetryLanes) === NoLanes) {
                    nextRetryLane = RetryLane1;
                }
                return lane;
            }
            function getHighestPriorityLane(lanes) {
                return lanes & -lanes;
            }
            function pickArbitraryLane(lanes) {
                // This wrapper function gets inlined. Only exists so to communicate that it
                // doesn't matter which bit is selected; you can pick any bit without
                // affecting the algorithms where its used. Here I'm using
                // getHighestPriorityLane because it requires the fewest operations.
                return getHighestPriorityLane(lanes);
            }
            function pickArbitraryLaneIndex(lanes) {
                return 31 - clz32(lanes);
            }
            function laneToIndex(lane) {
                return pickArbitraryLaneIndex(lane);
            }
            function includesSomeLane(a, b) {
                return (a & b) !== NoLanes;
            }
            function isSubsetOfLanes(set, subset) {
                return (set & subset) === subset;
            }
            function mergeLanes(a, b) {
                return a | b;
            }
            function removeLanes(set, subset) {
                return set & ~subset;
            }
            function intersectLanes(a, b) {
                return a & b;
            } // Seems redundant, but it changes the type from a single lane (used for
            // updates) to a group of lanes (used for flushing work).
            function laneToLanes(lane) {
                return lane;
            }
            function higherPriorityLane(a, b) {
                // This works because the bit ranges decrease in priority as you go left.
                return a !== NoLane && a < b ? a : b;
            }
            function createLaneMap(initial) {
                // Intentionally pushing one by one.
                // https://v8.dev/blog/elements-kinds#avoid-creating-holes
                var laneMap = [];
                for(var i = 0; i < TotalLanes; i++){
                    laneMap.push(initial);
                }
                return laneMap;
            }
            function markRootUpdated(root, updateLane, eventTime) {
                root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update
                // could unblock them. Clear the suspended lanes so that we can try rendering
                // them again.
                //
                // TODO: We really only need to unsuspend only lanes that are in the
                // `subtreeLanes` of the updated fiber, or the update lanes of the return
                // path. This would exclude suspended updates in an unrelated sibling tree,
                // since there's no way for this update to unblock it.
                //
                // We don't do this if the incoming update is idle, because we never process
                // idle updates until after all the regular updates have finished; there's no
                // way it could unblock a transition.
                if (updateLane !== IdleLane) {
                    root.suspendedLanes = NoLanes;
                    root.pingedLanes = NoLanes;
                }
                var eventTimes = root.eventTimes;
                var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
                // recent event, and we assume time is monotonically increasing.
                eventTimes[index] = eventTime;
            }
            function markRootSuspended(root, suspendedLanes) {
                root.suspendedLanes |= suspendedLanes;
                root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.
                var expirationTimes = root.expirationTimes;
                var lanes = suspendedLanes;
                while(lanes > 0){
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    expirationTimes[index] = NoTimestamp;
                    lanes &= ~lane;
                }
            }
            function markRootPinged(root, pingedLanes, eventTime) {
                root.pingedLanes |= root.suspendedLanes & pingedLanes;
            }
            function markRootFinished(root, remainingLanes) {
                var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
                root.pendingLanes = remainingLanes; // Let's try everything again
                root.suspendedLanes = NoLanes;
                root.pingedLanes = NoLanes;
                root.expiredLanes &= remainingLanes;
                root.mutableReadLanes &= remainingLanes;
                root.entangledLanes &= remainingLanes;
                var entanglements = root.entanglements;
                var eventTimes = root.eventTimes;
                var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work
                var lanes = noLongerPendingLanes;
                while(lanes > 0){
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    entanglements[index] = NoLanes;
                    eventTimes[index] = NoTimestamp;
                    expirationTimes[index] = NoTimestamp;
                    lanes &= ~lane;
                }
            }
            function markRootEntangled(root, entangledLanes) {
                // In addition to entangling each of the given lanes with each other, we also
                // have to consider _transitive_ entanglements. For each lane that is already
                // entangled with *any* of the given lanes, that lane is now transitively
                // entangled with *all* the given lanes.
                //
                // Translated: If C is entangled with A, then entangling A with B also
                // entangles C with B.
                //
                // If this is hard to grasp, it might help to intentionally break this
                // function and look at the tests that fail in ReactTransition-test.js. Try
                // commenting out one of the conditions below.
                var rootEntangledLanes = root.entangledLanes |= entangledLanes;
                var entanglements = root.entanglements;
                var lanes = rootEntangledLanes;
                while(lanes){
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                    entanglements[index] & entangledLanes) {
                        entanglements[index] |= entangledLanes;
                    }
                    lanes &= ~lane;
                }
            }
            function getBumpedLaneForHydration(root, renderLanes) {
                var renderLane = getHighestPriorityLane(renderLanes);
                var lane;
                switch(renderLane){
                    case InputContinuousLane:
                        lane = InputContinuousHydrationLane;
                        break;
                    case DefaultLane:
                        lane = DefaultHydrationLane;
                        break;
                    case TransitionLane1:
                    case TransitionLane2:
                    case TransitionLane3:
                    case TransitionLane4:
                    case TransitionLane5:
                    case TransitionLane6:
                    case TransitionLane7:
                    case TransitionLane8:
                    case TransitionLane9:
                    case TransitionLane10:
                    case TransitionLane11:
                    case TransitionLane12:
                    case TransitionLane13:
                    case TransitionLane14:
                    case TransitionLane15:
                    case TransitionLane16:
                    case RetryLane1:
                    case RetryLane2:
                    case RetryLane3:
                    case RetryLane4:
                    case RetryLane5:
                        lane = TransitionHydrationLane;
                        break;
                    case IdleLane:
                        lane = IdleHydrationLane;
                        break;
                    default:
                        // Everything else is already either a hydration lane, or shouldn't
                        // be retried at a hydration lane.
                        lane = NoLane;
                        break;
                } // Check if the lane we chose is suspended. If so, that indicates that we
                // already attempted and failed to hydrate at that level. Also check if we're
                // already rendering that lane, which is rare but could happen.
                if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
                    // Give up trying to hydrate and fall back to client render.
                    return NoLane;
                }
                return lane;
            }
            function addFiberToLanesMap(root, fiber, lanes) {
                if (!isDevToolsPresent) {
                    return;
                }
                var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
                while(lanes > 0){
                    var index = laneToIndex(lanes);
                    var lane = 1 << index;
                    var updaters = pendingUpdatersLaneMap[index];
                    updaters.add(fiber);
                    lanes &= ~lane;
                }
            }
            function movePendingFibersToMemoized(root, lanes) {
                if (!isDevToolsPresent) {
                    return;
                }
                var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
                var memoizedUpdaters = root.memoizedUpdaters;
                while(lanes > 0){
                    var index = laneToIndex(lanes);
                    var lane = 1 << index;
                    var updaters = pendingUpdatersLaneMap[index];
                    if (updaters.size > 0) {
                        updaters.forEach(function(fiber) {
                            var alternate = fiber.alternate;
                            if (alternate === null || !memoizedUpdaters.has(alternate)) {
                                memoizedUpdaters.add(fiber);
                            }
                        });
                        updaters.clear();
                    }
                    lanes &= ~lane;
                }
            }
            function getTransitionsForLanes(root, lanes) {
                {
                    return null;
                }
            }
            var DiscreteEventPriority = SyncLane;
            var ContinuousEventPriority = InputContinuousLane;
            var DefaultEventPriority = DefaultLane;
            var IdleEventPriority = IdleLane;
            var currentUpdatePriority = NoLane;
            function getCurrentUpdatePriority() {
                return currentUpdatePriority;
            }
            function setCurrentUpdatePriority(newPriority) {
                currentUpdatePriority = newPriority;
            }
            function runWithPriority(priority, fn) {
                var previousPriority = currentUpdatePriority;
                try {
                    currentUpdatePriority = priority;
                    return fn();
                } finally{
                    currentUpdatePriority = previousPriority;
                }
            }
            function higherEventPriority(a, b) {
                return a !== 0 && a < b ? a : b;
            }
            function lowerEventPriority(a, b) {
                return a > b ? a : b;
            }
            function isHigherEventPriority(a, b) {
                return a !== 0 && a < b;
            }
            function lanesToEventPriority(lanes) {
                var lane = getHighestPriorityLane(lanes);
                if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
                    return DiscreteEventPriority;
                }
                if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
                    return ContinuousEventPriority;
                }
                if (includesNonIdleWork(lane)) {
                    return DefaultEventPriority;
                }
                return IdleEventPriority;
            }
            // This module only exists as an ESM wrapper around the external CommonJS
            var scheduleCallback = Scheduler.unstable_scheduleCallback;
            var cancelCallback = Scheduler.unstable_cancelCallback;
            var shouldYield = Scheduler.unstable_shouldYield;
            var requestPaint = Scheduler.unstable_requestPaint;
            var now = Scheduler.unstable_now;
            var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
            var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
            var NormalPriority = Scheduler.unstable_NormalPriority;
            var IdlePriority = Scheduler.unstable_IdlePriority;
            // this doesn't actually exist on the scheduler, but it *does*
            // on scheduler/unstable_mock, which we'll need for internal testing
            var unstable_yieldValue = Scheduler.unstable_yieldValue;
            var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
            var rendererID = null;
            var injectedHook = null;
            var injectedProfilingHooks = null;
            var hasLoggedError = false;
            var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
            function injectInternals(internals) {
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                    // No DevTools
                    return false;
                }
                var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (hook.isDisabled) {
                    // This isn't a real property on the hook, but it can be set to opt out
                    // of DevTools integration and associated warnings and logs.
                    // https://github.com/facebook/react/issues/3877
                    return true;
                }
                if (!hook.supportsFiber) {
                    {
                        error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
                    }
                    return true;
                }
                try {
                    if (enableSchedulingProfiler) {
                        // Conditionally inject these hooks only if Timeline profiler is supported by this build.
                        // This gives DevTools a way to feature detect that isn't tied to version number
                        // (since profiling and timeline are controlled by different feature flags).
                        internals = assign({}, internals, {
                            getLaneLabelMap: getLaneLabelMap,
                            injectProfilingHooks: injectProfilingHooks
                        });
                    }
                    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
                    injectedHook = hook;
                } catch (err) {
                    // Catch all errors because it is unsafe to throw during initialization.
                    {
                        error('React instrumentation encountered an error: %s.', err);
                    }
                }
                if (hook.checkDCE) {
                    // This is the real DevTools.
                    return true;
                } else {
                    // This is likely a hook installed by Fast Refresh runtime.
                    return false;
                }
            }
            function onScheduleRoot(root, children) {
                {
                    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
                        try {
                            injectedHook.onScheduleFiberRoot(rendererID, root, children);
                        } catch (err) {
                            if (!hasLoggedError) {
                                hasLoggedError = true;
                                error('React instrumentation encountered an error: %s', err);
                            }
                        }
                    }
                }
            }
            function onCommitRoot(root, eventPriority) {
                if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
                    try {
                        var didError = (root.current.flags & DidCapture) === DidCapture;
                        if (enableProfilerTimer) {
                            var schedulerPriority;
                            switch(eventPriority){
                                case DiscreteEventPriority:
                                    schedulerPriority = ImmediatePriority;
                                    break;
                                case ContinuousEventPriority:
                                    schedulerPriority = UserBlockingPriority;
                                    break;
                                case DefaultEventPriority:
                                    schedulerPriority = NormalPriority;
                                    break;
                                case IdleEventPriority:
                                    schedulerPriority = IdlePriority;
                                    break;
                                default:
                                    schedulerPriority = NormalPriority;
                                    break;
                            }
                            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
                        }
                    } catch (err) {
                        {
                            if (!hasLoggedError) {
                                hasLoggedError = true;
                                error('React instrumentation encountered an error: %s', err);
                            }
                        }
                    }
                }
            }
            function onPostCommitRoot(root) {
                if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {
                    try {
                        injectedHook.onPostCommitFiberRoot(rendererID, root);
                    } catch (err) {
                        {
                            if (!hasLoggedError) {
                                hasLoggedError = true;
                                error('React instrumentation encountered an error: %s', err);
                            }
                        }
                    }
                }
            }
            function onCommitUnmount(fiber) {
                if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
                    try {
                        injectedHook.onCommitFiberUnmount(rendererID, fiber);
                    } catch (err) {
                        {
                            if (!hasLoggedError) {
                                hasLoggedError = true;
                                error('React instrumentation encountered an error: %s', err);
                            }
                        }
                    }
                }
            }
            function setIsStrictModeForDevtools(newIsStrictMode) {
                {
                    if (typeof unstable_yieldValue === 'function') {
                        // We're in a test because Scheduler.unstable_yieldValue only exists
                        // in SchedulerMock. To reduce the noise in strict mode tests,
                        // suppress warnings and disable scheduler yielding during the double render
                        unstable_setDisableYieldValue(newIsStrictMode);
                        setSuppressWarning(newIsStrictMode);
                    }
                    if (injectedHook && typeof injectedHook.setStrictMode === 'function') {
                        try {
                            injectedHook.setStrictMode(rendererID, newIsStrictMode);
                        } catch (err) {
                            {
                                if (!hasLoggedError) {
                                    hasLoggedError = true;
                                    error('React instrumentation encountered an error: %s', err);
                                }
                            }
                        }
                    }
                }
            } // Profiler API hooks
            function injectProfilingHooks(profilingHooks) {
                injectedProfilingHooks = profilingHooks;
            }
            function getLaneLabelMap() {
                {
                    var map = new Map();
                    var lane = 1;
                    for(var index = 0; index < TotalLanes; index++){
                        var label = getLabelForLane(lane);
                        map.set(lane, label);
                        lane *= 2;
                    }
                    return map;
                }
            }
            function markCommitStarted(lanes) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {
                        injectedProfilingHooks.markCommitStarted(lanes);
                    }
                }
            }
            function markCommitStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {
                        injectedProfilingHooks.markCommitStopped();
                    }
                }
            }
            function markComponentRenderStarted(fiber) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {
                        injectedProfilingHooks.markComponentRenderStarted(fiber);
                    }
                }
            }
            function markComponentRenderStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {
                        injectedProfilingHooks.markComponentRenderStopped();
                    }
                }
            }
            function markComponentPassiveEffectMountStarted(fiber) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {
                        injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
                    }
                }
            }
            function markComponentPassiveEffectMountStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {
                        injectedProfilingHooks.markComponentPassiveEffectMountStopped();
                    }
                }
            }
            function markComponentPassiveEffectUnmountStarted(fiber) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {
                        injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
                    }
                }
            }
            function markComponentPassiveEffectUnmountStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {
                        injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
                    }
                }
            }
            function markComponentLayoutEffectMountStarted(fiber) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {
                        injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
                    }
                }
            }
            function markComponentLayoutEffectMountStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {
                        injectedProfilingHooks.markComponentLayoutEffectMountStopped();
                    }
                }
            }
            function markComponentLayoutEffectUnmountStarted(fiber) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {
                        injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
                    }
                }
            }
            function markComponentLayoutEffectUnmountStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {
                        injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
                    }
                }
            }
            function markComponentErrored(fiber, thrownValue, lanes) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {
                        injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
                    }
                }
            }
            function markComponentSuspended(fiber, wakeable, lanes) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {
                        injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
                    }
                }
            }
            function markLayoutEffectsStarted(lanes) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {
                        injectedProfilingHooks.markLayoutEffectsStarted(lanes);
                    }
                }
            }
            function markLayoutEffectsStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {
                        injectedProfilingHooks.markLayoutEffectsStopped();
                    }
                }
            }
            function markPassiveEffectsStarted(lanes) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {
                        injectedProfilingHooks.markPassiveEffectsStarted(lanes);
                    }
                }
            }
            function markPassiveEffectsStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {
                        injectedProfilingHooks.markPassiveEffectsStopped();
                    }
                }
            }
            function markRenderStarted(lanes) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {
                        injectedProfilingHooks.markRenderStarted(lanes);
                    }
                }
            }
            function markRenderYielded() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {
                        injectedProfilingHooks.markRenderYielded();
                    }
                }
            }
            function markRenderStopped() {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {
                        injectedProfilingHooks.markRenderStopped();
                    }
                }
            }
            function markRenderScheduled(lane) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {
                        injectedProfilingHooks.markRenderScheduled(lane);
                    }
                }
            }
            function markForceUpdateScheduled(fiber, lane) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {
                        injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
                    }
                }
            }
            function markStateUpdateScheduled(fiber, lane) {
                {
                    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {
                        injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
                    }
                }
            }
            /**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */ function is(x, y) {
                return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
                ;
            }
            var objectIs = typeof Object.is === 'function' ? Object.is : is;
            var syncQueue = null;
            var includesLegacySyncCallbacks = false;
            var isFlushingSyncQueue = false;
            function scheduleSyncCallback(callback) {
                // Push this callback into an internal queue. We'll flush these either in
                // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
                if (syncQueue === null) {
                    syncQueue = [
                        callback
                    ];
                } else {
                    // Push onto existing queue. Don't need to schedule a callback because
                    // we already scheduled one when we created the queue.
                    syncQueue.push(callback);
                }
            }
            function scheduleLegacySyncCallback(callback) {
                includesLegacySyncCallbacks = true;
                scheduleSyncCallback(callback);
            }
            function flushSyncCallbacksOnlyInLegacyMode() {
                // Only flushes the queue if there's a legacy sync callback scheduled.
                // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So
                // it might make more sense for the queue to be a list of roots instead of a
                // list of generic callbacks. Then we can have two: one for legacy roots, one
                // for concurrent roots. And this method would only flush the legacy ones.
                if (includesLegacySyncCallbacks) {
                    flushSyncCallbacks();
                }
            }
            function flushSyncCallbacks() {
                if (!isFlushingSyncQueue && syncQueue !== null) {
                    // Prevent re-entrance.
                    isFlushingSyncQueue = true;
                    var i = 0;
                    var previousUpdatePriority = getCurrentUpdatePriority();
                    try {
                        var isSync = true;
                        var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this
                        // queue is in the render or commit phases.
                        setCurrentUpdatePriority(DiscreteEventPriority);
                        for(; i < queue.length; i++){
                            var callback = queue[i];
                            do {
                                callback = callback(isSync);
                            }while (callback !== null);
                        }
                        syncQueue = null;
                        includesLegacySyncCallbacks = false;
                    } catch (error) {
                        // If something throws, leave the remaining callbacks on the queue.
                        if (syncQueue !== null) {
                            syncQueue = syncQueue.slice(i + 1);
                        } // Resume flushing in the next tick
                        scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                        throw error;
                    } finally{
                        setCurrentUpdatePriority(previousUpdatePriority);
                        isFlushingSyncQueue = false;
                    }
                }
                return null;
            }
            // This is imported by the event replaying implementation in React DOM. It's
            // in a separate file to break a circular dependency between the renderer and
            // the reconciler.
            function isRootDehydrated(root) {
                var currentState = root.current.memoizedState;
                return currentState.isDehydrated;
            }
            // TODO: Use the unified fiber stack module instead of this local one?
            // Intentionally not using it yet to derisk the initial implementation, because
            // the way we push/pop these values is a bit unusual. If there's a mistake, I'd
            // rather the ids be wrong than crash the whole reconciler.
            var forkStack = [];
            var forkStackIndex = 0;
            var treeForkProvider = null;
            var treeForkCount = 0;
            var idStack = [];
            var idStackIndex = 0;
            var treeContextProvider = null;
            var treeContextId = 1;
            var treeContextOverflow = '';
            function isForkedChild(workInProgress) {
                warnIfNotHydrating();
                return (workInProgress.flags & Forked) !== NoFlags;
            }
            function getForksAtLevel(workInProgress) {
                warnIfNotHydrating();
                return treeForkCount;
            }
            function getTreeId() {
                var overflow = treeContextOverflow;
                var idWithLeadingBit = treeContextId;
                var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
                return id.toString(32) + overflow;
            }
            function pushTreeFork(workInProgress, totalChildren) {
                // This is called right after we reconcile an array (or iterator) of child
                // fibers, because that's the only place where we know how many children in
                // the whole set without doing extra work later, or storing addtional
                // information on the fiber.
                //
                // That's why this function is separate from pushTreeId — it's called during
                // the render phase of the fork parent, not the child, which is where we push
                // the other context values.
                //
                // In the Fizz implementation this is much simpler because the child is
                // rendered in the same callstack as the parent.
                //
                // It might be better to just add a `forks` field to the Fiber type. It would
                // make this module simpler.
                warnIfNotHydrating();
                forkStack[forkStackIndex++] = treeForkCount;
                forkStack[forkStackIndex++] = treeForkProvider;
                treeForkProvider = workInProgress;
                treeForkCount = totalChildren;
            }
            function pushTreeId(workInProgress, totalChildren, index) {
                warnIfNotHydrating();
                idStack[idStackIndex++] = treeContextId;
                idStack[idStackIndex++] = treeContextOverflow;
                idStack[idStackIndex++] = treeContextProvider;
                treeContextProvider = workInProgress;
                var baseIdWithLeadingBit = treeContextId;
                var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
                // of the id; we use it to account for leading 0s.
                var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
                var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
                var slot = index + 1;
                var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into
                // consideration the leading 1 we use to mark the end of the sequence.
                if (length > 30) {
                    // We overflowed the bitwise-safe range. Fall back to slower algorithm.
                    // This branch assumes the length of the base id is greater than 5; it won't
                    // work for smaller ids, because you need 5 bits per character.
                    //
                    // We encode the id in multiple steps: first the base id, then the
                    // remaining digits.
                    //
                    // Each 5 bit sequence corresponds to a single base 32 character. So for
                    // example, if the current id is 23 bits long, we can convert 20 of those
                    // bits into a string of 4 characters, with 3 bits left over.
                    //
                    // First calculate how many bits in the base id represent a complete
                    // sequence of characters.
                    var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.
                    var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.
                    var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.
                    var restOfBaseId = baseId >> numberOfOverflowBits;
                    var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because
                    // we made more room, this time it won't overflow.
                    var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
                    var restOfNewBits = slot << restOfBaseLength;
                    var id = restOfNewBits | restOfBaseId;
                    var overflow = newOverflow + baseOverflow;
                    treeContextId = 1 << restOfLength | id;
                    treeContextOverflow = overflow;
                } else {
                    // Normal path
                    var newBits = slot << baseLength;
                    var _id = newBits | baseId;
                    var _overflow = baseOverflow;
                    treeContextId = 1 << length | _id;
                    treeContextOverflow = _overflow;
                }
            }
            function pushMaterializedTreeId(workInProgress) {
                warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear
                // in its children.
                var returnFiber = workInProgress.return;
                if (returnFiber !== null) {
                    var numberOfForks = 1;
                    var slotIndex = 0;
                    pushTreeFork(workInProgress, numberOfForks);
                    pushTreeId(workInProgress, numberOfForks, slotIndex);
                }
            }
            function getBitLength(number) {
                return 32 - clz32(number);
            }
            function getLeadingBit(id) {
                return 1 << getBitLength(id) - 1;
            }
            function popTreeContext(workInProgress) {
                // Restore the previous values.
                // This is a bit more complicated than other context-like modules in Fiber
                // because the same Fiber may appear on the stack multiple times and for
                // different reasons. We have to keep popping until the work-in-progress is
                // no longer at the top of the stack.
                while(workInProgress === treeForkProvider){
                    treeForkProvider = forkStack[--forkStackIndex];
                    forkStack[forkStackIndex] = null;
                    treeForkCount = forkStack[--forkStackIndex];
                    forkStack[forkStackIndex] = null;
                }
                while(workInProgress === treeContextProvider){
                    treeContextProvider = idStack[--idStackIndex];
                    idStack[idStackIndex] = null;
                    treeContextOverflow = idStack[--idStackIndex];
                    idStack[idStackIndex] = null;
                    treeContextId = idStack[--idStackIndex];
                    idStack[idStackIndex] = null;
                }
            }
            function getSuspendedTreeContext() {
                warnIfNotHydrating();
                if (treeContextProvider !== null) {
                    return {
                        id: treeContextId,
                        overflow: treeContextOverflow
                    };
                } else {
                    return null;
                }
            }
            function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
                warnIfNotHydrating();
                idStack[idStackIndex++] = treeContextId;
                idStack[idStackIndex++] = treeContextOverflow;
                idStack[idStackIndex++] = treeContextProvider;
                treeContextId = suspendedContext.id;
                treeContextOverflow = suspendedContext.overflow;
                treeContextProvider = workInProgress;
            }
            function warnIfNotHydrating() {
                {
                    if (!getIsHydrating()) {
                        error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');
                    }
                }
            }
            // This may have been an insertion or a hydration.
            var hydrationParentFiber = null;
            var nextHydratableInstance = null;
            var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches
            // due to earlier mismatches or a suspended fiber.
            var didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary
            var hydrationErrors = null;
            function warnIfHydrating() {
                {
                    if (isHydrating) {
                        error('We should not be hydrating here. This is a bug in React. Please file a bug.');
                    }
                }
            }
            function markDidThrowWhileHydratingDEV() {
                {
                    didSuspendOrErrorDEV = true;
                }
            }
            function didSuspendOrErrorWhileHydratingDEV() {
                {
                    return didSuspendOrErrorDEV;
                }
            }
            function enterHydrationState(fiber) {
                if (!supportsHydration) {
                    return false;
                }
                var parentInstance = fiber.stateNode.containerInfo;
                nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
                hydrationParentFiber = fiber;
                isHydrating = true;
                hydrationErrors = null;
                didSuspendOrErrorDEV = false;
                return true;
            }
            function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
                if (!supportsHydration) {
                    return false;
                }
                nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
                hydrationParentFiber = fiber;
                isHydrating = true;
                hydrationErrors = null;
                didSuspendOrErrorDEV = false;
                if (treeContext !== null) {
                    restoreSuspendedTreeContext(fiber, treeContext);
                }
                return true;
            }
            function warnUnhydratedInstance(returnFiber, instance) {
                {
                    switch(returnFiber.tag){
                        case HostRoot:
                            {
                                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                                break;
                            }
                        case HostComponent:
                            {
                                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, isConcurrentMode);
                                break;
                            }
                        case SuspenseComponent:
                            {
                                var suspenseState = returnFiber.memoizedState;
                                if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                                break;
                            }
                    }
                }
            }
            function deleteHydratableInstance(returnFiber, instance) {
                warnUnhydratedInstance(returnFiber, instance);
                var childToDelete = createFiberFromHostInstanceForDeletion();
                childToDelete.stateNode = instance;
                childToDelete.return = returnFiber;
                var deletions = returnFiber.deletions;
                if (deletions === null) {
                    returnFiber.deletions = [
                        childToDelete
                    ];
                    returnFiber.flags |= ChildDeletion;
                } else {
                    deletions.push(childToDelete);
                }
            }
            function warnNonhydratedInstance(returnFiber, fiber) {
                {
                    if (didSuspendOrErrorDEV) {
                        // Inside a boundary that already suspended. We're currently rendering the
                        // siblings of a suspended node. The mismatch may be due to the missing
                        // data, so it's probably a false positive.
                        return;
                    }
                    switch(returnFiber.tag){
                        case HostRoot:
                            {
                                var parentContainer = returnFiber.stateNode.containerInfo;
                                switch(fiber.tag){
                                    case HostComponent:
                                        var type = fiber.type;
                                        var props = fiber.pendingProps;
                                        didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);
                                        break;
                                    case HostText:
                                        var text = fiber.pendingProps;
                                        didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                                        break;
                                    case SuspenseComponent:
                                        didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);
                                        break;
                                }
                                break;
                            }
                        case HostComponent:
                            {
                                var parentType = returnFiber.type;
                                var parentProps = returnFiber.memoizedProps;
                                var parentInstance = returnFiber.stateNode;
                                switch(fiber.tag){
                                    case HostComponent:
                                        {
                                            var _type = fiber.type;
                                            var _props = fiber.pendingProps;
                                            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                            didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, isConcurrentMode);
                                            break;
                                        }
                                    case HostText:
                                        {
                                            var _text = fiber.pendingProps;
                                            var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                            didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, _isConcurrentMode);
                                            break;
                                        }
                                    case SuspenseComponent:
                                        {
                                            didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
                                            break;
                                        }
                                }
                                break;
                            }
                        case SuspenseComponent:
                            {
                                var suspenseState = returnFiber.memoizedState;
                                var _parentInstance = suspenseState.dehydrated;
                                if (_parentInstance !== null) switch(fiber.tag){
                                    case HostComponent:
                                        var _type2 = fiber.type;
                                        var _props2 = fiber.pendingProps;
                                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);
                                        break;
                                    case HostText:
                                        var _text2 = fiber.pendingProps;
                                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                                        break;
                                    case SuspenseComponent:
                                        didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);
                                        break;
                                }
                                break;
                            }
                        default:
                            return;
                    }
                }
            }
            function insertNonHydratedInstance(returnFiber, fiber) {
                fiber.flags = fiber.flags & -4097 | Placement;
                warnNonhydratedInstance(returnFiber, fiber);
            }
            function tryHydrate(fiber, nextInstance) {
                switch(fiber.tag){
                    case HostComponent:
                        {
                            var type = fiber.type;
                            var props = fiber.pendingProps;
                            var instance = canHydrateInstance(nextInstance, type, props);
                            if (instance !== null) {
                                fiber.stateNode = instance;
                                hydrationParentFiber = fiber;
                                nextHydratableInstance = getFirstHydratableChild(instance);
                                return true;
                            }
                            return false;
                        }
                    case HostText:
                        {
                            var text = fiber.pendingProps;
                            var textInstance = canHydrateTextInstance(nextInstance, text);
                            if (textInstance !== null) {
                                fiber.stateNode = textInstance;
                                hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.
                                nextHydratableInstance = null;
                                return true;
                            }
                            return false;
                        }
                    case SuspenseComponent:
                        {
                            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                            if (suspenseInstance !== null) {
                                var suspenseState = {
                                    dehydrated: suspenseInstance,
                                    treeContext: getSuspendedTreeContext(),
                                    retryLane: OffscreenLane
                                };
                                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.
                                // This simplifies the code for getHostSibling and deleting nodes,
                                // since it doesn't have to consider all Suspense boundaries and
                                // check if they're dehydrated ones or not.
                                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                                dehydratedFragment.return = fiber;
                                fiber.child = dehydratedFragment;
                                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into
                                // it during the first pass. Instead, we'll reenter it later.
                                nextHydratableInstance = null;
                                return true;
                            }
                            return false;
                        }
                    default:
                        return false;
                }
            }
            function shouldClientRenderOnMismatch(fiber) {
                return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
            }
            function throwOnHydrationMismatch(fiber) {
                throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');
            }
            function tryToClaimNextHydratableInstance(fiber) {
                if (!isHydrating) {
                    return;
                }
                var nextInstance = nextHydratableInstance;
                if (!nextInstance) {
                    if (shouldClientRenderOnMismatch(fiber)) {
                        warnNonhydratedInstance(hydrationParentFiber, fiber);
                        throwOnHydrationMismatch();
                    } // Nothing to hydrate. Make it an insertion.
                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                    isHydrating = false;
                    hydrationParentFiber = fiber;
                    return;
                }
                var firstAttemptedInstance = nextInstance;
                if (!tryHydrate(fiber, nextInstance)) {
                    if (shouldClientRenderOnMismatch(fiber)) {
                        warnNonhydratedInstance(hydrationParentFiber, fiber);
                        throwOnHydrationMismatch();
                    } // If we can't hydrate this instance let's try the next one.
                    // We use this as a heuristic. It's based on intuition and not data so it
                    // might be flawed or unnecessary.
                    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
                    var prevHydrationParentFiber = hydrationParentFiber;
                    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                        // Nothing to hydrate. Make it an insertion.
                        insertNonHydratedInstance(hydrationParentFiber, fiber);
                        isHydrating = false;
                        hydrationParentFiber = fiber;
                        return;
                    } // We matched the next one, we'll now assume that the first one was
                    // superfluous and we'll delete it. Since we can't eagerly delete it
                    // we'll have to schedule a deletion. To do that, this node needs a dummy
                    // fiber associated with it.
                    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
                }
            }
            function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
                if (!supportsHydration) {
                    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                var instance = fiber.stateNode;
                var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
                var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.
                fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
                // is a new ref we mark this as an update.
                if (updatePayload !== null) {
                    return true;
                }
                return false;
            }
            function prepareToHydrateHostTextInstance(fiber) {
                if (!supportsHydration) {
                    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                var textInstance = fiber.stateNode;
                var textContent = fiber.memoizedProps;
                var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
                var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);
                if (shouldUpdate) {
                    // We assume that prepareToHydrateHostTextInstance is called in a context where the
                    // hydration parent is the parent host component of this host text.
                    var returnFiber = hydrationParentFiber;
                    if (returnFiber !== null) {
                        switch(returnFiber.tag){
                            case HostRoot:
                                {
                                    var parentContainer = returnFiber.stateNode.containerInfo;
                                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);
                                    break;
                                }
                            case HostComponent:
                                {
                                    var parentType = returnFiber.type;
                                    var parentProps = returnFiber.memoizedProps;
                                    var parentInstance = returnFiber.stateNode;
                                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, _isConcurrentMode2);
                                    break;
                                }
                        }
                    }
                }
                return shouldUpdate;
            }
            function prepareToHydrateHostSuspenseInstance(fiber) {
                if (!supportsHydration) {
                    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                var suspenseState = fiber.memoizedState;
                var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
                if (!suspenseInstance) {
                    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                hydrateSuspenseInstance(suspenseInstance, fiber);
            }
            function skipPastDehydratedSuspenseInstance(fiber) {
                if (!supportsHydration) {
                    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                var suspenseState = fiber.memoizedState;
                var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
                if (!suspenseInstance) {
                    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
            }
            function popToNextHostParent(fiber) {
                var parent = fiber.return;
                while(parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent){
                    parent = parent.return;
                }
                hydrationParentFiber = parent;
            }
            function popHydrationState(fiber) {
                if (!supportsHydration) {
                    return false;
                }
                if (fiber !== hydrationParentFiber) {
                    // We're deeper than the current hydration context, inside an inserted
                    // tree.
                    return false;
                }
                if (!isHydrating) {
                    // If we're not currently hydrating but we're in a hydration context, then
                    // we were an insertion and now need to pop up reenter hydration of our
                    // siblings.
                    popToNextHostParent(fiber);
                    isHydrating = true;
                    return false;
                } // If we have any remaining hydratable nodes, we need to delete them now.
                // We only do this deeper than head and body since they tend to have random
                // other nodes in them. We also ignore components with pure text content in
                // side of them. We also don't delete anything inside the root container.
                if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
                    var nextInstance = nextHydratableInstance;
                    if (nextInstance) {
                        if (shouldClientRenderOnMismatch(fiber)) {
                            warnIfUnhydratedTailNodes(fiber);
                            throwOnHydrationMismatch();
                        } else {
                            while(nextInstance){
                                deleteHydratableInstance(fiber, nextInstance);
                                nextInstance = getNextHydratableSibling(nextInstance);
                            }
                        }
                    }
                }
                popToNextHostParent(fiber);
                if (fiber.tag === SuspenseComponent) {
                    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
                } else {
                    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
                }
                return true;
            }
            function hasUnhydratedTailNodes() {
                return isHydrating && nextHydratableInstance !== null;
            }
            function warnIfUnhydratedTailNodes(fiber) {
                var nextInstance = nextHydratableInstance;
                while(nextInstance){
                    warnUnhydratedInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                }
            }
            function resetHydrationState() {
                if (!supportsHydration) {
                    return;
                }
                hydrationParentFiber = null;
                nextHydratableInstance = null;
                isHydrating = false;
                didSuspendOrErrorDEV = false;
            }
            function upgradeHydrationErrorsToRecoverable() {
                if (hydrationErrors !== null) {
                    // Successfully completed a forced client render. The errors that occurred
                    // during the hydration attempt are now recovered. We will log them in
                    // commit phase, once the entire tree has finished.
                    queueRecoverableErrors(hydrationErrors);
                    hydrationErrors = null;
                }
            }
            function getIsHydrating() {
                return isHydrating;
            }
            function queueHydrationError(error) {
                if (hydrationErrors === null) {
                    hydrationErrors = [
                        error
                    ];
                } else {
                    hydrationErrors.push(error);
                }
            }
            var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
            var NoTransition = null;
            function requestCurrentTransition() {
                return ReactCurrentBatchConfig.transition;
            }
            /**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */ function shallowEqual(objA, objB) {
                if (objectIs(objA, objB)) {
                    return true;
                }
                if ((typeof objA === "undefined" ? "undefined" : _type_of(objA)) !== 'object' || objA === null || (typeof objB === "undefined" ? "undefined" : _type_of(objB)) !== 'object' || objB === null) {
                    return false;
                }
                var keysA = Object.keys(objA);
                var keysB = Object.keys(objB);
                if (keysA.length !== keysB.length) {
                    return false;
                } // Test for A's keys different from B.
                for(var i = 0; i < keysA.length; i++){
                    var currentKey = keysA[i];
                    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                        return false;
                    }
                }
                return true;
            }
            function describeFiber(fiber) {
                fiber._debugOwner ? fiber._debugOwner.type : null;
                fiber._debugSource;
                switch(fiber.tag){
                    case HostComponent:
                        return describeBuiltInComponentFrame(fiber.type);
                    case LazyComponent:
                        return describeBuiltInComponentFrame('Lazy');
                    case SuspenseComponent:
                        return describeBuiltInComponentFrame('Suspense');
                    case SuspenseListComponent:
                        return describeBuiltInComponentFrame('SuspenseList');
                    case FunctionComponent:
                    case IndeterminateComponent:
                    case SimpleMemoComponent:
                        return describeFunctionComponentFrame(fiber.type);
                    case ForwardRef:
                        return describeFunctionComponentFrame(fiber.type.render);
                    case ClassComponent:
                        return describeClassComponentFrame(fiber.type);
                    default:
                        return '';
                }
            }
            function getStackByFiberInDevAndProd(workInProgress) {
                try {
                    var info = '';
                    var node = workInProgress;
                    do {
                        info += describeFiber(node);
                        node = node.return;
                    }while (node);
                    return info;
                } catch (x) {
                    return '\nError generating stack: ' + x.message + '\n' + x.stack;
                }
            }
            var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
            var current = null;
            var isRendering = false;
            function getCurrentFiberOwnerNameInDevOrNull() {
                {
                    if (current === null) {
                        return null;
                    }
                    var owner = current._debugOwner;
                    if (owner !== null && typeof owner !== 'undefined') {
                        return getComponentNameFromFiber(owner);
                    }
                }
                return null;
            }
            function getCurrentFiberStackInDev() {
                {
                    if (current === null) {
                        return '';
                    } // Safe because if current fiber exists, we are reconciling,
                    // and it is guaranteed to be the work-in-progress version.
                    return getStackByFiberInDevAndProd(current);
                }
            }
            function resetCurrentFiber() {
                {
                    ReactDebugCurrentFrame$1.getCurrentStack = null;
                    current = null;
                    isRendering = false;
                }
            }
            function setCurrentFiber(fiber) {
                {
                    ReactDebugCurrentFrame$1.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
                    current = fiber;
                    isRendering = false;
                }
            }
            function getCurrentFiber() {
                {
                    return current;
                }
            }
            function setIsRendering(rendering) {
                {
                    isRendering = rendering;
                }
            }
            var ReactStrictModeWarnings = {
                recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
                flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
                recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
                flushLegacyContextWarning: function flushLegacyContextWarning() {},
                discardPendingWarnings: function discardPendingWarnings() {}
            };
            {
                var findStrictRoot = function findStrictRoot(fiber) {
                    var maybeStrictRoot = null;
                    var node = fiber;
                    while(node !== null){
                        if (node.mode & StrictLegacyMode) {
                            maybeStrictRoot = node;
                        }
                        node = node.return;
                    }
                    return maybeStrictRoot;
                };
                var setToSortedString = function setToSortedString(set) {
                    var array = [];
                    set.forEach(function(value) {
                        array.push(value);
                    });
                    return array.sort().join(', ');
                };
                var pendingComponentWillMountWarnings = [];
                var pendingUNSAFE_ComponentWillMountWarnings = [];
                var pendingComponentWillReceivePropsWarnings = [];
                var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                var pendingComponentWillUpdateWarnings = [];
                var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
                var didWarnAboutUnsafeLifecycles = new Set();
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
                    // Dedupe strategy: Warn once per component.
                    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                        return;
                    }
                    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
                    instance.componentWillMount.__suppressDeprecationWarning !== true) {
                        pendingComponentWillMountWarnings.push(fiber);
                    }
                    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {
                        pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
                    }
                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                        pendingComponentWillReceivePropsWarnings.push(fiber);
                    }
                    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                        pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
                    }
                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                        pendingComponentWillUpdateWarnings.push(fiber);
                    }
                    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
                        pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
                    }
                };
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
                    // We do an initial pass to gather component names
                    var componentWillMountUniqueNames = new Set();
                    if (pendingComponentWillMountWarnings.length > 0) {
                        pendingComponentWillMountWarnings.forEach(function(fiber) {
                            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutUnsafeLifecycles.add(fiber.type);
                        });
                        pendingComponentWillMountWarnings = [];
                    }
                    var UNSAFE_componentWillMountUniqueNames = new Set();
                    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                        pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutUnsafeLifecycles.add(fiber.type);
                        });
                        pendingUNSAFE_ComponentWillMountWarnings = [];
                    }
                    var componentWillReceivePropsUniqueNames = new Set();
                    if (pendingComponentWillReceivePropsWarnings.length > 0) {
                        pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutUnsafeLifecycles.add(fiber.type);
                        });
                        pendingComponentWillReceivePropsWarnings = [];
                    }
                    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
                    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                        pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutUnsafeLifecycles.add(fiber.type);
                        });
                        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                    }
                    var componentWillUpdateUniqueNames = new Set();
                    if (pendingComponentWillUpdateWarnings.length > 0) {
                        pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutUnsafeLifecycles.add(fiber.type);
                        });
                        pendingComponentWillUpdateWarnings = [];
                    }
                    var UNSAFE_componentWillUpdateUniqueNames = new Set();
                    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                        pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutUnsafeLifecycles.add(fiber.type);
                        });
                        pendingUNSAFE_ComponentWillUpdateWarnings = [];
                    } // Finally, we flush all the warnings
                    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
                    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                        error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
                    }
                    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                        var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                        error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
                    }
                    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                        var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                        error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
                    }
                    if (componentWillMountUniqueNames.size > 0) {
                        var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                        warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
                    }
                    if (componentWillReceivePropsUniqueNames.size > 0) {
                        var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                        warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
                    }
                    if (componentWillUpdateUniqueNames.size > 0) {
                        var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                        warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
                    }
                };
                var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
                var didWarnAboutLegacyContext = new Set();
                ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
                    var strictRoot = findStrictRoot(fiber);
                    if (strictRoot === null) {
                        error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                        return;
                    } // Dedup strategy: Warn once per component.
                    if (didWarnAboutLegacyContext.has(fiber.type)) {
                        return;
                    }
                    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
                    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
                        if (warningsForRoot === undefined) {
                            warningsForRoot = [];
                            pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                        }
                        warningsForRoot.push(fiber);
                    }
                };
                ReactStrictModeWarnings.flushLegacyContextWarning = function() {
                    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                        if (fiberArray.length === 0) {
                            return;
                        }
                        var firstFiber = fiberArray[0];
                        var uniqueNames = new Set();
                        fiberArray.forEach(function(fiber) {
                            uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                            didWarnAboutLegacyContext.add(fiber.type);
                        });
                        var sortedNames = setToSortedString(uniqueNames);
                        try {
                            setCurrentFiber(firstFiber);
                            error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
                        } finally{
                            resetCurrentFiber();
                        }
                    });
                };
                ReactStrictModeWarnings.discardPendingWarnings = function() {
                    pendingComponentWillMountWarnings = [];
                    pendingUNSAFE_ComponentWillMountWarnings = [];
                    pendingComponentWillReceivePropsWarnings = [];
                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                    pendingComponentWillUpdateWarnings = [];
                    pendingUNSAFE_ComponentWillUpdateWarnings = [];
                    pendingLegacyContextWarning = new Map();
                };
            }
            /*
	 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
	 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
	 *
	 * The functions in this module will throw an easier-to-understand,
	 * easier-to-debug exception with a clear errors message message explaining the
	 * problem. (Instead of a confusing exception thrown inside the implementation
	 * of the `value` object).
	 */ // $FlowFixMe only called in DEV, so void return is not possible.
            function typeName(value) {
                {
                    // toStringTag is needed for namespaced types like Temporal.Instant
                    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
                    return type;
                }
            } // $FlowFixMe only called in DEV, so void return is not possible.
            function willCoercionThrow(value) {
                {
                    try {
                        testStringCoercion(value);
                        return false;
                    } catch (e) {
                        return true;
                    }
                }
            }
            function testStringCoercion(value) {
                // If you ended up here by following an exception call stack, here's what's
                // happened: you supplied an object or symbol value to React (as a prop, key,
                // DOM attribute, CSS property, string ref, etc.) and when React tried to
                // coerce it to a string using `'' + value`, an exception was thrown.
                //
                // The most common types that will cause this exception are `Symbol` instances
                // and Temporal objects like `Temporal.Instant`. But any object that has a
                // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
                // exception. (Library authors do this to prevent users from using built-in
                // numeric operators like `+` or comparison operators like `>=` because custom
                // methods are needed to perform accurate arithmetic or comparison.)
                //
                // To fix the problem, coerce this object or symbol value to a string before
                // passing it to React. The most reliable way is usually `String(value)`.
                //
                // To find which value is throwing, check the browser or debugger console.
                // Before this exception was thrown, there should be `console.error` output
                // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
                // problem and how that type was used: key, atrribute, input value prop, etc.
                // In most cases, this console output also shows the component and its
                // ancestor components where the exception happened.
                //
                // eslint-disable-next-line react-internal/safe-string-coercion
                return '' + value;
            }
            function checkKeyStringCoercion(value) {
                {
                    if (willCoercionThrow(value)) {
                        error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
                        return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                    }
                }
            }
            function checkPropStringCoercion(value, propName) {
                {
                    if (willCoercionThrow(value)) {
                        error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));
                        return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                    }
                }
            }
            var didWarnAboutMaps;
            var didWarnAboutGenerators;
            var didWarnAboutStringRefs;
            var ownerHasKeyUseWarning;
            var ownerHasFunctionTypeWarning;
            var warnForMissingKey = function warnForMissingKey(child, returnFiber) {};
            {
                didWarnAboutMaps = false;
                didWarnAboutGenerators = false;
                didWarnAboutStringRefs = {};
                /**
	   * Warn if there's no key explicitly set on dynamic arrays of children or
	   * object keys are not valid. This allows us to keep track of children between
	   * updates.
	   */ ownerHasKeyUseWarning = {};
                ownerHasFunctionTypeWarning = {};
                warnForMissingKey = function warnForMissingKey(child, returnFiber) {
                    if (child === null || (typeof child === "undefined" ? "undefined" : _type_of(child)) !== 'object') {
                        return;
                    }
                    if (!child._store || child._store.validated || child.key != null) {
                        return;
                    }
                    if (_type_of(child._store) !== 'object') {
                        throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    }
                    child._store.validated = true;
                    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                    if (ownerHasKeyUseWarning[componentName]) {
                        return;
                    }
                    ownerHasKeyUseWarning[componentName] = true;
                    error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
                };
            }
            function isReactClass(type) {
                return type.prototype && type.prototype.isReactComponent;
            }
            function coerceRef(returnFiber, current, element) {
                var mixedRef = element.ref;
                if (mixedRef !== null && typeof mixedRef !== 'function' && (typeof mixedRef === "undefined" ? "undefined" : _type_of(mixedRef)) !== 'object') {
                    {
                        // TODO: Clean this up once we turn on the string ref warning for
                        // everyone, because the strict mode case will no longer be relevant
                        if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                        // because these cannot be automatically converted to an arrow function
                        // using a codemod. Therefore, we don't have to warn about string refs again.
                        !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
                        !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
                        !(typeof element.type === 'function' && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
                        element._owner) {
                            var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                            if (!didWarnAboutStringRefs[componentName]) {
                                {
                                    error('Component "%s" contains the string ref "%s". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                                }
                                didWarnAboutStringRefs[componentName] = true;
                            }
                        }
                    }
                    if (element._owner) {
                        var owner = element._owner;
                        var inst;
                        if (owner) {
                            var ownerFiber = owner;
                            if (ownerFiber.tag !== ClassComponent) {
                                throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');
                            }
                            inst = ownerFiber.stateNode;
                        }
                        if (!inst) {
                            throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a " + 'bug in React. Please file an issue.');
                        } // Assigning this to a const so Flow knows it won't change in the closure
                        var resolvedInst = inst;
                        {
                            checkPropStringCoercion(mixedRef, 'ref');
                        }
                        var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref
                        if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
                            return current.ref;
                        }
                        var ref = function ref(value) {
                            var refs = resolvedInst.refs;
                            if (value === null) {
                                delete refs[stringRef];
                            } else {
                                refs[stringRef] = value;
                            }
                        };
                        ref._stringRef = stringRef;
                        return ref;
                    } else {
                        if (typeof mixedRef !== 'string') {
                            throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');
                        }
                        if (!element._owner) {
                            throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of" + ' the following reasons:\n' + '1. You may be adding a ref to a function component\n' + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + '3. You have multiple copies of React loaded\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');
                        }
                    }
                }
                return mixedRef;
            }
            function throwOnInvalidObjectType(returnFiber, newChild) {
                var childString = Object.prototype.toString.call(newChild);
                throw new Error("Objects are not valid as a React child (found: " + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
            }
            function warnOnFunctionType(returnFiber) {
                {
                    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                    if (ownerHasFunctionTypeWarning[componentName]) {
                        return;
                    }
                    ownerHasFunctionTypeWarning[componentName] = true;
                    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
                }
            }
            function resolveLazy(lazyType) {
                var payload = lazyType._payload;
                var init = lazyType._init;
                return init(payload);
            } // This wrapper function exists because I expect to clone the code in each path
            // to be able to optimize each path individually by branching early. This needs
            // a compiler or we can do it manually. Helpers that don't need this branching
            // live outside of this function.
            function ChildReconciler(shouldTrackSideEffects) {
                function deleteChild(returnFiber, childToDelete) {
                    if (!shouldTrackSideEffects) {
                        // Noop.
                        return;
                    }
                    var deletions = returnFiber.deletions;
                    if (deletions === null) {
                        returnFiber.deletions = [
                            childToDelete
                        ];
                        returnFiber.flags |= ChildDeletion;
                    } else {
                        deletions.push(childToDelete);
                    }
                }
                function deleteRemainingChildren(returnFiber, currentFirstChild) {
                    if (!shouldTrackSideEffects) {
                        // Noop.
                        return null;
                    } // TODO: For the shouldClone case, this could be micro-optimized a bit by
                    // assuming that after the first child we've already added everything.
                    var childToDelete = currentFirstChild;
                    while(childToDelete !== null){
                        deleteChild(returnFiber, childToDelete);
                        childToDelete = childToDelete.sibling;
                    }
                    return null;
                }
                function mapRemainingChildren(returnFiber, currentFirstChild) {
                    // Add the remaining children to a temporary map so that we can find them by
                    // keys quickly. Implicit (null) keys get added to this set with their index
                    // instead.
                    var existingChildren = new Map();
                    var existingChild = currentFirstChild;
                    while(existingChild !== null){
                        if (existingChild.key !== null) {
                            existingChildren.set(existingChild.key, existingChild);
                        } else {
                            existingChildren.set(existingChild.index, existingChild);
                        }
                        existingChild = existingChild.sibling;
                    }
                    return existingChildren;
                }
                function useFiber(fiber, pendingProps) {
                    // We currently set sibling to null and index to 0 here because it is easy
                    // to forget to do before returning it. E.g. for the single child case.
                    var clone = createWorkInProgress(fiber, pendingProps);
                    clone.index = 0;
                    clone.sibling = null;
                    return clone;
                }
                function placeChild(newFiber, lastPlacedIndex, newIndex) {
                    newFiber.index = newIndex;
                    if (!shouldTrackSideEffects) {
                        // During hydration, the useId algorithm needs to know which fibers are
                        // part of a list of children (arrays, iterators).
                        newFiber.flags |= Forked;
                        return lastPlacedIndex;
                    }
                    var current = newFiber.alternate;
                    if (current !== null) {
                        var oldIndex = current.index;
                        if (oldIndex < lastPlacedIndex) {
                            // This is a move.
                            newFiber.flags |= Placement;
                            return lastPlacedIndex;
                        } else {
                            // This item can stay in place.
                            return oldIndex;
                        }
                    } else {
                        // This is an insertion.
                        newFiber.flags |= Placement;
                        return lastPlacedIndex;
                    }
                }
                function placeSingleChild(newFiber) {
                    // This is simpler for the single child case. We only need to do a
                    // placement for inserting new children.
                    if (shouldTrackSideEffects && newFiber.alternate === null) {
                        newFiber.flags |= Placement;
                    }
                    return newFiber;
                }
                function updateTextNode(returnFiber, current, textContent, lanes) {
                    if (current === null || current.tag !== HostText) {
                        // Insert
                        var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                        created.return = returnFiber;
                        return created;
                    } else {
                        // Update
                        var existing = useFiber(current, textContent);
                        existing.return = returnFiber;
                        return existing;
                    }
                }
                function updateElement(returnFiber, current, element, lanes) {
                    var elementType = element.type;
                    if (elementType === REACT_FRAGMENT_TYPE) {
                        return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
                    }
                    if (current !== null) {
                        if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.
                        // We need to do this after the Hot Reloading check above,
                        // because hot reloading has different semantics than prod because
                        // it doesn't resuspend. So we can't let the call below suspend.
                        (typeof elementType === "undefined" ? "undefined" : _type_of(elementType)) === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {
                            // Move based on index
                            var existing = useFiber(current, element.props);
                            existing.ref = coerceRef(returnFiber, current, element);
                            existing.return = returnFiber;
                            {
                                existing._debugSource = element._source;
                                existing._debugOwner = element._owner;
                            }
                            return existing;
                        }
                    } // Insert
                    var created = createFiberFromElement(element, returnFiber.mode, lanes);
                    created.ref = coerceRef(returnFiber, current, element);
                    created.return = returnFiber;
                    return created;
                }
                function updatePortal(returnFiber, current, portal, lanes) {
                    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
                        // Insert
                        var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                        created.return = returnFiber;
                        return created;
                    } else {
                        // Update
                        var existing = useFiber(current, portal.children || []);
                        existing.return = returnFiber;
                        return existing;
                    }
                }
                function updateFragment(returnFiber, current, fragment, lanes, key) {
                    if (current === null || current.tag !== Fragment) {
                        // Insert
                        var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                        created.return = returnFiber;
                        return created;
                    } else {
                        // Update
                        var existing = useFiber(current, fragment);
                        existing.return = returnFiber;
                        return existing;
                    }
                }
                function createChild(returnFiber, newChild, lanes) {
                    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                        // Text nodes don't have keys. If the previous node is implicitly keyed
                        // we can continue to replace it without aborting even if it is not a text
                        // node.
                        var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
                        created.return = returnFiber;
                        return created;
                    }
                    if ((typeof newChild === "undefined" ? "undefined" : _type_of(newChild)) === 'object' && newChild !== null) {
                        switch(newChild.$$typeof){
                            case REACT_ELEMENT_TYPE:
                                {
                                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                                    _created.ref = coerceRef(returnFiber, null, newChild);
                                    _created.return = returnFiber;
                                    return _created;
                                }
                            case REACT_PORTAL_TYPE:
                                {
                                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                                    _created2.return = returnFiber;
                                    return _created2;
                                }
                            case REACT_LAZY_TYPE:
                                {
                                    var payload = newChild._payload;
                                    var init = newChild._init;
                                    return createChild(returnFiber, init(payload), lanes);
                                }
                        }
                        if (isArray(newChild) || getIteratorFn(newChild)) {
                            var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                            _created3.return = returnFiber;
                            return _created3;
                        }
                        throwOnInvalidObjectType(returnFiber, newChild);
                    }
                    {
                        if (typeof newChild === 'function') {
                            warnOnFunctionType(returnFiber);
                        }
                    }
                    return null;
                }
                function updateSlot(returnFiber, oldFiber, newChild, lanes) {
                    // Update the fiber if the keys match, otherwise return null.
                    var key = oldFiber !== null ? oldFiber.key : null;
                    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                        // Text nodes don't have keys. If the previous node is implicitly keyed
                        // we can continue to replace it without aborting even if it is not a text
                        // node.
                        if (key !== null) {
                            return null;
                        }
                        return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
                    }
                    if ((typeof newChild === "undefined" ? "undefined" : _type_of(newChild)) === 'object' && newChild !== null) {
                        switch(newChild.$$typeof){
                            case REACT_ELEMENT_TYPE:
                                {
                                    if (newChild.key === key) {
                                        return updateElement(returnFiber, oldFiber, newChild, lanes);
                                    } else {
                                        return null;
                                    }
                                }
                            case REACT_PORTAL_TYPE:
                                {
                                    if (newChild.key === key) {
                                        return updatePortal(returnFiber, oldFiber, newChild, lanes);
                                    } else {
                                        return null;
                                    }
                                }
                            case REACT_LAZY_TYPE:
                                {
                                    var payload = newChild._payload;
                                    var init = newChild._init;
                                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                                }
                        }
                        if (isArray(newChild) || getIteratorFn(newChild)) {
                            if (key !== null) {
                                return null;
                            }
                            return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                        }
                        throwOnInvalidObjectType(returnFiber, newChild);
                    }
                    {
                        if (typeof newChild === 'function') {
                            warnOnFunctionType(returnFiber);
                        }
                    }
                    return null;
                }
                function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
                    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                        // Text nodes don't have keys, so we neither have to check the old nor
                        // new node for the key. If both are text nodes, they match.
                        var matchedFiber = existingChildren.get(newIdx) || null;
                        return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
                    }
                    if ((typeof newChild === "undefined" ? "undefined" : _type_of(newChild)) === 'object' && newChild !== null) {
                        switch(newChild.$$typeof){
                            case REACT_ELEMENT_TYPE:
                                {
                                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                                }
                            case REACT_PORTAL_TYPE:
                                {
                                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                                }
                            case REACT_LAZY_TYPE:
                                var payload = newChild._payload;
                                var init = newChild._init;
                                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                        }
                        if (isArray(newChild) || getIteratorFn(newChild)) {
                            var _matchedFiber3 = existingChildren.get(newIdx) || null;
                            return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
                        }
                        throwOnInvalidObjectType(returnFiber, newChild);
                    }
                    {
                        if (typeof newChild === 'function') {
                            warnOnFunctionType(returnFiber);
                        }
                    }
                    return null;
                }
                /**
	   * Warns if there is a duplicate or missing key
	   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {
                    {
                        if ((typeof child === "undefined" ? "undefined" : _type_of(child)) !== 'object' || child === null) {
                            return knownKeys;
                        }
                        switch(child.$$typeof){
                            case REACT_ELEMENT_TYPE:
                            case REACT_PORTAL_TYPE:
                                warnForMissingKey(child, returnFiber);
                                var key = child.key;
                                if (typeof key !== 'string') {
                                    break;
                                }
                                if (knownKeys === null) {
                                    knownKeys = new Set();
                                    knownKeys.add(key);
                                    break;
                                }
                                if (!knownKeys.has(key)) {
                                    knownKeys.add(key);
                                    break;
                                }
                                error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);
                                break;
                            case REACT_LAZY_TYPE:
                                var payload = child._payload;
                                var init = child._init;
                                warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                                break;
                        }
                    }
                    return knownKeys;
                }
                function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
                    // This algorithm can't optimize by searching from both ends since we
                    // don't have backpointers on fibers. I'm trying to see how far we can get
                    // with that model. If it ends up not being worth the tradeoffs, we can
                    // add it later.
                    // Even with a two ended optimization, we'd want to optimize for the case
                    // where there are few changes and brute force the comparison instead of
                    // going for the Map. It'd like to explore hitting that path first in
                    // forward-only mode and only go for the Map once we notice that we need
                    // lots of look ahead. This doesn't handle reversal as well as two ended
                    // search but that's unusual. Besides, for the two ended optimization to
                    // work on Iterables, we'd need to copy the whole set.
                    // In this first iteration, we'll just live with hitting the bad case
                    // (adding everything to a Map) in for every insert/move.
                    // If you change this code, also update reconcileChildrenIterator() which
                    // uses the same algorithm.
                    {
                        // First, validate keys.
                        var knownKeys = null;
                        for(var i = 0; i < newChildren.length; i++){
                            var child = newChildren[i];
                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                        }
                    }
                    var resultingFirstChild = null;
                    var previousNewFiber = null;
                    var oldFiber = currentFirstChild;
                    var lastPlacedIndex = 0;
                    var newIdx = 0;
                    var nextOldFiber = null;
                    for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){
                        if (oldFiber.index > newIdx) {
                            nextOldFiber = oldFiber;
                            oldFiber = null;
                        } else {
                            nextOldFiber = oldFiber.sibling;
                        }
                        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                        if (newFiber === null) {
                            // TODO: This breaks on empty slots like null children. That's
                            // unfortunate because it triggers the slow path all the time. We need
                            // a better way to communicate whether this was a miss or null,
                            // boolean, undefined, etc.
                            if (oldFiber === null) {
                                oldFiber = nextOldFiber;
                            }
                            break;
                        }
                        if (shouldTrackSideEffects) {
                            if (oldFiber && newFiber.alternate === null) {
                                // We matched the slot, but we didn't reuse the existing fiber, so we
                                // need to delete the existing child.
                                deleteChild(returnFiber, oldFiber);
                            }
                        }
                        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            // TODO: Move out of the loop. This only happens for the first run.
                            resultingFirstChild = newFiber;
                        } else {
                            // TODO: Defer siblings if we're not at the right index for this slot.
                            // I.e. if we had null values before, then we want to defer this
                            // for each null value. However, we also don't want to call updateSlot
                            // with the previous one.
                            previousNewFiber.sibling = newFiber;
                        }
                        previousNewFiber = newFiber;
                        oldFiber = nextOldFiber;
                    }
                    if (newIdx === newChildren.length) {
                        // We've reached the end of the new children. We can delete the rest.
                        deleteRemainingChildren(returnFiber, oldFiber);
                        if (getIsHydrating()) {
                            var numberOfForks = newIdx;
                            pushTreeFork(returnFiber, numberOfForks);
                        }
                        return resultingFirstChild;
                    }
                    if (oldFiber === null) {
                        // If we don't have any more existing children we can choose a fast path
                        // since the rest will all be insertions.
                        for(; newIdx < newChildren.length; newIdx++){
                            var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                            if (_newFiber === null) {
                                continue;
                            }
                            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                            if (previousNewFiber === null) {
                                // TODO: Move out of the loop. This only happens for the first run.
                                resultingFirstChild = _newFiber;
                            } else {
                                previousNewFiber.sibling = _newFiber;
                            }
                            previousNewFiber = _newFiber;
                        }
                        if (getIsHydrating()) {
                            var _numberOfForks = newIdx;
                            pushTreeFork(returnFiber, _numberOfForks);
                        }
                        return resultingFirstChild;
                    } // Add all children to a key map for quick lookups.
                    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
                    for(; newIdx < newChildren.length; newIdx++){
                        var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                        if (_newFiber2 !== null) {
                            if (shouldTrackSideEffects) {
                                if (_newFiber2.alternate !== null) {
                                    // The new fiber is a work in progress, but if there exists a
                                    // current, that means that we reused the fiber. We need to delete
                                    // it from the child list so that we don't add it to the deletion
                                    // list.
                                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                                }
                            }
                            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                            if (previousNewFiber === null) {
                                resultingFirstChild = _newFiber2;
                            } else {
                                previousNewFiber.sibling = _newFiber2;
                            }
                            previousNewFiber = _newFiber2;
                        }
                    }
                    if (shouldTrackSideEffects) {
                        // Any existing children that weren't consumed above were deleted. We need
                        // to add them to the deletion list.
                        existingChildren.forEach(function(child) {
                            return deleteChild(returnFiber, child);
                        });
                    }
                    if (getIsHydrating()) {
                        var _numberOfForks2 = newIdx;
                        pushTreeFork(returnFiber, _numberOfForks2);
                    }
                    return resultingFirstChild;
                }
                function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
                    // This is the same implementation as reconcileChildrenArray(),
                    // but using the iterator instead.
                    var iteratorFn = getIteratorFn(newChildrenIterable);
                    if (typeof iteratorFn !== 'function') {
                        throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');
                    }
                    {
                        // We don't support rendering Generators because it's a mutation.
                        // See https://github.com/facebook/react/issues/12995
                        if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
                        newChildrenIterable[Symbol.toStringTag] === 'Generator') {
                            if (!didWarnAboutGenerators) {
                                error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
                            }
                            didWarnAboutGenerators = true;
                        } // Warn about using Maps as children
                        if (newChildrenIterable.entries === iteratorFn) {
                            if (!didWarnAboutMaps) {
                                error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                            }
                            didWarnAboutMaps = true;
                        } // First, validate keys.
                        // We'll get a different iterator later for the main pass.
                        var _newChildren = iteratorFn.call(newChildrenIterable);
                        if (_newChildren) {
                            var knownKeys = null;
                            var _step = _newChildren.next();
                            for(; !_step.done; _step = _newChildren.next()){
                                var child = _step.value;
                                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                            }
                        }
                    }
                    var newChildren = iteratorFn.call(newChildrenIterable);
                    if (newChildren == null) {
                        throw new Error('An iterable object provided no iterator.');
                    }
                    var resultingFirstChild = null;
                    var previousNewFiber = null;
                    var oldFiber = currentFirstChild;
                    var lastPlacedIndex = 0;
                    var newIdx = 0;
                    var nextOldFiber = null;
                    var step = newChildren.next();
                    for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){
                        if (oldFiber.index > newIdx) {
                            nextOldFiber = oldFiber;
                            oldFiber = null;
                        } else {
                            nextOldFiber = oldFiber.sibling;
                        }
                        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                        if (newFiber === null) {
                            // TODO: This breaks on empty slots like null children. That's
                            // unfortunate because it triggers the slow path all the time. We need
                            // a better way to communicate whether this was a miss or null,
                            // boolean, undefined, etc.
                            if (oldFiber === null) {
                                oldFiber = nextOldFiber;
                            }
                            break;
                        }
                        if (shouldTrackSideEffects) {
                            if (oldFiber && newFiber.alternate === null) {
                                // We matched the slot, but we didn't reuse the existing fiber, so we
                                // need to delete the existing child.
                                deleteChild(returnFiber, oldFiber);
                            }
                        }
                        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            // TODO: Move out of the loop. This only happens for the first run.
                            resultingFirstChild = newFiber;
                        } else {
                            // TODO: Defer siblings if we're not at the right index for this slot.
                            // I.e. if we had null values before, then we want to defer this
                            // for each null value. However, we also don't want to call updateSlot
                            // with the previous one.
                            previousNewFiber.sibling = newFiber;
                        }
                        previousNewFiber = newFiber;
                        oldFiber = nextOldFiber;
                    }
                    if (step.done) {
                        // We've reached the end of the new children. We can delete the rest.
                        deleteRemainingChildren(returnFiber, oldFiber);
                        if (getIsHydrating()) {
                            var numberOfForks = newIdx;
                            pushTreeFork(returnFiber, numberOfForks);
                        }
                        return resultingFirstChild;
                    }
                    if (oldFiber === null) {
                        // If we don't have any more existing children we can choose a fast path
                        // since the rest will all be insertions.
                        for(; !step.done; newIdx++, step = newChildren.next()){
                            var _newFiber3 = createChild(returnFiber, step.value, lanes);
                            if (_newFiber3 === null) {
                                continue;
                            }
                            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                            if (previousNewFiber === null) {
                                // TODO: Move out of the loop. This only happens for the first run.
                                resultingFirstChild = _newFiber3;
                            } else {
                                previousNewFiber.sibling = _newFiber3;
                            }
                            previousNewFiber = _newFiber3;
                        }
                        if (getIsHydrating()) {
                            var _numberOfForks3 = newIdx;
                            pushTreeFork(returnFiber, _numberOfForks3);
                        }
                        return resultingFirstChild;
                    } // Add all children to a key map for quick lookups.
                    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
                    for(; !step.done; newIdx++, step = newChildren.next()){
                        var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                        if (_newFiber4 !== null) {
                            if (shouldTrackSideEffects) {
                                if (_newFiber4.alternate !== null) {
                                    // The new fiber is a work in progress, but if there exists a
                                    // current, that means that we reused the fiber. We need to delete
                                    // it from the child list so that we don't add it to the deletion
                                    // list.
                                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                                }
                            }
                            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                            if (previousNewFiber === null) {
                                resultingFirstChild = _newFiber4;
                            } else {
                                previousNewFiber.sibling = _newFiber4;
                            }
                            previousNewFiber = _newFiber4;
                        }
                    }
                    if (shouldTrackSideEffects) {
                        // Any existing children that weren't consumed above were deleted. We need
                        // to add them to the deletion list.
                        existingChildren.forEach(function(child) {
                            return deleteChild(returnFiber, child);
                        });
                    }
                    if (getIsHydrating()) {
                        var _numberOfForks4 = newIdx;
                        pushTreeFork(returnFiber, _numberOfForks4);
                    }
                    return resultingFirstChild;
                }
                function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
                    // There's no need to check for keys on text nodes since we don't have a
                    // way to define them.
                    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                        // We already have an existing node so let's just update it and delete
                        // the rest.
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        var existing = useFiber(currentFirstChild, textContent);
                        existing.return = returnFiber;
                        return existing;
                    } // The existing first child is not a text node so we need to create one
                    // and delete the existing ones.
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    return created;
                }
                function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
                    var key = element.key;
                    var child = currentFirstChild;
                    while(child !== null){
                        // TODO: If key === null and child.key === null, then this only applies to
                        // the first item in the list.
                        if (child.key === key) {
                            var elementType = element.type;
                            if (elementType === REACT_FRAGMENT_TYPE) {
                                if (child.tag === Fragment) {
                                    deleteRemainingChildren(returnFiber, child.sibling);
                                    var existing = useFiber(child, element.props.children);
                                    existing.return = returnFiber;
                                    {
                                        existing._debugSource = element._source;
                                        existing._debugOwner = element._owner;
                                    }
                                    return existing;
                                }
                            } else {
                                if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                                // We need to do this after the Hot Reloading check above,
                                // because hot reloading has different semantics than prod because
                                // it doesn't resuspend. So we can't let the call below suspend.
                                (typeof elementType === "undefined" ? "undefined" : _type_of(elementType)) === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                                    deleteRemainingChildren(returnFiber, child.sibling);
                                    var _existing = useFiber(child, element.props);
                                    _existing.ref = coerceRef(returnFiber, child, element);
                                    _existing.return = returnFiber;
                                    {
                                        _existing._debugSource = element._source;
                                        _existing._debugOwner = element._owner;
                                    }
                                    return _existing;
                                }
                            } // Didn't match.
                            deleteRemainingChildren(returnFiber, child);
                            break;
                        } else {
                            deleteChild(returnFiber, child);
                        }
                        child = child.sibling;
                    }
                    if (element.type === REACT_FRAGMENT_TYPE) {
                        var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                        created.return = returnFiber;
                        return created;
                    } else {
                        var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                        _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                        _created4.return = returnFiber;
                        return _created4;
                    }
                }
                function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
                    var key = portal.key;
                    var child = currentFirstChild;
                    while(child !== null){
                        // TODO: If key === null and child.key === null, then this only applies to
                        // the first item in the list.
                        if (child.key === key) {
                            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var existing = useFiber(child, portal.children || []);
                                existing.return = returnFiber;
                                return existing;
                            } else {
                                deleteRemainingChildren(returnFiber, child);
                                break;
                            }
                        } else {
                            deleteChild(returnFiber, child);
                        }
                        child = child.sibling;
                    }
                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    return created;
                } // This API will tag the children with the side-effect of the reconciliation
                // itself. They will be added to the side-effect list as we pass through the
                // children and the parent.
                function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
                    // This function is not recursive.
                    // If the top level item is an array, we treat it as a set of children,
                    // not as a fragment. Nested arrays on the other hand will be treated as
                    // fragment nodes. Recursion happens at the normal flow.
                    // Handle top level unkeyed fragments as if they were arrays.
                    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
                    // We treat the ambiguous cases above the same.
                    var isUnkeyedTopLevelFragment = (typeof newChild === "undefined" ? "undefined" : _type_of(newChild)) === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
                    if (isUnkeyedTopLevelFragment) {
                        newChild = newChild.props.children;
                    } // Handle object types
                    if ((typeof newChild === "undefined" ? "undefined" : _type_of(newChild)) === 'object' && newChild !== null) {
                        switch(newChild.$$typeof){
                            case REACT_ELEMENT_TYPE:
                                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                            case REACT_PORTAL_TYPE:
                                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                            case REACT_LAZY_TYPE:
                                var payload = newChild._payload;
                                var init = newChild._init; // TODO: This function is supposed to be non-recursive.
                                return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);
                        }
                        if (isArray(newChild)) {
                            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                        }
                        if (getIteratorFn(newChild)) {
                            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                        }
                        throwOnInvalidObjectType(returnFiber, newChild);
                    }
                    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                        return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
                    }
                    {
                        if (typeof newChild === 'function') {
                            warnOnFunctionType(returnFiber);
                        }
                    }
                    return deleteRemainingChildren(returnFiber, currentFirstChild);
                }
                return reconcileChildFibers;
            }
            var reconcileChildFibers = ChildReconciler(true);
            var mountChildFibers = ChildReconciler(false);
            function cloneChildFibers(current, workInProgress) {
                if (current !== null && workInProgress.child !== current.child) {
                    throw new Error('Resuming work not yet implemented.');
                }
                if (workInProgress.child === null) {
                    return;
                }
                var currentChild = workInProgress.child;
                var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
                workInProgress.child = newChild;
                newChild.return = workInProgress;
                while(currentChild.sibling !== null){
                    currentChild = currentChild.sibling;
                    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
                    newChild.return = workInProgress;
                }
                newChild.sibling = null;
            } // Reset a workInProgress child set to prepare it for a second pass.
            function resetChildFibers(workInProgress, lanes) {
                var child = workInProgress.child;
                while(child !== null){
                    resetWorkInProgress(child, lanes);
                    child = child.sibling;
                }
            }
            var valueCursor = createCursor(null);
            var rendererSigil;
            {
                // Use this to detect multiple renderers using the same context
                rendererSigil = {};
            }
            var currentlyRenderingFiber = null;
            var lastContextDependency = null;
            var lastFullyObservedContext = null;
            var isDisallowedContextReadInDEV = false;
            function resetContextDependencies() {
                // This is called right before React yields execution, to ensure `readContext`
                // cannot be called outside the render phase.
                currentlyRenderingFiber = null;
                lastContextDependency = null;
                lastFullyObservedContext = null;
                {
                    isDisallowedContextReadInDEV = false;
                }
            }
            function enterDisallowedContextReadInDEV() {
                {
                    isDisallowedContextReadInDEV = true;
                }
            }
            function exitDisallowedContextReadInDEV() {
                {
                    isDisallowedContextReadInDEV = false;
                }
            }
            function pushProvider(providerFiber, context, nextValue) {
                if (isPrimaryRenderer) {
                    push(valueCursor, context._currentValue, providerFiber);
                    context._currentValue = nextValue;
                    {
                        if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                            error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
                        }
                        context._currentRenderer = rendererSigil;
                    }
                } else {
                    push(valueCursor, context._currentValue2, providerFiber);
                    context._currentValue2 = nextValue;
                    {
                        if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                            error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
                        }
                        context._currentRenderer2 = rendererSigil;
                    }
                }
            }
            function popProvider(context, providerFiber) {
                var currentValue = valueCursor.current;
                pop(valueCursor, providerFiber);
                if (isPrimaryRenderer) {
                    {
                        context._currentValue = currentValue;
                    }
                } else {
                    {
                        context._currentValue2 = currentValue;
                    }
                }
            }
            function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
                // Update the child lanes of all the ancestors, including the alternates.
                var node = parent;
                while(node !== null){
                    var alternate = node.alternate;
                    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
                        node.childLanes = mergeLanes(node.childLanes, renderLanes);
                        if (alternate !== null) {
                            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
                        }
                    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {
                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
                    }
                    if (node === propagationRoot) {
                        break;
                    }
                    node = node.return;
                }
                {
                    if (node !== propagationRoot) {
                        error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    }
                }
            }
            function propagateContextChange(workInProgress, context, renderLanes) {
                {
                    propagateContextChange_eager(workInProgress, context, renderLanes);
                }
            }
            function propagateContextChange_eager(workInProgress, context, renderLanes) {
                var fiber = workInProgress.child;
                if (fiber !== null) {
                    // Set the return pointer of the child to the work-in-progress fiber.
                    fiber.return = workInProgress;
                }
                while(fiber !== null){
                    var nextFiber = void 0; // Visit this fiber.
                    var list = fiber.dependencies;
                    if (list !== null) {
                        nextFiber = fiber.child;
                        var dependency = list.firstContext;
                        while(dependency !== null){
                            // Check if the context matches.
                            if (dependency.context === context) {
                                // Match! Schedule an update on this fiber.
                                if (fiber.tag === ClassComponent) {
                                    // Schedule a force update on the work-in-progress.
                                    var lane = pickArbitraryLane(renderLanes);
                                    var update = createUpdate(NoTimestamp, lane);
                                    update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
                                    // update to the current fiber, too, which means it will persist even if
                                    // this render is thrown away. Since it's a race condition, not sure it's
                                    // worth fixing.
                                    // Inlined `enqueueUpdate` to remove interleaved update check
                                    var updateQueue = fiber.updateQueue;
                                    if (updateQueue === null) ;
                                    else {
                                        var sharedQueue = updateQueue.shared;
                                        var pending = sharedQueue.pending;
                                        if (pending === null) {
                                            // This is the first update. Create a circular list.
                                            update.next = update;
                                        } else {
                                            update.next = pending.next;
                                            pending.next = update;
                                        }
                                        sharedQueue.pending = update;
                                    }
                                }
                                fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                                var alternate = fiber.alternate;
                                if (alternate !== null) {
                                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                                }
                                scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.
                                list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
                                break;
                            }
                            dependency = dependency.next;
                        }
                    } else if (fiber.tag === ContextProvider) {
                        // Don't scan deeper if this is a matching provider
                        nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
                    } else if (fiber.tag === DehydratedFragment) {
                        // If a dehydrated suspense boundary is in this subtree, we don't know
                        // if it will have any context consumers in it. The best we can do is
                        // mark it as having updates.
                        var parentSuspense = fiber.return;
                        if (parentSuspense === null) {
                            throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');
                        }
                        parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);
                        var _alternate = parentSuspense.alternate;
                        if (_alternate !== null) {
                            _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);
                        } // This is intentionally passing this fiber as the parent
                        // because we want to schedule this fiber as having work
                        // on its children. We'll use the childLanes on
                        // this fiber to indicate that a context has changed.
                        scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);
                        nextFiber = fiber.sibling;
                    } else {
                        // Traverse down.
                        nextFiber = fiber.child;
                    }
                    if (nextFiber !== null) {
                        // Set the return pointer of the child to the work-in-progress fiber.
                        nextFiber.return = fiber;
                    } else {
                        // No child. Traverse to next sibling.
                        nextFiber = fiber;
                        while(nextFiber !== null){
                            if (nextFiber === workInProgress) {
                                // We're back to the root of this subtree. Exit.
                                nextFiber = null;
                                break;
                            }
                            var sibling = nextFiber.sibling;
                            if (sibling !== null) {
                                // Set the return pointer of the sibling to the work-in-progress fiber.
                                sibling.return = nextFiber.return;
                                nextFiber = sibling;
                                break;
                            } // No more siblings. Traverse up.
                            nextFiber = nextFiber.return;
                        }
                    }
                    fiber = nextFiber;
                }
            }
            function prepareToReadContext(workInProgress, renderLanes) {
                currentlyRenderingFiber = workInProgress;
                lastContextDependency = null;
                lastFullyObservedContext = null;
                var dependencies = workInProgress.dependencies;
                if (dependencies !== null) {
                    {
                        var firstContext = dependencies.firstContext;
                        if (firstContext !== null) {
                            if (includesSomeLane(dependencies.lanes, renderLanes)) {
                                // Context list has a pending update. Mark that this fiber performed work.
                                markWorkInProgressReceivedUpdate();
                            } // Reset the work-in-progress list
                            dependencies.firstContext = null;
                        }
                    }
                }
            }
            function readContext(context) {
                {
                    // This warning would fire if you read context inside a Hook like useMemo.
                    // Unlike the class check below, it's not enforced in production for perf.
                    if (isDisallowedContextReadInDEV) {
                        error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                    }
                }
                var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
                if (lastFullyObservedContext === context) ;
                else {
                    var contextItem = {
                        context: context,
                        memoizedValue: value,
                        next: null
                    };
                    if (lastContextDependency === null) {
                        if (currentlyRenderingFiber === null) {
                            throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                        } // This is the first dependency for this component. Create a new list.
                        lastContextDependency = contextItem;
                        currentlyRenderingFiber.dependencies = {
                            lanes: NoLanes,
                            firstContext: contextItem
                        };
                    } else {
                        // Append a new context item.
                        lastContextDependency = lastContextDependency.next = contextItem;
                    }
                }
                return value;
            }
            // render. When this render exits, either because it finishes or because it is
            // interrupted, the interleaved updates will be transferred onto the main part
            // of the queue.
            var concurrentQueues = null;
            function pushConcurrentUpdateQueue(queue) {
                if (concurrentQueues === null) {
                    concurrentQueues = [
                        queue
                    ];
                } else {
                    concurrentQueues.push(queue);
                }
            }
            function finishQueueingConcurrentUpdates() {
                // Transfer the interleaved updates onto the main queue. Each queue has a
                // `pending` field and an `interleaved` field. When they are not null, they
                // point to the last node in a circular linked list. We need to append the
                // interleaved list to the end of the pending list by joining them into a
                // single, circular list.
                if (concurrentQueues !== null) {
                    for(var i = 0; i < concurrentQueues.length; i++){
                        var queue = concurrentQueues[i];
                        var lastInterleavedUpdate = queue.interleaved;
                        if (lastInterleavedUpdate !== null) {
                            queue.interleaved = null;
                            var firstInterleavedUpdate = lastInterleavedUpdate.next;
                            var lastPendingUpdate = queue.pending;
                            if (lastPendingUpdate !== null) {
                                var firstPendingUpdate = lastPendingUpdate.next;
                                lastPendingUpdate.next = firstInterleavedUpdate;
                                lastInterleavedUpdate.next = firstPendingUpdate;
                            }
                            queue.pending = lastInterleavedUpdate;
                        }
                    }
                    concurrentQueues = null;
                }
            }
            function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
                var interleaved = queue.interleaved;
                if (interleaved === null) {
                    // This is the first update. Create a circular list.
                    update.next = update; // At the end of the current render, this queue's interleaved updates will
                    // be transferred to the pending queue.
                    pushConcurrentUpdateQueue(queue);
                } else {
                    update.next = interleaved.next;
                    interleaved.next = update;
                }
                queue.interleaved = update;
                return markUpdateLaneFromFiberToRoot(fiber, lane);
            }
            function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
                var interleaved = queue.interleaved;
                if (interleaved === null) {
                    // This is the first update. Create a circular list.
                    update.next = update; // At the end of the current render, this queue's interleaved updates will
                    // be transferred to the pending queue.
                    pushConcurrentUpdateQueue(queue);
                } else {
                    update.next = interleaved.next;
                    interleaved.next = update;
                }
                queue.interleaved = update;
            }
            function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
                var interleaved = queue.interleaved;
                if (interleaved === null) {
                    // This is the first update. Create a circular list.
                    update.next = update; // At the end of the current render, this queue's interleaved updates will
                    // be transferred to the pending queue.
                    pushConcurrentUpdateQueue(queue);
                } else {
                    update.next = interleaved.next;
                    interleaved.next = update;
                }
                queue.interleaved = update;
                return markUpdateLaneFromFiberToRoot(fiber, lane);
            }
            function enqueueConcurrentRenderForLane(fiber, lane) {
                return markUpdateLaneFromFiberToRoot(fiber, lane);
            } // Calling this function outside this module should only be done for backwards
            // compatibility and should always be accompanied by a warning.
            var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
            function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
                // Update the source fiber's lanes
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
                var alternate = sourceFiber.alternate;
                if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, lane);
                }
                {
                    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                        warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                    }
                }
                var node = sourceFiber;
                var parent = sourceFiber.return;
                while(parent !== null){
                    parent.childLanes = mergeLanes(parent.childLanes, lane);
                    alternate = parent.alternate;
                    if (alternate !== null) {
                        alternate.childLanes = mergeLanes(alternate.childLanes, lane);
                    } else {
                        {
                            if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                            }
                        }
                    }
                    node = parent;
                    parent = parent.return;
                }
                if (node.tag === HostRoot) {
                    var root = node.stateNode;
                    return root;
                } else {
                    return null;
                }
            }
            var UpdateState = 0;
            var ReplaceState = 1;
            var ForceUpdate = 2;
            var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
            // It should only be read right after calling `processUpdateQueue`, via
            // `checkHasForceUpdateAfterProcessing`.
            var hasForceUpdate = false;
            var didWarnUpdateInsideUpdate;
            var currentlyProcessingQueue;
            {
                didWarnUpdateInsideUpdate = false;
                currentlyProcessingQueue = null;
            }
            function initializeUpdateQueue(fiber) {
                var queue = {
                    baseState: fiber.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        interleaved: null,
                        lanes: NoLanes
                    },
                    effects: null
                };
                fiber.updateQueue = queue;
            }
            function cloneUpdateQueue(current, workInProgress) {
                // Clone the update queue from current. Unless it's already a clone.
                var queue = workInProgress.updateQueue;
                var currentQueue = current.updateQueue;
                if (queue === currentQueue) {
                    var clone = {
                        baseState: currentQueue.baseState,
                        firstBaseUpdate: currentQueue.firstBaseUpdate,
                        lastBaseUpdate: currentQueue.lastBaseUpdate,
                        shared: currentQueue.shared,
                        effects: currentQueue.effects
                    };
                    workInProgress.updateQueue = clone;
                }
            }
            function createUpdate(eventTime, lane) {
                var update = {
                    eventTime: eventTime,
                    lane: lane,
                    tag: UpdateState,
                    payload: null,
                    callback: null,
                    next: null
                };
                return update;
            }
            function enqueueUpdate(fiber, update, lane) {
                var updateQueue = fiber.updateQueue;
                if (updateQueue === null) {
                    // Only occurs if the fiber has been unmounted.
                    return null;
                }
                var sharedQueue = updateQueue.shared;
                {
                    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                        error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
                        didWarnUpdateInsideUpdate = true;
                    }
                }
                if (isUnsafeClassRenderPhaseUpdate()) {
                    // This is an unsafe render phase update. Add directly to the update
                    // queue so we can process it immediately during the current render.
                    var pending = sharedQueue.pending;
                    if (pending === null) {
                        // This is the first update. Create a circular list.
                        update.next = update;
                    } else {
                        update.next = pending.next;
                        pending.next = update;
                    }
                    sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering
                    // this fiber. This is for backwards compatibility in the case where you
                    // update a different component during render phase than the one that is
                    // currently renderings (a pattern that is accompanied by a warning).
                    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
                } else {
                    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
                }
            }
            function entangleTransitions(root, fiber, lane) {
                var updateQueue = fiber.updateQueue;
                if (updateQueue === null) {
                    // Only occurs if the fiber has been unmounted.
                    return;
                }
                var sharedQueue = updateQueue.shared;
                if (isTransitionLane(lane)) {
                    var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must
                    // have finished. We can remove them from the shared queue, which represents
                    // a superset of the actually pending lanes. In some cases we may entangle
                    // more than we need to, but that's OK. In fact it's worse if we *don't*
                    // entangle when we should.
                    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.
                    var newQueueLanes = mergeLanes(queueLanes, lane);
                    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if
                    // the lane finished since the last time we entangled it. So we need to
                    // entangle it again, just to be sure.
                    markRootEntangled(root, newQueueLanes);
                }
            }
            function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
                // Captured updates are updates that are thrown by a child during the render
                // phase. They should be discarded if the render is aborted. Therefore,
                // we should only put them on the work-in-progress queue, not the current one.
                var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.
                var current = workInProgress.alternate;
                if (current !== null) {
                    var currentQueue = current.updateQueue;
                    if (queue === currentQueue) {
                        // The work-in-progress queue is the same as current. This happens when
                        // we bail out on a parent fiber that then captures an error thrown by
                        // a child. Since we want to append the update only to the work-in
                        // -progress queue, we need to clone the updates. We usually clone during
                        // processUpdateQueue, but that didn't happen in this case because we
                        // skipped over the parent when we bailed out.
                        var newFirst = null;
                        var newLast = null;
                        var firstBaseUpdate = queue.firstBaseUpdate;
                        if (firstBaseUpdate !== null) {
                            // Loop through the updates and clone them.
                            var update = firstBaseUpdate;
                            do {
                                var clone = {
                                    eventTime: update.eventTime,
                                    lane: update.lane,
                                    tag: update.tag,
                                    payload: update.payload,
                                    callback: update.callback,
                                    next: null
                                };
                                if (newLast === null) {
                                    newFirst = newLast = clone;
                                } else {
                                    newLast.next = clone;
                                    newLast = clone;
                                }
                                update = update.next;
                            }while (update !== null); // Append the captured update the end of the cloned list.
                            if (newLast === null) {
                                newFirst = newLast = capturedUpdate;
                            } else {
                                newLast.next = capturedUpdate;
                                newLast = capturedUpdate;
                            }
                        } else {
                            // There are no base updates.
                            newFirst = newLast = capturedUpdate;
                        }
                        queue = {
                            baseState: currentQueue.baseState,
                            firstBaseUpdate: newFirst,
                            lastBaseUpdate: newLast,
                            shared: currentQueue.shared,
                            effects: currentQueue.effects
                        };
                        workInProgress.updateQueue = queue;
                        return;
                    }
                } // Append the update to the end of the list.
                var lastBaseUpdate = queue.lastBaseUpdate;
                if (lastBaseUpdate === null) {
                    queue.firstBaseUpdate = capturedUpdate;
                } else {
                    lastBaseUpdate.next = capturedUpdate;
                }
                queue.lastBaseUpdate = capturedUpdate;
            }
            function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
                switch(update.tag){
                    case ReplaceState:
                        {
                            var payload = update.payload;
                            if (typeof payload === 'function') {
                                // Updater function
                                {
                                    enterDisallowedContextReadInDEV();
                                }
                                var nextState = payload.call(instance, prevState, nextProps);
                                {
                                    if (workInProgress.mode & StrictLegacyMode) {
                                        setIsStrictModeForDevtools(true);
                                        try {
                                            payload.call(instance, prevState, nextProps);
                                        } finally{
                                            setIsStrictModeForDevtools(false);
                                        }
                                    }
                                    exitDisallowedContextReadInDEV();
                                }
                                return nextState;
                            } // State object
                            return payload;
                        }
                    case CaptureUpdate:
                        {
                            workInProgress.flags = workInProgress.flags & -65537 | DidCapture;
                        }
                    // Intentional fallthrough
                    case UpdateState:
                        {
                            var _payload = update.payload;
                            var partialState;
                            if (typeof _payload === 'function') {
                                // Updater function
                                {
                                    enterDisallowedContextReadInDEV();
                                }
                                partialState = _payload.call(instance, prevState, nextProps);
                                {
                                    if (workInProgress.mode & StrictLegacyMode) {
                                        setIsStrictModeForDevtools(true);
                                        try {
                                            _payload.call(instance, prevState, nextProps);
                                        } finally{
                                            setIsStrictModeForDevtools(false);
                                        }
                                    }
                                    exitDisallowedContextReadInDEV();
                                }
                            } else {
                                // Partial state object
                                partialState = _payload;
                            }
                            if (partialState === null || partialState === undefined) {
                                // Null and undefined are treated as no-ops.
                                return prevState;
                            } // Merge the partial state and the previous state.
                            return assign({}, prevState, partialState);
                        }
                    case ForceUpdate:
                        {
                            hasForceUpdate = true;
                            return prevState;
                        }
                }
                return prevState;
            }
            function processUpdateQueue(workInProgress, props, instance, renderLanes) {
                // This is always non-null on a ClassComponent or HostRoot
                var queue = workInProgress.updateQueue;
                hasForceUpdate = false;
                {
                    currentlyProcessingQueue = queue.shared;
                }
                var firstBaseUpdate = queue.firstBaseUpdate;
                var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.
                var pendingQueue = queue.shared.pending;
                if (pendingQueue !== null) {
                    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
                    // and last so that it's non-circular.
                    var lastPendingUpdate = pendingQueue;
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = null; // Append pending updates to base queue
                    if (lastBaseUpdate === null) {
                        firstBaseUpdate = firstPendingUpdate;
                    } else {
                        lastBaseUpdate.next = firstPendingUpdate;
                    }
                    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
                    // we need to transfer the updates to that queue, too. Because the base
                    // queue is a singly-linked list with no cycles, we can append to both
                    // lists and take advantage of structural sharing.
                    // TODO: Pass `current` as argument
                    var current = workInProgress.alternate;
                    if (current !== null) {
                        // This is always non-null on a ClassComponent or HostRoot
                        var currentQueue = current.updateQueue;
                        var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                        if (currentLastBaseUpdate !== lastBaseUpdate) {
                            if (currentLastBaseUpdate === null) {
                                currentQueue.firstBaseUpdate = firstPendingUpdate;
                            } else {
                                currentLastBaseUpdate.next = firstPendingUpdate;
                            }
                            currentQueue.lastBaseUpdate = lastPendingUpdate;
                        }
                    }
                } // These values may change as we process the queue.
                if (firstBaseUpdate !== null) {
                    // Iterate through the list of updates to compute the result.
                    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
                    // from the original lanes.
                    var newLanes = NoLanes;
                    var newBaseState = null;
                    var newFirstBaseUpdate = null;
                    var newLastBaseUpdate = null;
                    var update = firstBaseUpdate;
                    do {
                        var updateLane = update.lane;
                        var updateEventTime = update.eventTime;
                        if (!isSubsetOfLanes(renderLanes, updateLane)) {
                            // Priority is insufficient. Skip this update. If this is the first
                            // skipped update, the previous update/state is the new base
                            // update/state.
                            var clone = {
                                eventTime: updateEventTime,
                                lane: updateLane,
                                tag: update.tag,
                                payload: update.payload,
                                callback: update.callback,
                                next: null
                            };
                            if (newLastBaseUpdate === null) {
                                newFirstBaseUpdate = newLastBaseUpdate = clone;
                                newBaseState = newState;
                            } else {
                                newLastBaseUpdate = newLastBaseUpdate.next = clone;
                            } // Update the remaining priority in the queue.
                            newLanes = mergeLanes(newLanes, updateLane);
                        } else {
                            // This update does have sufficient priority.
                            if (newLastBaseUpdate !== null) {
                                var _clone = {
                                    eventTime: updateEventTime,
                                    // This update is going to be committed so we never want uncommit
                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                                    // this will never be skipped by the check above.
                                    lane: NoLane,
                                    tag: update.tag,
                                    payload: update.payload,
                                    callback: update.callback,
                                    next: null
                                };
                                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                            } // Process this update.
                            newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
                            var callback = update.callback;
                            if (callback !== null && // If the update was already committed, we should not queue its
                            // callback again.
                            update.lane !== NoLane) {
                                workInProgress.flags |= Callback;
                                var effects = queue.effects;
                                if (effects === null) {
                                    queue.effects = [
                                        update
                                    ];
                                } else {
                                    effects.push(update);
                                }
                            }
                        }
                        update = update.next;
                        if (update === null) {
                            pendingQueue = queue.shared.pending;
                            if (pendingQueue === null) {
                                break;
                            } else {
                                // An update was scheduled from inside a reducer. Add the new
                                // pending updates to the end of the list and keep processing.
                                var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
                                // unravel them when transferring them to the base queue.
                                var _firstPendingUpdate = _lastPendingUpdate.next;
                                _lastPendingUpdate.next = null;
                                update = _firstPendingUpdate;
                                queue.lastBaseUpdate = _lastPendingUpdate;
                                queue.shared.pending = null;
                            }
                        }
                    }while (true);
                    if (newLastBaseUpdate === null) {
                        newBaseState = newState;
                    }
                    queue.baseState = newBaseState;
                    queue.firstBaseUpdate = newFirstBaseUpdate;
                    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to
                    // process them during this render, but we do need to track which lanes
                    // are remaining.
                    var lastInterleaved = queue.shared.interleaved;
                    if (lastInterleaved !== null) {
                        var interleaved = lastInterleaved;
                        do {
                            newLanes = mergeLanes(newLanes, interleaved.lane);
                            interleaved = interleaved.next;
                        }while (interleaved !== lastInterleaved);
                    } else if (firstBaseUpdate === null) {
                        // `queue.lanes` is used for entangling transitions. We can set it back to
                        // zero once the queue is empty.
                        queue.shared.lanes = NoLanes;
                    } // Set the remaining expiration time to be whatever is remaining in the queue.
                    // This should be fine because the only two other things that contribute to
                    // expiration time are props and context. We're already in the middle of the
                    // begin phase by the time we start processing the queue, so we've already
                    // dealt with the props. Context in components that specify
                    // shouldComponentUpdate is tricky; but we'll have to account for
                    // that regardless.
                    markSkippedUpdateLanes(newLanes);
                    workInProgress.lanes = newLanes;
                    workInProgress.memoizedState = newState;
                }
                {
                    currentlyProcessingQueue = null;
                }
            }
            function callCallback(callback, context) {
                if (typeof callback !== 'function') {
                    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + ("received: " + callback));
                }
                callback.call(context);
            }
            function resetHasForceUpdateBeforeProcessing() {
                hasForceUpdate = false;
            }
            function checkHasForceUpdateAfterProcessing() {
                return hasForceUpdate;
            }
            function commitUpdateQueue(finishedWork, finishedQueue, instance) {
                // Commit the effects
                var effects = finishedQueue.effects;
                finishedQueue.effects = null;
                if (effects !== null) {
                    for(var i = 0; i < effects.length; i++){
                        var effect = effects[i];
                        var callback = effect.callback;
                        if (callback !== null) {
                            effect.callback = null;
                            callCallback(callback, instance);
                        }
                    }
                }
            }
            var NO_CONTEXT = {};
            var contextStackCursor$1 = createCursor(NO_CONTEXT);
            var contextFiberStackCursor = createCursor(NO_CONTEXT);
            var rootInstanceStackCursor = createCursor(NO_CONTEXT);
            function requiredContext(c) {
                if (c === NO_CONTEXT) {
                    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');
                }
                return c;
            }
            function getRootHostContainer() {
                var rootInstance = requiredContext(rootInstanceStackCursor.current);
                return rootInstance;
            }
            function pushHostContainer(fiber, nextRootInstance) {
                // Push current root instance onto the stack;
                // This allows us to reset root when portals are popped.
                push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
                // This enables us to pop only Fibers that provide unique contexts.
                push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
                // However, we can't just call getRootHostContext() and push it because
                // we'd have a different number of entries on the stack depending on
                // whether getRootHostContext() throws somewhere in renderer code or not.
                // So we push an empty value first. This lets us safely unwind on errors.
                push(contextStackCursor$1, NO_CONTEXT, fiber);
                var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.
                pop(contextStackCursor$1, fiber);
                push(contextStackCursor$1, nextRootContext, fiber);
            }
            function popHostContainer(fiber) {
                pop(contextStackCursor$1, fiber);
                pop(contextFiberStackCursor, fiber);
                pop(rootInstanceStackCursor, fiber);
            }
            function getHostContext() {
                var context = requiredContext(contextStackCursor$1.current);
                return context;
            }
            function pushHostContext(fiber) {
                var rootInstance = requiredContext(rootInstanceStackCursor.current);
                var context = requiredContext(contextStackCursor$1.current);
                var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.
                if (context === nextContext) {
                    return;
                } // Track the context and the Fiber that provided it.
                // This enables us to pop only Fibers that provide unique contexts.
                push(contextFiberStackCursor, fiber, fiber);
                push(contextStackCursor$1, nextContext, fiber);
            }
            function popHostContext(fiber) {
                // Do not pop unless this Fiber provided the current context.
                // pushHostContext() only pushes Fibers that provide unique contexts.
                if (contextFiberStackCursor.current !== fiber) {
                    return;
                }
                pop(contextStackCursor$1, fiber);
                pop(contextFiberStackCursor, fiber);
            }
            var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
            // inherited deeply down the subtree. The upper bits only affect
            // this immediate suspense boundary and gets reset each new
            // boundary or suspense list.
            var SubtreeSuspenseContextMask = 1; // Subtree Flags:
            // InvisibleParentSuspenseContext indicates that one of our parent Suspense
            // boundaries is not currently showing visible main content.
            // Either because it is already showing a fallback or is not mounted at all.
            // We can use this to determine if it is desirable to trigger a fallback at
            // the parent. If not, then we might need to trigger undesirable boundaries
            // and/or suspend the commit to avoid hiding the parent content.
            var InvisibleParentSuspenseContext = 1; // Shallow Flags:
            // ForceSuspenseFallback can be used by SuspenseList to force newly added
            // items into their fallback state during one of the render passes.
            var ForceSuspenseFallback = 2;
            var suspenseStackCursor = createCursor(DefaultSuspenseContext);
            function hasSuspenseContext(parentContext, flag) {
                return (parentContext & flag) !== 0;
            }
            function setDefaultShallowSuspenseContext(parentContext) {
                return parentContext & SubtreeSuspenseContextMask;
            }
            function setShallowSuspenseContext(parentContext, shallowContext) {
                return parentContext & SubtreeSuspenseContextMask | shallowContext;
            }
            function addSubtreeSuspenseContext(parentContext, subtreeContext) {
                return parentContext | subtreeContext;
            }
            function pushSuspenseContext(fiber, newContext) {
                push(suspenseStackCursor, newContext, fiber);
            }
            function popSuspenseContext(fiber) {
                pop(suspenseStackCursor, fiber);
            }
            function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
                // If it was the primary children that just suspended, capture and render the
                // fallback. Otherwise, don't capture and bubble to the next boundary.
                var nextState = workInProgress.memoizedState;
                if (nextState !== null) {
                    if (nextState.dehydrated !== null) {
                        // A dehydrated boundary always captures.
                        return true;
                    }
                    return false;
                }
                workInProgress.memoizedProps; // Regular boundaries always capture.
                {
                    return true;
                }
            }
            function findFirstSuspended(row) {
                var node = row;
                while(node !== null){
                    if (node.tag === SuspenseComponent) {
                        var state = node.memoizedState;
                        if (state !== null) {
                            var dehydrated = state.dehydrated;
                            if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                                return node;
                            }
                        }
                    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
                    // keep track of whether it suspended or not.
                    node.memoizedProps.revealOrder !== undefined) {
                        var didSuspend = (node.flags & DidCapture) !== NoFlags;
                        if (didSuspend) {
                            return node;
                        }
                    } else if (node.child !== null) {
                        node.child.return = node;
                        node = node.child;
                        continue;
                    }
                    if (node === row) {
                        return null;
                    }
                    while(node.sibling === null){
                        if (node.return === null || node.return === row) {
                            return null;
                        }
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                }
                return null;
            }
            var NoFlags$1 = /*   */ 0; // Represents whether effect should fire.
            var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.
            var Insertion = /*  */ 2;
            var Layout = /*    */ 4;
            var Passive$1 = /*   */ 8;
            // and should be reset before starting a new render.
            // This tracks which mutable sources need to be reset after a render.
            var workInProgressSources = [];
            function resetWorkInProgressVersions() {
                for(var i = 0; i < workInProgressSources.length; i++){
                    var mutableSource = workInProgressSources[i];
                    if (isPrimaryRenderer) {
                        mutableSource._workInProgressVersionPrimary = null;
                    } else {
                        mutableSource._workInProgressVersionSecondary = null;
                    }
                }
                workInProgressSources.length = 0;
            }
            // This ensures that the version used for server rendering matches the one
            // that is eventually read during hydration.
            // If they don't match there's a potential tear and a full deopt render is required.
            function registerMutableSourceForHydration(root, mutableSource) {
                var getVersion = mutableSource._getVersion;
                var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
                // Retaining it forever may interfere with GC.
                if (root.mutableSourceEagerHydrationData == null) {
                    root.mutableSourceEagerHydrationData = [
                        mutableSource,
                        version
                    ];
                } else {
                    root.mutableSourceEagerHydrationData.push(mutableSource, version);
                }
            }
            var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
            var didWarnAboutMismatchedHooksForComponent;
            var didWarnUncachedGetSnapshot;
            {
                didWarnAboutMismatchedHooksForComponent = new Set();
            }
            // These are set right before calling the component.
            var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
            // the work-in-progress hook.
            var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
            // current hook list is the list that belongs to the current fiber. The
            // work-in-progress hook list is a new list that will be added to the
            // work-in-progress fiber.
            var currentHook = null;
            var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
            // does not get reset if we do another render pass; only when we're completely
            // finished evaluating this component. This is an optimization so we know
            // whether we need to clear render phase updates after a throw.
            var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
            // gets reset after each attempt.
            // TODO: Maybe there's some way to consolidate this with
            // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
            var didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.
            var localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during
            // hydration). This counter is global, so client ids are not stable across
            // render attempts.
            var globalClientIdCounter = 0;
            var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook
            var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
            // The list stores the order of hooks used during the initial render (mount).
            // Subsequent renders (updates) reference this list.
            var hookTypesDev = null;
            var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
            // the dependencies for Hooks that need them (e.g. useEffect or useMemo).
            // When true, such Hooks will always be "remounted". Only used during hot reload.
            var ignorePreviousDependencies = false;
            function mountHookTypesDev() {
                {
                    var hookName = currentHookNameInDev;
                    if (hookTypesDev === null) {
                        hookTypesDev = [
                            hookName
                        ];
                    } else {
                        hookTypesDev.push(hookName);
                    }
                }
            }
            function updateHookTypesDev() {
                {
                    var hookName = currentHookNameInDev;
                    if (hookTypesDev !== null) {
                        hookTypesUpdateIndexDev++;
                        if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                            warnOnHookMismatchInDev(hookName);
                        }
                    }
                }
            }
            function checkDepsAreArrayDev(deps) {
                {
                    if (deps !== undefined && deps !== null && !isArray(deps)) {
                        // Verify deps, but only on mount to avoid extra checks.
                        // It's unlikely their type would change as usually you define them inline.
                        error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps === "undefined" ? "undefined" : _type_of(deps));
                    }
                }
            }
            function warnOnHookMismatchInDev(currentHookName) {
                {
                    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
                    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                        didWarnAboutMismatchedHooksForComponent.add(componentName);
                        if (hookTypesDev !== null) {
                            var table = '';
                            var secondColumnStart = 30;
                            for(var i = 0; i <= hookTypesUpdateIndexDev; i++){
                                var oldHookName = hookTypesDev[i];
                                var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                                var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
                                // lol @ IE not supporting String#repeat
                                while(row.length < secondColumnStart){
                                    row += ' ';
                                }
                                row += newHookName + '\n';
                                table += row;
                            }
                            error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
                        }
                    }
                }
            }
            function throwInvalidHookError() {
                throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
            }
            function areHookInputsEqual(nextDeps, prevDeps) {
                {
                    if (ignorePreviousDependencies) {
                        // Only true when this component is being hot reloaded.
                        return false;
                    }
                }
                if (prevDeps === null) {
                    {
                        error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
                    }
                    return false;
                }
                {
                    // Don't bother comparing lengths in prod because these arrays should be
                    // passed inline.
                    if (nextDeps.length !== prevDeps.length) {
                        error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
                    }
                }
                for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
                    if (objectIs(nextDeps[i], prevDeps[i])) {
                        continue;
                    }
                    return false;
                }
                return true;
            }
            function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
                renderLanes = nextRenderLanes;
                currentlyRenderingFiber$1 = workInProgress;
                {
                    hookTypesDev = current !== null ? current._debugHookTypes : null;
                    hookTypesUpdateIndexDev = -1; // Used for hot reloading:
                    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
                }
                workInProgress.memoizedState = null;
                workInProgress.updateQueue = null;
                workInProgress.lanes = NoLanes; // The following should have already been reset
                // currentHook = null;
                // workInProgressHook = null;
                // didScheduleRenderPhaseUpdate = false;
                // localIdCounter = 0;
                // TODO Warn if no hooks are used at all during mount, then some are used during update.
                // Currently we will identify the update render as a mount because memoizedState === null.
                // This is tricky because it's valid for certain types of components (e.g. React.lazy)
                // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
                // Non-stateful hooks (e.g. context) don't get added to memoizedState,
                // so memoizedState would be null during updates and mounts.
                {
                    if (current !== null && current.memoizedState !== null) {
                        ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
                    } else if (hookTypesDev !== null) {
                        // This dispatcher handles an edge case where a component is updating,
                        // but no stateful hooks have been used.
                        // We want to match the production code behavior (which will use HooksDispatcherOnMount),
                        // but with the extra DEV validation to ensure hooks ordering hasn't changed.
                        // This dispatcher does that.
                        ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
                    } else {
                        ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
                    }
                }
                var children = Component(props, secondArg); // Check if there was a render phase update
                if (didScheduleRenderPhaseUpdateDuringThisPass) {
                    // Keep rendering in a loop for as long as render phase updates continue to
                    // be scheduled. Use a counter to prevent infinite loops.
                    var numberOfReRenders = 0;
                    do {
                        didScheduleRenderPhaseUpdateDuringThisPass = false;
                        localIdCounter = 0;
                        if (numberOfReRenders >= RE_RENDER_LIMIT) {
                            throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');
                        }
                        numberOfReRenders += 1;
                        {
                            // Even when hot reloading, allow dependencies to stabilize
                            // after first render to prevent infinite render phase updates.
                            ignorePreviousDependencies = false;
                        }
                        currentHook = null;
                        workInProgressHook = null;
                        workInProgress.updateQueue = null;
                        {
                            // Also validate hook order for cascading updates.
                            hookTypesUpdateIndexDev = -1;
                        }
                        ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                        children = Component(props, secondArg);
                    }while (didScheduleRenderPhaseUpdateDuringThisPass);
                } // We can assume the previous dispatcher is always this one, since we set it
                // at the beginning of the render phase and there's no re-entrance.
                ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
                {
                    workInProgress._debugHookTypes = hookTypesDev;
                }
                // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
                var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
                renderLanes = NoLanes;
                currentlyRenderingFiber$1 = null;
                currentHook = null;
                workInProgressHook = null;
                {
                    currentHookNameInDev = null;
                    hookTypesDev = null;
                    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last
                    // render. If this fires, it suggests that we incorrectly reset the static
                    // flags in some other part of the codebase. This has happened before, for
                    // example, in the SuspenseList implementation.
                    if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
                    // and creates false positives. To make this work in legacy mode, we'd
                    // need to mark fibers that commit in an incomplete state, somehow. For
                    // now I'll disable the warning that most of the bugs that would trigger
                    // it are either exclusive to concurrent mode or exist in both.
                    (current.mode & ConcurrentMode) !== NoMode) {
                        error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');
                    }
                }
                didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook
                // localIdCounter = 0;
                if (didRenderTooFewHooks) {
                    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');
                }
                return children;
            }
            function checkDidRenderIdHook() {
                // This should be called immediately after every renderWithHooks call.
                // Conceptually, it's part of the return value of renderWithHooks; it's only a
                // separate function to avoid using an array tuple.
                var didRenderIdHook = localIdCounter !== 0;
                localIdCounter = 0;
                return didRenderIdHook;
            }
            function bailoutHooks(current, workInProgress, lanes) {
                workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the
                // complete phase (bubbleProperties).
                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                    workInProgress.flags &= -50333701;
                } else {
                    workInProgress.flags &= -2053;
                }
                current.lanes = removeLanes(current.lanes, lanes);
            }
            function resetHooksAfterThrow() {
                // We can assume the previous dispatcher is always this one, since we set it
                // at the beginning of the render phase and there's no re-entrance.
                ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
                if (didScheduleRenderPhaseUpdate) {
                    // There were render phase updates. These are only valid for this render
                    // phase, which we are now aborting. Remove the updates from the queues so
                    // they do not persist to the next render. Do not remove updates from hooks
                    // that weren't processed.
                    //
                    // Only reset the updates from the queue if it has a clone. If it does
                    // not have a clone, that means it wasn't processed, and the updates were
                    // scheduled before we entered the render phase.
                    var hook = currentlyRenderingFiber$1.memoizedState;
                    while(hook !== null){
                        var queue = hook.queue;
                        if (queue !== null) {
                            queue.pending = null;
                        }
                        hook = hook.next;
                    }
                    didScheduleRenderPhaseUpdate = false;
                }
                renderLanes = NoLanes;
                currentlyRenderingFiber$1 = null;
                currentHook = null;
                workInProgressHook = null;
                {
                    hookTypesDev = null;
                    hookTypesUpdateIndexDev = -1;
                    currentHookNameInDev = null;
                    isUpdatingOpaqueValueInRenderPhase = false;
                }
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
            }
            function mountWorkInProgressHook() {
                var hook = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                if (workInProgressHook === null) {
                    // This is the first hook in the list
                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
                } else {
                    // Append to the end of the list
                    workInProgressHook = workInProgressHook.next = hook;
                }
                return workInProgressHook;
            }
            function updateWorkInProgressHook() {
                // This function is used both for updates and for re-renders triggered by a
                // render phase update. It assumes there is either a current hook we can
                // clone, or a work-in-progress hook from a previous render pass that we can
                // use as a base. When we reach the end of the base list, we must switch to
                // the dispatcher used for mounts.
                var nextCurrentHook;
                if (currentHook === null) {
                    var current = currentlyRenderingFiber$1.alternate;
                    if (current !== null) {
                        nextCurrentHook = current.memoizedState;
                    } else {
                        nextCurrentHook = null;
                    }
                } else {
                    nextCurrentHook = currentHook.next;
                }
                var nextWorkInProgressHook;
                if (workInProgressHook === null) {
                    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
                } else {
                    nextWorkInProgressHook = workInProgressHook.next;
                }
                if (nextWorkInProgressHook !== null) {
                    // There's already a work-in-progress. Reuse it.
                    workInProgressHook = nextWorkInProgressHook;
                    nextWorkInProgressHook = workInProgressHook.next;
                    currentHook = nextCurrentHook;
                } else {
                    // Clone from the current hook.
                    if (nextCurrentHook === null) {
                        throw new Error('Rendered more hooks than during the previous render.');
                    }
                    currentHook = nextCurrentHook;
                    var newHook = {
                        memoizedState: currentHook.memoizedState,
                        baseState: currentHook.baseState,
                        baseQueue: currentHook.baseQueue,
                        queue: currentHook.queue,
                        next: null
                    };
                    if (workInProgressHook === null) {
                        // This is the first hook in the list.
                        currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
                    } else {
                        // Append to the end of the list.
                        workInProgressHook = workInProgressHook.next = newHook;
                    }
                }
                return workInProgressHook;
            }
            function createFunctionComponentUpdateQueue() {
                return {
                    lastEffect: null,
                    stores: null
                };
            }
            function basicStateReducer(state, action) {
                // $FlowFixMe: Flow doesn't like mixed types
                return typeof action === 'function' ? action(state) : action;
            }
            function mountReducer(reducer, initialArg, init) {
                var hook = mountWorkInProgressHook();
                var initialState;
                if (init !== undefined) {
                    initialState = init(initialArg);
                } else {
                    initialState = initialArg;
                }
                hook.memoizedState = hook.baseState = initialState;
                var queue = {
                    pending: null,
                    interleaved: null,
                    lanes: NoLanes,
                    dispatch: null,
                    lastRenderedReducer: reducer,
                    lastRenderedState: initialState
                };
                hook.queue = queue;
                var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
                return [
                    hook.memoizedState,
                    dispatch
                ];
            }
            function updateReducer(reducer, initialArg, init) {
                var hook = updateWorkInProgressHook();
                var queue = hook.queue;
                if (queue === null) {
                    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');
                }
                queue.lastRenderedReducer = reducer;
                var current = currentHook; // The last rebase update that is NOT part of the base state.
                var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.
                var pendingQueue = queue.pending;
                if (pendingQueue !== null) {
                    // We have new updates that haven't been processed yet.
                    // We'll add them to the base queue.
                    if (baseQueue !== null) {
                        // Merge the pending queue and the base queue.
                        var baseFirst = baseQueue.next;
                        var pendingFirst = pendingQueue.next;
                        baseQueue.next = pendingFirst;
                        pendingQueue.next = baseFirst;
                    }
                    {
                        if (current.baseQueue !== baseQueue) {
                            // Internal invariant that should never happen, but feasibly could in
                            // the future if we implement resuming, or some form of that.
                            error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
                        }
                    }
                    current.baseQueue = baseQueue = pendingQueue;
                    queue.pending = null;
                }
                if (baseQueue !== null) {
                    // We have a queue to process.
                    var first = baseQueue.next;
                    var newState = current.baseState;
                    var newBaseState = null;
                    var newBaseQueueFirst = null;
                    var newBaseQueueLast = null;
                    var update = first;
                    do {
                        var updateLane = update.lane;
                        if (!isSubsetOfLanes(renderLanes, updateLane)) {
                            // Priority is insufficient. Skip this update. If this is the first
                            // skipped update, the previous update/state is the new base
                            // update/state.
                            var clone = {
                                lane: updateLane,
                                action: update.action,
                                hasEagerState: update.hasEagerState,
                                eagerState: update.eagerState,
                                next: null
                            };
                            if (newBaseQueueLast === null) {
                                newBaseQueueFirst = newBaseQueueLast = clone;
                                newBaseState = newState;
                            } else {
                                newBaseQueueLast = newBaseQueueLast.next = clone;
                            } // Update the remaining priority in the queue.
                            // TODO: Don't need to accumulate this. Instead, we can remove
                            // renderLanes from the original lanes.
                            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                            markSkippedUpdateLanes(updateLane);
                        } else {
                            // This update does have sufficient priority.
                            if (newBaseQueueLast !== null) {
                                var _clone = {
                                    // This update is going to be committed so we never want uncommit
                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                                    // this will never be skipped by the check above.
                                    lane: NoLane,
                                    action: update.action,
                                    hasEagerState: update.hasEagerState,
                                    eagerState: update.eagerState,
                                    next: null
                                };
                                newBaseQueueLast = newBaseQueueLast.next = _clone;
                            } // Process this update.
                            if (update.hasEagerState) {
                                // If this update is a state update (not a reducer) and was processed eagerly,
                                // we can use the eagerly computed state
                                newState = update.eagerState;
                            } else {
                                var action = update.action;
                                newState = reducer(newState, action);
                            }
                        }
                        update = update.next;
                    }while (update !== null && update !== first);
                    if (newBaseQueueLast === null) {
                        newBaseState = newState;
                    } else {
                        newBaseQueueLast.next = newBaseQueueFirst;
                    } // Mark that the fiber performed work, but only if the new state is
                    // different from the current state.
                    if (!objectIs(newState, hook.memoizedState)) {
                        markWorkInProgressReceivedUpdate();
                    }
                    hook.memoizedState = newState;
                    hook.baseState = newBaseState;
                    hook.baseQueue = newBaseQueueLast;
                    queue.lastRenderedState = newState;
                } // Interleaved updates are stored on a separate queue. We aren't going to
                // process them during this render, but we do need to track which lanes
                // are remaining.
                var lastInterleaved = queue.interleaved;
                if (lastInterleaved !== null) {
                    var interleaved = lastInterleaved;
                    do {
                        var interleavedLane = interleaved.lane;
                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                        markSkippedUpdateLanes(interleavedLane);
                        interleaved = interleaved.next;
                    }while (interleaved !== lastInterleaved);
                } else if (baseQueue === null) {
                    // `queue.lanes` is used for entangling transitions. We can set it back to
                    // zero once the queue is empty.
                    queue.lanes = NoLanes;
                }
                var dispatch = queue.dispatch;
                return [
                    hook.memoizedState,
                    dispatch
                ];
            }
            function rerenderReducer(reducer, initialArg, init) {
                var hook = updateWorkInProgressHook();
                var queue = hook.queue;
                if (queue === null) {
                    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');
                }
                queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
                // work-in-progress hook.
                var dispatch = queue.dispatch;
                var lastRenderPhaseUpdate = queue.pending;
                var newState = hook.memoizedState;
                if (lastRenderPhaseUpdate !== null) {
                    // The queue doesn't persist past this render pass.
                    queue.pending = null;
                    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                    var update = firstRenderPhaseUpdate;
                    do {
                        // Process this render phase update. We don't have to check the
                        // priority because it will always be the same as the current
                        // render's.
                        var action = update.action;
                        newState = reducer(newState, action);
                        update = update.next;
                    }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is
                    // different from the current state.
                    if (!objectIs(newState, hook.memoizedState)) {
                        markWorkInProgressReceivedUpdate();
                    }
                    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
                    // the base state unless the queue is empty.
                    // TODO: Not sure if this is the desired semantics, but it's what we
                    // do for gDSFP. I can't remember why.
                    if (hook.baseQueue === null) {
                        hook.baseState = newState;
                    }
                    queue.lastRenderedState = newState;
                }
                return [
                    newState,
                    dispatch
                ];
            }
            function mountMutableSource(source, getSnapshot, subscribe) {
                {
                    return undefined;
                }
            }
            function updateMutableSource(source, getSnapshot, subscribe) {
                {
                    return undefined;
                }
            }
            function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                var fiber = currentlyRenderingFiber$1;
                var hook = mountWorkInProgressHook();
                var nextSnapshot;
                var isHydrating = getIsHydrating();
                if (isHydrating) {
                    if (getServerSnapshot === undefined) {
                        throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');
                    }
                    nextSnapshot = getServerSnapshot();
                    {
                        if (!didWarnUncachedGetSnapshot) {
                            if (nextSnapshot !== getServerSnapshot()) {
                                error('The result of getServerSnapshot should be cached to avoid an infinite loop');
                                didWarnUncachedGetSnapshot = true;
                            }
                        }
                    }
                } else {
                    nextSnapshot = getSnapshot();
                    {
                        if (!didWarnUncachedGetSnapshot) {
                            var cachedSnapshot = getSnapshot();
                            if (!objectIs(nextSnapshot, cachedSnapshot)) {
                                error('The result of getSnapshot should be cached to avoid an infinite loop');
                                didWarnUncachedGetSnapshot = true;
                            }
                        }
                    }
                    // Right before committing, we will walk the tree and check if any of the
                    // stores were mutated.
                    //
                    // We won't do this if we're hydrating server-rendered content, because if
                    // the content is stale, it's already visible anyway. Instead we'll patch
                    // it up in a passive effect.
                    var root = getWorkInProgressRoot();
                    if (root === null) {
                        throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');
                    }
                    if (!includesBlockingLane(root, renderLanes)) {
                        pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                    }
                } // Read the current snapshot from the store on every render. This breaks the
                // normal rules of React, and only works because store updates are
                // always synchronous.
                hook.memoizedState = nextSnapshot;
                var inst = {
                    value: nextSnapshot,
                    getSnapshot: getSnapshot
                };
                hook.queue = inst; // Schedule an effect to subscribe to the store.
                mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                    subscribe
                ]); // Schedule an effect to update the mutable instance fields. We will update
                // this whenever subscribe, getSnapshot, or value changes. Because there's no
                // clean-up function, and we track the deps correctly, we can call pushEffect
                // directly, without storing any additional state. For the same reason, we
                // don't need to set a static flag, either.
                // TODO: We can move this to the passive phase once we add a pre-commit
                // consistency check. See the next comment.
                fiber.flags |= Passive;
                pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);
                return nextSnapshot;
            }
            function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                var fiber = currentlyRenderingFiber$1;
                var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the
                // normal rules of React, and only works because store updates are
                // always synchronous.
                var nextSnapshot = getSnapshot();
                {
                    if (!didWarnUncachedGetSnapshot) {
                        var cachedSnapshot = getSnapshot();
                        if (!objectIs(nextSnapshot, cachedSnapshot)) {
                            error('The result of getSnapshot should be cached to avoid an infinite loop');
                            didWarnUncachedGetSnapshot = true;
                        }
                    }
                }
                var prevSnapshot = hook.memoizedState;
                var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
                if (snapshotChanged) {
                    hook.memoizedState = nextSnapshot;
                    markWorkInProgressReceivedUpdate();
                }
                var inst = hook.queue;
                updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                    subscribe
                ]); // Whenever getSnapshot or subscribe changes, we need to check in the
                // commit phase if there was an interleaved mutation. In concurrent mode
                // this can happen all the time, but even in synchronous mode, an earlier
                // effect may have mutated the store.
                if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
                // checking whether we scheduled a subscription effect above.
                workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
                    fiber.flags |= Passive;
                    pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.
                    // Right before committing, we will walk the tree and check if any of the
                    // stores were mutated.
                    var root = getWorkInProgressRoot();
                    if (root === null) {
                        throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');
                    }
                    if (!includesBlockingLane(root, renderLanes)) {
                        pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                    }
                }
                return nextSnapshot;
            }
            function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
                fiber.flags |= StoreConsistency;
                var check = {
                    getSnapshot: getSnapshot,
                    value: renderedSnapshot
                };
                var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
                if (componentUpdateQueue === null) {
                    componentUpdateQueue = createFunctionComponentUpdateQueue();
                    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                    componentUpdateQueue.stores = [
                        check
                    ];
                } else {
                    var stores = componentUpdateQueue.stores;
                    if (stores === null) {
                        componentUpdateQueue.stores = [
                            check
                        ];
                    } else {
                        stores.push(check);
                    }
                }
            }
            function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
                // These are updated in the passive phase
                inst.value = nextSnapshot;
                inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could
                // have been in an event that fired before the passive effects, or it could
                // have been in a layout effect. In that case, we would have used the old
                // snapsho and getSnapshot values to bail out. We need to check one more time.
                if (checkIfSnapshotChanged(inst)) {
                    // Force a re-render.
                    forceStoreRerender(fiber);
                }
            }
            function subscribeToStore(fiber, inst, subscribe) {
                var handleStoreChange = function handleStoreChange() {
                    // The store changed. Check if the snapshot changed since the last time we
                    // read from the store.
                    if (checkIfSnapshotChanged(inst)) {
                        // Force a re-render.
                        forceStoreRerender(fiber);
                    }
                }; // Subscribe to the store and return a clean-up function.
                return subscribe(handleStoreChange);
            }
            function checkIfSnapshotChanged(inst) {
                var latestGetSnapshot = inst.getSnapshot;
                var prevValue = inst.value;
                try {
                    var nextValue = latestGetSnapshot();
                    return !objectIs(prevValue, nextValue);
                } catch (error) {
                    return true;
                }
            }
            function forceStoreRerender(fiber) {
                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                }
            }
            function mountState(initialState) {
                var hook = mountWorkInProgressHook();
                if (typeof initialState === 'function') {
                    // $FlowFixMe: Flow doesn't like mixed types
                    initialState = initialState();
                }
                hook.memoizedState = hook.baseState = initialState;
                var queue = {
                    pending: null,
                    interleaved: null,
                    lanes: NoLanes,
                    dispatch: null,
                    lastRenderedReducer: basicStateReducer,
                    lastRenderedState: initialState
                };
                hook.queue = queue;
                var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
                return [
                    hook.memoizedState,
                    dispatch
                ];
            }
            function updateState(initialState) {
                return updateReducer(basicStateReducer);
            }
            function rerenderState(initialState) {
                return rerenderReducer(basicStateReducer);
            }
            function pushEffect(tag, create, destroy, deps) {
                var effect = {
                    tag: tag,
                    create: create,
                    destroy: destroy,
                    deps: deps,
                    // Circular
                    next: null
                };
                var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
                if (componentUpdateQueue === null) {
                    componentUpdateQueue = createFunctionComponentUpdateQueue();
                    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                    componentUpdateQueue.lastEffect = effect.next = effect;
                } else {
                    var lastEffect = componentUpdateQueue.lastEffect;
                    if (lastEffect === null) {
                        componentUpdateQueue.lastEffect = effect.next = effect;
                    } else {
                        var firstEffect = lastEffect.next;
                        lastEffect.next = effect;
                        effect.next = firstEffect;
                        componentUpdateQueue.lastEffect = effect;
                    }
                }
                return effect;
            }
            function mountRef(initialValue) {
                var hook = mountWorkInProgressHook();
                {
                    var _ref2 = {
                        current: initialValue
                    };
                    hook.memoizedState = _ref2;
                    return _ref2;
                }
            }
            function updateRef(initialValue) {
                var hook = updateWorkInProgressHook();
                return hook.memoizedState;
            }
            function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
                var hook = mountWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                currentlyRenderingFiber$1.flags |= fiberFlags;
                hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
            }
            function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
                var hook = updateWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                var destroy = undefined;
                if (currentHook !== null) {
                    var prevEffect = currentHook.memoizedState;
                    destroy = prevEffect.destroy;
                    if (nextDeps !== null) {
                        var prevDeps = prevEffect.deps;
                        if (areHookInputsEqual(nextDeps, prevDeps)) {
                            hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                            return;
                        }
                    }
                }
                currentlyRenderingFiber$1.flags |= fiberFlags;
                hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
            }
            function mountEffect(create, deps) {
                if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                    return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
                } else {
                    return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
                }
            }
            function updateEffect(create, deps) {
                return updateEffectImpl(Passive, Passive$1, create, deps);
            }
            function mountInsertionEffect(create, deps) {
                return mountEffectImpl(Update, Insertion, create, deps);
            }
            function updateInsertionEffect(create, deps) {
                return updateEffectImpl(Update, Insertion, create, deps);
            }
            function mountLayoutEffect(create, deps) {
                var fiberFlags = Update;
                {
                    fiberFlags |= LayoutStatic;
                }
                if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                    fiberFlags |= MountLayoutDev;
                }
                return mountEffectImpl(fiberFlags, Layout, create, deps);
            }
            function updateLayoutEffect(create, deps) {
                return updateEffectImpl(Update, Layout, create, deps);
            }
            function imperativeHandleEffect(create, ref) {
                if (typeof ref === 'function') {
                    var refCallback = ref;
                    var _inst = create();
                    refCallback(_inst);
                    return function() {
                        refCallback(null);
                    };
                } else if (ref !== null && ref !== undefined) {
                    var refObject = ref;
                    {
                        if (!refObject.hasOwnProperty('current')) {
                            error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
                        }
                    }
                    var _inst2 = create();
                    refObject.current = _inst2;
                    return function() {
                        refObject.current = null;
                    };
                }
            }
            function mountImperativeHandle(ref, create, deps) {
                {
                    if (typeof create !== 'function') {
                        error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create === "undefined" ? "undefined" : _type_of(create) : 'null');
                    }
                }
                var effectDeps = deps !== null && deps !== undefined ? deps.concat([
                    ref
                ]) : null;
                var fiberFlags = Update;
                {
                    fiberFlags |= LayoutStatic;
                }
                if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                    fiberFlags |= MountLayoutDev;
                }
                return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
            }
            function updateImperativeHandle(ref, create, deps) {
                {
                    if (typeof create !== 'function') {
                        error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create === "undefined" ? "undefined" : _type_of(create) : 'null');
                    }
                }
                var effectDeps = deps !== null && deps !== undefined ? deps.concat([
                    ref
                ]) : null;
                return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
            }
            function mountDebugValue(value, formatterFn) {
            // The react-debug-hooks package injects its own implementation
            // so that e.g. DevTools can display custom hook values.
            }
            var updateDebugValue = mountDebugValue;
            function mountCallback(callback, deps) {
                var hook = mountWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                hook.memoizedState = [
                    callback,
                    nextDeps
                ];
                return callback;
            }
            function updateCallback(callback, deps) {
                var hook = updateWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                var prevState = hook.memoizedState;
                if (prevState !== null) {
                    if (nextDeps !== null) {
                        var prevDeps = prevState[1];
                        if (areHookInputsEqual(nextDeps, prevDeps)) {
                            return prevState[0];
                        }
                    }
                }
                hook.memoizedState = [
                    callback,
                    nextDeps
                ];
                return callback;
            }
            function mountMemo(nextCreate, deps) {
                var hook = mountWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                var nextValue = nextCreate();
                hook.memoizedState = [
                    nextValue,
                    nextDeps
                ];
                return nextValue;
            }
            function updateMemo(nextCreate, deps) {
                var hook = updateWorkInProgressHook();
                var nextDeps = deps === undefined ? null : deps;
                var prevState = hook.memoizedState;
                if (prevState !== null) {
                    // Assume these are defined. If they're not, areHookInputsEqual will warn.
                    if (nextDeps !== null) {
                        var prevDeps = prevState[1];
                        if (areHookInputsEqual(nextDeps, prevDeps)) {
                            return prevState[0];
                        }
                    }
                }
                var nextValue = nextCreate();
                hook.memoizedState = [
                    nextValue,
                    nextDeps
                ];
                return nextValue;
            }
            function mountDeferredValue(value) {
                var hook = mountWorkInProgressHook();
                hook.memoizedState = value;
                return value;
            }
            function updateDeferredValue(value) {
                var hook = updateWorkInProgressHook();
                var resolvedCurrentHook = currentHook;
                var prevValue = resolvedCurrentHook.memoizedState;
                return updateDeferredValueImpl(hook, prevValue, value);
            }
            function rerenderDeferredValue(value) {
                var hook = updateWorkInProgressHook();
                if (currentHook === null) {
                    // This is a rerender during a mount.
                    hook.memoizedState = value;
                    return value;
                } else {
                    // This is a rerender during an update.
                    var prevValue = currentHook.memoizedState;
                    return updateDeferredValueImpl(hook, prevValue, value);
                }
            }
            function updateDeferredValueImpl(hook, prevValue, value) {
                var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
                if (shouldDeferValue) {
                    // This is an urgent update. If the value has changed, keep using the
                    // previous value and spawn a deferred render to update it later.
                    if (!objectIs(value, prevValue)) {
                        // Schedule a deferred render
                        var deferredLane = claimNextTransitionLane();
                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                        markSkippedUpdateLanes(deferredLane); // Set this to true to indicate that the rendered value is inconsistent
                        // from the latest value. The name "baseState" doesn't really match how we
                        // use it because we're reusing a state hook field instead of creating a
                        // new one.
                        hook.baseState = true;
                    } // Reuse the previous value
                    return prevValue;
                } else {
                    // This is not an urgent update, so we can use the latest value regardless
                    // of what it is. No need to defer it.
                    // However, if we're currently inside a spawned render, then we need to mark
                    // this as an update to prevent the fiber from bailing out.
                    //
                    // `baseState` is true when the current value is different from the rendered
                    // value. The name doesn't really match how we use it because we're reusing
                    // a state hook field instead of creating a new one.
                    if (hook.baseState) {
                        // Flip this back to false.
                        hook.baseState = false;
                        markWorkInProgressReceivedUpdate();
                    }
                    hook.memoizedState = value;
                    return value;
                }
            }
            function startTransition(setPending, callback, options) {
                var previousPriority = getCurrentUpdatePriority();
                setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
                setPending(true);
                var prevTransition = ReactCurrentBatchConfig$1.transition;
                ReactCurrentBatchConfig$1.transition = {};
                var currentTransition = ReactCurrentBatchConfig$1.transition;
                {
                    ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();
                }
                try {
                    setPending(false);
                    callback();
                } finally{
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$1.transition = prevTransition;
                    {
                        if (prevTransition === null && currentTransition._updatedFibers) {
                            var updatedFibersCount = currentTransition._updatedFibers.size;
                            if (updatedFibersCount > 10) {
                                warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                            }
                            currentTransition._updatedFibers.clear();
                        }
                    }
                }
            }
            function mountTransition() {
                var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1]; // The `start` method never changes.
                var start = startTransition.bind(null, setPending);
                var hook = mountWorkInProgressHook();
                hook.memoizedState = start;
                return [
                    isPending,
                    start
                ];
            }
            function updateTransition() {
                var _updateState = updateState(), isPending = _updateState[0];
                var hook = updateWorkInProgressHook();
                var start = hook.memoizedState;
                return [
                    isPending,
                    start
                ];
            }
            function rerenderTransition() {
                var _rerenderState = rerenderState(), isPending = _rerenderState[0];
                var hook = updateWorkInProgressHook();
                var start = hook.memoizedState;
                return [
                    isPending,
                    start
                ];
            }
            var isUpdatingOpaqueValueInRenderPhase = false;
            function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
                {
                    return isUpdatingOpaqueValueInRenderPhase;
                }
            }
            function mountId() {
                var hook = mountWorkInProgressHook();
                var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we
                // should do this in Fiber, too? Deferring this decision for now because
                // there's no other place to store the prefix except for an internal field on
                // the public createRoot object, which the fiber tree does not currently have
                // a reference to.
                var identifierPrefix = root.identifierPrefix;
                var id;
                if (getIsHydrating()) {
                    var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.
                    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end
                    // that represents the position of this useId hook among all the useId
                    // hooks for this fiber.
                    var localId = localIdCounter++;
                    if (localId > 0) {
                        id += 'H' + localId.toString(32);
                    }
                    id += ':';
                } else {
                    // Use a lowercase r prefix for client-generated ids.
                    var globalClientId = globalClientIdCounter++;
                    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';
                }
                hook.memoizedState = id;
                return id;
            }
            function updateId() {
                var hook = updateWorkInProgressHook();
                var id = hook.memoizedState;
                return id;
            }
            function dispatchReducerAction(fiber, queue, action) {
                {
                    if (typeof arguments[3] === 'function') {
                        error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
                    }
                }
                var lane = requestUpdateLane(fiber);
                var update = {
                    lane: lane,
                    action: action,
                    hasEagerState: false,
                    eagerState: null,
                    next: null
                };
                if (isRenderPhaseUpdate(fiber)) {
                    enqueueRenderPhaseUpdate(queue, update);
                } else {
                    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                    if (root !== null) {
                        var eventTime = requestEventTime();
                        scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                        entangleTransitionUpdate(root, queue, lane);
                    }
                }
                markUpdateInDevTools(fiber, lane);
            }
            function dispatchSetState(fiber, queue, action) {
                {
                    if (typeof arguments[3] === 'function') {
                        error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
                    }
                }
                var lane = requestUpdateLane(fiber);
                var update = {
                    lane: lane,
                    action: action,
                    hasEagerState: false,
                    eagerState: null,
                    next: null
                };
                if (isRenderPhaseUpdate(fiber)) {
                    enqueueRenderPhaseUpdate(queue, update);
                } else {
                    var alternate = fiber.alternate;
                    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                        // The queue is currently empty, which means we can eagerly compute the
                        // next state before entering the render phase. If the new state is the
                        // same as the current state, we may be able to bail out entirely.
                        var lastRenderedReducer = queue.lastRenderedReducer;
                        if (lastRenderedReducer !== null) {
                            var prevDispatcher;
                            {
                                prevDispatcher = ReactCurrentDispatcher$1.current;
                                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                            }
                            try {
                                var currentState = queue.lastRenderedState;
                                var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
                                // it, on the update object. If the reducer hasn't changed by the
                                // time we enter the render phase, then the eager state can be used
                                // without calling the reducer again.
                                update.hasEagerState = true;
                                update.eagerState = eagerState;
                                if (objectIs(eagerState, currentState)) {
                                    // Fast path. We can bail out without scheduling React to re-render.
                                    // It's still possible that we'll need to rebase this update later,
                                    // if the component re-renders for a different reason and by that
                                    // time the reducer has changed.
                                    // TODO: Do we still need to entangle transitions in this case?
                                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                                    return;
                                }
                            } catch (error) {} finally{
                                {
                                    ReactCurrentDispatcher$1.current = prevDispatcher;
                                }
                            }
                        }
                    }
                    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                    if (root !== null) {
                        var eventTime = requestEventTime();
                        scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                        entangleTransitionUpdate(root, queue, lane);
                    }
                }
                markUpdateInDevTools(fiber, lane);
            }
            function isRenderPhaseUpdate(fiber) {
                var alternate = fiber.alternate;
                return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
            }
            function enqueueRenderPhaseUpdate(queue, update) {
                // This is a render phase update. Stash it in a lazily-created map of
                // queue -> linked list of updates. After this render pass, we'll restart
                // and apply the stashed updates on top of the work-in-progress hook.
                didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
                var pending = queue.pending;
                if (pending === null) {
                    // This is the first update. Create a circular list.
                    update.next = update;
                } else {
                    update.next = pending.next;
                    pending.next = update;
                }
                queue.pending = update;
            } // TODO: Move to ReactFiberConcurrentUpdates?
            function entangleTransitionUpdate(root, queue, lane) {
                if (isTransitionLane(lane)) {
                    var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they
                    // must have finished. We can remove them from the shared queue, which
                    // represents a superset of the actually pending lanes. In some cases we
                    // may entangle more than we need to, but that's OK. In fact it's worse if
                    // we *don't* entangle when we should.
                    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.
                    var newQueueLanes = mergeLanes(queueLanes, lane);
                    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if
                    // the lane finished since the last time we entangled it. So we need to
                    // entangle it again, just to be sure.
                    markRootEntangled(root, newQueueLanes);
                }
            }
            function markUpdateInDevTools(fiber, lane, action) {
                {
                    markStateUpdateScheduled(fiber, lane);
                }
            }
            var ContextOnlyDispatcher = {
                readContext: readContext,
                useCallback: throwInvalidHookError,
                useContext: throwInvalidHookError,
                useEffect: throwInvalidHookError,
                useImperativeHandle: throwInvalidHookError,
                useInsertionEffect: throwInvalidHookError,
                useLayoutEffect: throwInvalidHookError,
                useMemo: throwInvalidHookError,
                useReducer: throwInvalidHookError,
                useRef: throwInvalidHookError,
                useState: throwInvalidHookError,
                useDebugValue: throwInvalidHookError,
                useDeferredValue: throwInvalidHookError,
                useTransition: throwInvalidHookError,
                useMutableSource: throwInvalidHookError,
                useSyncExternalStore: throwInvalidHookError,
                useId: throwInvalidHookError,
                unstable_isNewReconciler: enableNewReconciler
            };
            var HooksDispatcherOnMountInDEV = null;
            var HooksDispatcherOnMountWithHookTypesInDEV = null;
            var HooksDispatcherOnUpdateInDEV = null;
            var HooksDispatcherOnRerenderInDEV = null;
            var InvalidNestedHooksDispatcherOnMountInDEV = null;
            var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
            var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
            {
                var warnInvalidContextAccess = function warnInvalidContextAccess() {
                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
                };
                var warnInvalidHookAccess = function warnInvalidHookAccess() {
                    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
                };
                HooksDispatcherOnMountInDEV = {
                    readContext: function readContext1(context) {
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        mountHookTypesDev();
                        checkDepsAreArrayDev(deps);
                        return mountCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        mountHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        mountHookTypesDev();
                        checkDepsAreArrayDev(deps);
                        return mountEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        mountHookTypesDev();
                        checkDepsAreArrayDev(deps);
                        return mountImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        mountHookTypesDev();
                        checkDepsAreArrayDev(deps);
                        return mountInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        mountHookTypesDev();
                        checkDepsAreArrayDev(deps);
                        return mountLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        mountHookTypesDev();
                        checkDepsAreArrayDev(deps);
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        mountHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        mountHookTypesDev();
                        return mountRef(initialValue);
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        mountHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        mountHookTypesDev();
                        return mountDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        mountHookTypesDev();
                        return mountDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        mountHookTypesDev();
                        return mountTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        mountHookTypesDev();
                        return mountMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        mountHookTypesDev();
                        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        mountHookTypesDev();
                        return mountId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
                HooksDispatcherOnMountWithHookTypesInDEV = {
                    readContext: function readContext1(context) {
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        updateHookTypesDev();
                        return mountCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        updateHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        updateHookTypesDev();
                        return mountEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        updateHookTypesDev();
                        return mountImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        updateHookTypesDev();
                        return mountInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        updateHookTypesDev();
                        return mountLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        updateHookTypesDev();
                        return mountRef(initialValue);
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        updateHookTypesDev();
                        return mountDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        updateHookTypesDev();
                        return mountDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        updateHookTypesDev();
                        return mountTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        updateHookTypesDev();
                        return mountMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        updateHookTypesDev();
                        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        updateHookTypesDev();
                        return mountId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
                HooksDispatcherOnUpdateInDEV = {
                    readContext: function readContext1(context) {
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        updateHookTypesDev();
                        return updateCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        updateHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        updateHookTypesDev();
                        return updateEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        updateHookTypesDev();
                        return updateImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        updateHookTypesDev();
                        return updateInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        updateHookTypesDev();
                        return updateLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        updateHookTypesDev();
                        return updateRef();
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        updateHookTypesDev();
                        return updateDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        updateHookTypesDev();
                        return updateDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        updateHookTypesDev();
                        return updateTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        updateHookTypesDev();
                        return updateMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        updateHookTypesDev();
                        return updateSyncExternalStore(subscribe, getSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        updateHookTypesDev();
                        return updateId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
                HooksDispatcherOnRerenderInDEV = {
                    readContext: function readContext1(context) {
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        updateHookTypesDev();
                        return updateCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        updateHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        updateHookTypesDev();
                        return updateEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        updateHookTypesDev();
                        return updateImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        updateHookTypesDev();
                        return updateInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        updateHookTypesDev();
                        return updateLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                        try {
                            return updateMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                        try {
                            return rerenderReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        updateHookTypesDev();
                        return updateRef();
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                        try {
                            return rerenderState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        updateHookTypesDev();
                        return updateDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        updateHookTypesDev();
                        return rerenderDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        updateHookTypesDev();
                        return rerenderTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        updateHookTypesDev();
                        return updateMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        updateHookTypesDev();
                        return updateSyncExternalStore(subscribe, getSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        updateHookTypesDev();
                        return updateId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
                InvalidNestedHooksDispatcherOnMountInDEV = {
                    readContext: function readContext1(context) {
                        warnInvalidContextAccess();
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountRef(initialValue);
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                        try {
                            return mountState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        warnInvalidHookAccess();
                        mountHookTypesDev();
                        return mountId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
                InvalidNestedHooksDispatcherOnUpdateInDEV = {
                    readContext: function readContext1(context) {
                        warnInvalidContextAccess();
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateRef();
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateSyncExternalStore(subscribe, getSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
                InvalidNestedHooksDispatcherOnRerenderInDEV = {
                    readContext: function readContext1(context) {
                        warnInvalidContextAccess();
                        return readContext(context);
                    },
                    useCallback: function useCallback(callback, deps) {
                        currentHookNameInDev = 'useCallback';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateCallback(callback, deps);
                    },
                    useContext: function useContext(context) {
                        currentHookNameInDev = 'useContext';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return readContext(context);
                    },
                    useEffect: function useEffect(create, deps) {
                        currentHookNameInDev = 'useEffect';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateEffect(create, deps);
                    },
                    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
                        currentHookNameInDev = 'useImperativeHandle';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateImperativeHandle(ref, create, deps);
                    },
                    useInsertionEffect: function useInsertionEffect(create, deps) {
                        currentHookNameInDev = 'useInsertionEffect';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateInsertionEffect(create, deps);
                    },
                    useLayoutEffect: function useLayoutEffect(create, deps) {
                        currentHookNameInDev = 'useLayoutEffect';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateLayoutEffect(create, deps);
                    },
                    useMemo: function useMemo(create, deps) {
                        currentHookNameInDev = 'useMemo';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return updateMemo(create, deps);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useReducer: function useReducer(reducer, initialArg, init) {
                        currentHookNameInDev = 'useReducer';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return rerenderReducer(reducer, initialArg, init);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useRef: function useRef(initialValue) {
                        currentHookNameInDev = 'useRef';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateRef();
                    },
                    useState: function useState(initialState) {
                        currentHookNameInDev = 'useState';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        var prevDispatcher = ReactCurrentDispatcher$1.current;
                        ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        try {
                            return rerenderState(initialState);
                        } finally{
                            ReactCurrentDispatcher$1.current = prevDispatcher;
                        }
                    },
                    useDebugValue: function useDebugValue(value, formatterFn) {
                        currentHookNameInDev = 'useDebugValue';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateDebugValue();
                    },
                    useDeferredValue: function useDeferredValue(value) {
                        currentHookNameInDev = 'useDeferredValue';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return rerenderDeferredValue(value);
                    },
                    useTransition: function useTransition() {
                        currentHookNameInDev = 'useTransition';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return rerenderTransition();
                    },
                    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
                        currentHookNameInDev = 'useMutableSource';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateMutableSource();
                    },
                    useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
                        currentHookNameInDev = 'useSyncExternalStore';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateSyncExternalStore(subscribe, getSnapshot);
                    },
                    useId: function useId() {
                        currentHookNameInDev = 'useId';
                        warnInvalidHookAccess();
                        updateHookTypesDev();
                        return updateId();
                    },
                    unstable_isNewReconciler: enableNewReconciler
                };
            }
            var now$1 = Scheduler.unstable_now;
            var commitTime = 0;
            var layoutEffectStartTime = -1;
            var profilerStartTime = -1;
            var passiveEffectStartTime = -1;
            /**
	 * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).
	 *
	 * The overall sequence is:
	 *   1. render
	 *   2. commit (and call `onRender`, `onCommit`)
	 *   3. check for nested updates
	 *   4. flush passive effects (and call `onPostCommit`)
	 *
	 * Nested updates are identified in step 3 above,
	 * but step 4 still applies to the work that was just committed.
	 * We use two flags to track nested updates then:
	 * one tracks whether the upcoming update is a nested update,
	 * and the other tracks whether the current update was a nested update.
	 * The first value gets synced to the second at the start of the render phase.
	 */ var currentUpdateIsNested = false;
            var nestedUpdateScheduled = false;
            function isCurrentUpdateNested() {
                return currentUpdateIsNested;
            }
            function markNestedUpdateScheduled() {
                {
                    nestedUpdateScheduled = true;
                }
            }
            function resetNestedUpdateFlag() {
                {
                    currentUpdateIsNested = false;
                    nestedUpdateScheduled = false;
                }
            }
            function syncNestedUpdateFlag() {
                {
                    currentUpdateIsNested = nestedUpdateScheduled;
                    nestedUpdateScheduled = false;
                }
            }
            function getCommitTime() {
                return commitTime;
            }
            function recordCommitTime() {
                commitTime = now$1();
            }
            function startProfilerTimer(fiber) {
                profilerStartTime = now$1();
                if (fiber.actualStartTime < 0) {
                    fiber.actualStartTime = now$1();
                }
            }
            function stopProfilerTimerIfRunning(fiber) {
                profilerStartTime = -1;
            }
            function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
                if (profilerStartTime >= 0) {
                    var elapsedTime = now$1() - profilerStartTime;
                    fiber.actualDuration += elapsedTime;
                    if (overrideBaseTime) {
                        fiber.selfBaseDuration = elapsedTime;
                    }
                    profilerStartTime = -1;
                }
            }
            function recordLayoutEffectDuration(fiber) {
                if (layoutEffectStartTime >= 0) {
                    var elapsedTime = now$1() - layoutEffectStartTime;
                    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor
                    // Or the root (for the DevTools Profiler to read)
                    var parentFiber = fiber.return;
                    while(parentFiber !== null){
                        switch(parentFiber.tag){
                            case HostRoot:
                                var root = parentFiber.stateNode;
                                root.effectDuration += elapsedTime;
                                return;
                            case Profiler:
                                var parentStateNode = parentFiber.stateNode;
                                parentStateNode.effectDuration += elapsedTime;
                                return;
                        }
                        parentFiber = parentFiber.return;
                    }
                }
            }
            function recordPassiveEffectDuration(fiber) {
                if (passiveEffectStartTime >= 0) {
                    var elapsedTime = now$1() - passiveEffectStartTime;
                    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor
                    // Or the root (for the DevTools Profiler to read)
                    var parentFiber = fiber.return;
                    while(parentFiber !== null){
                        switch(parentFiber.tag){
                            case HostRoot:
                                var root = parentFiber.stateNode;
                                if (root !== null) {
                                    root.passiveEffectDuration += elapsedTime;
                                }
                                return;
                            case Profiler:
                                var parentStateNode = parentFiber.stateNode;
                                if (parentStateNode !== null) {
                                    // Detached fibers have their state node cleared out.
                                    // In this case, the return pointer is also cleared out,
                                    // so we won't be able to report the time spent in this Profiler's subtree.
                                    parentStateNode.passiveEffectDuration += elapsedTime;
                                }
                                return;
                        }
                        parentFiber = parentFiber.return;
                    }
                }
            }
            function startLayoutEffectTimer() {
                layoutEffectStartTime = now$1();
            }
            function startPassiveEffectTimer() {
                passiveEffectStartTime = now$1();
            }
            function transferActualDuration(fiber) {
                // Transfer time spent rendering these children so we don't lose it
                // after we rerender. This is used as a helper in special cases
                // where we should count the work of multiple passes.
                var child = fiber.child;
                while(child){
                    fiber.actualDuration += child.actualDuration;
                    child = child.sibling;
                }
            }
            function resolveDefaultProps(Component, baseProps) {
                if (Component && Component.defaultProps) {
                    // Resolve default props. Taken from ReactElement
                    var props = assign({}, baseProps);
                    var defaultProps = Component.defaultProps;
                    for(var propName in defaultProps){
                        if (props[propName] === undefined) {
                            props[propName] = defaultProps[propName];
                        }
                    }
                    return props;
                }
                return baseProps;
            }
            var fakeInternalInstance = {};
            var didWarnAboutStateAssignmentForComponent;
            var didWarnAboutUninitializedState;
            var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
            var didWarnAboutLegacyLifecyclesAndDerivedState;
            var didWarnAboutUndefinedDerivedState;
            var warnOnUndefinedDerivedState;
            var warnOnInvalidCallback;
            var didWarnAboutDirectlyAssigningPropsToState;
            var didWarnAboutContextTypeAndContextTypes;
            var didWarnAboutInvalidateContextType;
            var didWarnAboutLegacyContext$1;
            {
                didWarnAboutStateAssignmentForComponent = new Set();
                didWarnAboutUninitializedState = new Set();
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
                didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
                didWarnAboutDirectlyAssigningPropsToState = new Set();
                didWarnAboutUndefinedDerivedState = new Set();
                didWarnAboutContextTypeAndContextTypes = new Set();
                didWarnAboutInvalidateContextType = new Set();
                didWarnAboutLegacyContext$1 = new Set();
                var didWarnOnInvalidCallback = new Set();
                warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
                    if (callback === null || typeof callback === 'function') {
                        return;
                    }
                    var key = callerName + '_' + callback;
                    if (!didWarnOnInvalidCallback.has(key)) {
                        didWarnOnInvalidCallback.add(key);
                        error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
                    }
                };
                warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
                    if (partialState === undefined) {
                        var componentName = getComponentNameFromType(type) || 'Component';
                        if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                            didWarnAboutUndefinedDerivedState.add(componentName);
                            error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
                        }
                    }
                }; // This is so gross but it's at least non-critical and can be removed if
                // it causes problems. This is meant to give a nicer error message for
                // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
                // ...)) which otherwise throws a "_processChildContext is not a function"
                // exception.
                Object.defineProperty(fakeInternalInstance, '_processChildContext', {
                    enumerable: false,
                    value: function value() {
                        throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');
                    }
                });
                Object.freeze(fakeInternalInstance);
            }
            function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
                var prevState = workInProgress.memoizedState;
                var partialState = getDerivedStateFromProps(nextProps, prevState);
                {
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            // Invoke the function an extra time to help detect side-effects.
                            partialState = getDerivedStateFromProps(nextProps, prevState);
                        } finally{
                            setIsStrictModeForDevtools(false);
                        }
                    }
                    warnOnUndefinedDerivedState(ctor, partialState);
                }
                var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
                workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
                // base state.
                if (workInProgress.lanes === NoLanes) {
                    // Queue is always non-null for classes
                    var updateQueue = workInProgress.updateQueue;
                    updateQueue.baseState = memoizedState;
                }
            }
            var classComponentUpdater = {
                isMounted: isMounted,
                enqueueSetState: function enqueueSetState(inst, payload, callback) {
                    var fiber = get(inst);
                    var eventTime = requestEventTime();
                    var lane = requestUpdateLane(fiber);
                    var update = createUpdate(eventTime, lane);
                    update.payload = payload;
                    if (callback !== undefined && callback !== null) {
                        {
                            warnOnInvalidCallback(callback, 'setState');
                        }
                        update.callback = callback;
                    }
                    var root = enqueueUpdate(fiber, update, lane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                        entangleTransitions(root, fiber, lane);
                    }
                    {
                        markStateUpdateScheduled(fiber, lane);
                    }
                },
                enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
                    var fiber = get(inst);
                    var eventTime = requestEventTime();
                    var lane = requestUpdateLane(fiber);
                    var update = createUpdate(eventTime, lane);
                    update.tag = ReplaceState;
                    update.payload = payload;
                    if (callback !== undefined && callback !== null) {
                        {
                            warnOnInvalidCallback(callback, 'replaceState');
                        }
                        update.callback = callback;
                    }
                    var root = enqueueUpdate(fiber, update, lane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                        entangleTransitions(root, fiber, lane);
                    }
                    {
                        markStateUpdateScheduled(fiber, lane);
                    }
                },
                enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
                    var fiber = get(inst);
                    var eventTime = requestEventTime();
                    var lane = requestUpdateLane(fiber);
                    var update = createUpdate(eventTime, lane);
                    update.tag = ForceUpdate;
                    if (callback !== undefined && callback !== null) {
                        {
                            warnOnInvalidCallback(callback, 'forceUpdate');
                        }
                        update.callback = callback;
                    }
                    var root = enqueueUpdate(fiber, update, lane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                        entangleTransitions(root, fiber, lane);
                    }
                    {
                        markForceUpdateScheduled(fiber, lane);
                    }
                }
            };
            function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
                var instance = workInProgress.stateNode;
                if (typeof instance.shouldComponentUpdate === 'function') {
                    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                    {
                        if (workInProgress.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                // Invoke the function an extra time to help detect side-effects.
                                shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                        if (shouldUpdate === undefined) {
                            error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');
                        }
                    }
                    return shouldUpdate;
                }
                if (ctor.prototype && ctor.prototype.isPureReactComponent) {
                    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
                }
                return true;
            }
            function checkClassInstance(workInProgress, ctor, newProps) {
                var instance = workInProgress.stateNode;
                {
                    var name = getComponentNameFromType(ctor) || 'Component';
                    var renderPresent = instance.render;
                    if (!renderPresent) {
                        if (ctor.prototype && typeof ctor.prototype.render === 'function') {
                            error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
                        } else {
                            error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
                        }
                    }
                    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                        error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
                    }
                    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                        error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
                    }
                    if (instance.propTypes) {
                        error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
                    }
                    if (instance.contextType) {
                        error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
                    }
                    {
                        if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
                        // this one.
                        (workInProgress.mode & StrictLegacyMode) === NoMode) {
                            didWarnAboutLegacyContext$1.add(ctor);
                            error('%s uses the legacy childContextTypes API which is no longer ' + 'supported and will be removed in the next major release. Use ' + 'React.createContext() instead\n\n.' + 'Learn more about this warning here: https://reactjs.org/link/legacy-context', name);
                        }
                        if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
                        // this one.
                        (workInProgress.mode & StrictLegacyMode) === NoMode) {
                            didWarnAboutLegacyContext$1.add(ctor);
                            error('%s uses the legacy contextTypes API which is no longer supported ' + 'and will be removed in the next major release. Use ' + 'React.createContext() with static contextType instead.\n\n' + 'Learn more about this warning here: https://reactjs.org/link/legacy-context', name);
                        }
                        if (instance.contextTypes) {
                            error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
                        }
                        if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                            didWarnAboutContextTypeAndContextTypes.add(ctor);
                            error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
                        }
                    }
                    if (typeof instance.componentShouldUpdate === 'function') {
                        error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
                    }
                    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
                        error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');
                    }
                    if (typeof instance.componentDidUnmount === 'function') {
                        error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
                    }
                    if (typeof instance.componentDidReceiveProps === 'function') {
                        error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
                    }
                    if (typeof instance.componentWillRecieveProps === 'function') {
                        error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
                    }
                    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
                        error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
                    }
                    var hasMutatedProps = instance.props !== newProps;
                    if (instance.props !== undefined && hasMutatedProps) {
                        error('%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
                    }
                    if (instance.defaultProps) {
                        error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
                    }
                    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                        error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));
                    }
                    if (typeof instance.getDerivedStateFromProps === 'function') {
                        error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
                    }
                    if (typeof instance.getDerivedStateFromError === 'function') {
                        error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
                    }
                    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
                        error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
                    }
                    var _state = instance.state;
                    if (_state && ((typeof _state === "undefined" ? "undefined" : _type_of(_state)) !== 'object' || isArray(_state))) {
                        error('%s.state: must be set to an object or null', name);
                    }
                    if (typeof instance.getChildContext === 'function' && _type_of(ctor.childContextTypes) !== 'object') {
                        error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
                    }
                }
            }
            function adoptClassInstance(workInProgress, instance) {
                instance.updater = classComponentUpdater;
                workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates
                set(instance, workInProgress);
                {
                    instance._reactInternalInstance = fakeInternalInstance;
                }
            }
            function constructClassInstance(workInProgress, ctor, props) {
                var isLegacyContextConsumer = false;
                var unmaskedContext = emptyContextObject;
                var context = emptyContextObject;
                var contextType = ctor.contextType;
                {
                    if ('contextType' in ctor) {
                        var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>
                        if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                            didWarnAboutInvalidateContextType.add(ctor);
                            var addendum = '';
                            if (contextType === undefined) {
                                addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
                            } else if ((typeof contextType === "undefined" ? "undefined" : _type_of(contextType)) !== 'object') {
                                addendum = ' However, it is set to a ' + (typeof contextType === "undefined" ? "undefined" : _type_of(contextType)) + '.';
                            } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                                addendum = ' Did you accidentally pass the Context.Provider instead?';
                            } else if (contextType._context !== undefined) {
                                // <Context.Consumer>
                                addendum = ' Did you accidentally pass the Context.Consumer instead?';
                            } else {
                                addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                            }
                            error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);
                        }
                    }
                }
                if ((typeof contextType === "undefined" ? "undefined" : _type_of(contextType)) === 'object' && contextType !== null) {
                    context = readContext(contextType);
                } else {
                    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                    var contextTypes = ctor.contextTypes;
                    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
                    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
                }
                var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.
                {
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            instance = new ctor(props, context); // eslint-disable-line no-new
                        } finally{
                            setIsStrictModeForDevtools(false);
                        }
                    }
                }
                var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
                adoptClassInstance(workInProgress, instance);
                {
                    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
                        var componentName = getComponentNameFromType(ctor) || 'Component';
                        if (!didWarnAboutUninitializedState.has(componentName)) {
                            didWarnAboutUninitializedState.add(componentName);
                            error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
                        }
                    } // If new component APIs are defined, "unsafe" lifecycles won't be called.
                    // Warn about these lifecycles if they are present.
                    // Don't warn about react-lifecycles-compat polyfilled methods though.
                    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
                        var foundWillMountName = null;
                        var foundWillReceivePropsName = null;
                        var foundWillUpdateName = null;
                        if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                            foundWillMountName = 'componentWillMount';
                        } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
                            foundWillMountName = 'UNSAFE_componentWillMount';
                        }
                        if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                            foundWillReceivePropsName = 'componentWillReceiveProps';
                        } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                            foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
                        }
                        if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                            foundWillUpdateName = 'componentWillUpdate';
                        } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
                            foundWillUpdateName = 'UNSAFE_componentWillUpdate';
                        }
                        if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                            var _componentName = getComponentNameFromType(ctor) || 'Component';
                            var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
                            if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                                error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
                            }
                        }
                    }
                }
                // ReactFiberContext usually updates this cache but can't for newly-created instances.
                if (isLegacyContextConsumer) {
                    cacheContext(workInProgress, unmaskedContext, context);
                }
                return instance;
            }
            function callComponentWillMount(workInProgress, instance) {
                var oldState = instance.state;
                if (typeof instance.componentWillMount === 'function') {
                    instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === 'function') {
                    instance.UNSAFE_componentWillMount();
                }
                if (oldState !== instance.state) {
                    {
                        error('%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');
                    }
                    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
                }
            }
            function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
                var oldState = instance.state;
                if (typeof instance.componentWillReceiveProps === 'function') {
                    instance.componentWillReceiveProps(newProps, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
                }
                if (instance.state !== oldState) {
                    {
                        var componentName = getComponentNameFromFiber(workInProgress) || 'Component';
                        if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                            didWarnAboutStateAssignmentForComponent.add(componentName);
                            error('%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
                        }
                    }
                    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
                }
            } // Invokes the mount life-cycles on a previously never rendered instance.
            function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
                {
                    checkClassInstance(workInProgress, ctor, newProps);
                }
                var instance = workInProgress.stateNode;
                instance.props = newProps;
                instance.state = workInProgress.memoizedState;
                instance.refs = {};
                initializeUpdateQueue(workInProgress);
                var contextType = ctor.contextType;
                if ((typeof contextType === "undefined" ? "undefined" : _type_of(contextType)) === 'object' && contextType !== null) {
                    instance.context = readContext(contextType);
                } else {
                    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                    instance.context = getMaskedContext(workInProgress, unmaskedContext);
                }
                {
                    if (instance.state === newProps) {
                        var componentName = getComponentNameFromType(ctor) || 'Component';
                        if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                            didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                            error('%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
                        }
                    }
                    if (workInProgress.mode & StrictLegacyMode) {
                        ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
                    }
                    {
                        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
                    }
                }
                instance.state = workInProgress.memoizedState;
                var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                if (typeof getDerivedStateFromProps === 'function') {
                    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
                    instance.state = workInProgress.memoizedState;
                } // In order to support react-lifecycles-compat polyfilled components,
                // Unsafe lifecycles should not be invoked for components using the new APIs.
                if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
                    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
                    // process them now.
                    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
                    instance.state = workInProgress.memoizedState;
                }
                if (typeof instance.componentDidMount === 'function') {
                    var fiberFlags = Update;
                    {
                        fiberFlags |= LayoutStatic;
                    }
                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                        fiberFlags |= MountLayoutDev;
                    }
                    workInProgress.flags |= fiberFlags;
                }
            }
            function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
                var instance = workInProgress.stateNode;
                var oldProps = workInProgress.memoizedProps;
                instance.props = oldProps;
                var oldContext = instance.context;
                var contextType = ctor.contextType;
                var nextContext = emptyContextObject;
                if ((typeof contextType === "undefined" ? "undefined" : _type_of(contextType)) === 'object' && contextType !== null) {
                    nextContext = readContext(contextType);
                } else {
                    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
                }
                var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
                // ever the previously attempted to render - not the "current". However,
                // during componentDidUpdate we pass the "current" props.
                // In order to support react-lifecycles-compat polyfilled components,
                // Unsafe lifecycles should not be invoked for components using the new APIs.
                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
                    if (oldProps !== newProps || oldContext !== nextContext) {
                        callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
                    }
                }
                resetHasForceUpdateBeforeProcessing();
                var oldState = workInProgress.memoizedState;
                var newState = instance.state = oldState;
                processUpdateQueue(workInProgress, newProps, instance, renderLanes);
                newState = workInProgress.memoizedState;
                if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
                    // If an update was already in progress, we should schedule an Update
                    // effect even though we're bailing out, so that cWU/cDU are called.
                    if (typeof instance.componentDidMount === 'function') {
                        var fiberFlags = Update;
                        {
                            fiberFlags |= LayoutStatic;
                        }
                        if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                            fiberFlags |= MountLayoutDev;
                        }
                        workInProgress.flags |= fiberFlags;
                    }
                    return false;
                }
                if (typeof getDerivedStateFromProps === 'function') {
                    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
                    newState = workInProgress.memoizedState;
                }
                var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);
                if (shouldUpdate) {
                    // In order to support react-lifecycles-compat polyfilled components,
                    // Unsafe lifecycles should not be invoked for components using the new APIs.
                    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
                        if (typeof instance.componentWillMount === 'function') {
                            instance.componentWillMount();
                        }
                        if (typeof instance.UNSAFE_componentWillMount === 'function') {
                            instance.UNSAFE_componentWillMount();
                        }
                    }
                    if (typeof instance.componentDidMount === 'function') {
                        var _fiberFlags = Update;
                        {
                            _fiberFlags |= LayoutStatic;
                        }
                        if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                            _fiberFlags |= MountLayoutDev;
                        }
                        workInProgress.flags |= _fiberFlags;
                    }
                } else {
                    // If an update was already in progress, we should schedule an Update
                    // effect even though we're bailing out, so that cWU/cDU are called.
                    if (typeof instance.componentDidMount === 'function') {
                        var _fiberFlags2 = Update;
                        {
                            _fiberFlags2 |= LayoutStatic;
                        }
                        if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                            _fiberFlags2 |= MountLayoutDev;
                        }
                        workInProgress.flags |= _fiberFlags2;
                    } // If shouldComponentUpdate returned false, we should still update the
                    // memoized state to indicate that this work can be reused.
                    workInProgress.memoizedProps = newProps;
                    workInProgress.memoizedState = newState;
                } // Update the existing instance's state, props, and context pointers even
                // if shouldComponentUpdate returns false.
                instance.props = newProps;
                instance.state = newState;
                instance.context = nextContext;
                return shouldUpdate;
            } // Invokes the update life-cycles and returns false if it shouldn't rerender.
            function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
                var instance = workInProgress.stateNode;
                cloneUpdateQueue(current, workInProgress);
                var unresolvedOldProps = workInProgress.memoizedProps;
                var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
                instance.props = oldProps;
                var unresolvedNewProps = workInProgress.pendingProps;
                var oldContext = instance.context;
                var contextType = ctor.contextType;
                var nextContext = emptyContextObject;
                if ((typeof contextType === "undefined" ? "undefined" : _type_of(contextType)) === 'object' && contextType !== null) {
                    nextContext = readContext(contextType);
                } else {
                    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
                    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
                }
                var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
                // ever the previously attempted to render - not the "current". However,
                // during componentDidUpdate we pass the "current" props.
                // In order to support react-lifecycles-compat polyfilled components,
                // Unsafe lifecycles should not be invoked for components using the new APIs.
                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
                    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                        callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
                    }
                }
                resetHasForceUpdateBeforeProcessing();
                var oldState = workInProgress.memoizedState;
                var newState = instance.state = oldState;
                processUpdateQueue(workInProgress, newProps, instance, renderLanes);
                newState = workInProgress.memoizedState;
                if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && true) {
                    // If an update was already in progress, we should schedule an Update
                    // effect even though we're bailing out, so that cWU/cDU are called.
                    if (typeof instance.componentDidUpdate === 'function') {
                        if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                            workInProgress.flags |= Update;
                        }
                    }
                    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                        if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                            workInProgress.flags |= Snapshot;
                        }
                    }
                    return false;
                }
                if (typeof getDerivedStateFromProps === 'function') {
                    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
                    newState = workInProgress.memoizedState;
                }
                var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
                // both before and after `shouldComponentUpdate` has been called. Not ideal,
                // but I'm loath to refactor this function. This only happens for memoized
                // components so it's not that common.
                enableLazyContextPropagation;
                if (shouldUpdate) {
                    // In order to support react-lifecycles-compat polyfilled components,
                    // Unsafe lifecycles should not be invoked for components using the new APIs.
                    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
                        if (typeof instance.componentWillUpdate === 'function') {
                            instance.componentWillUpdate(newProps, newState, nextContext);
                        }
                        if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
                            instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                        }
                    }
                    if (typeof instance.componentDidUpdate === 'function') {
                        workInProgress.flags |= Update;
                    }
                    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                        workInProgress.flags |= Snapshot;
                    }
                } else {
                    // If an update was already in progress, we should schedule an Update
                    // effect even though we're bailing out, so that cWU/cDU are called.
                    if (typeof instance.componentDidUpdate === 'function') {
                        if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                            workInProgress.flags |= Update;
                        }
                    }
                    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                        if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
                            workInProgress.flags |= Snapshot;
                        }
                    } // If shouldComponentUpdate returned false, we should still update the
                    // memoized props/state to indicate that this work can be reused.
                    workInProgress.memoizedProps = newProps;
                    workInProgress.memoizedState = newState;
                } // Update the existing instance's state, props, and context pointers even
                // if shouldComponentUpdate returns false.
                instance.props = newProps;
                instance.state = newState;
                instance.context = nextContext;
                return shouldUpdate;
            }
            function createCapturedValueAtFiber(value, source) {
                // If the value is an error, call this function immediately after it is thrown
                // so the stack is accurate.
                return {
                    value: value,
                    source: source,
                    stack: getStackByFiberInDevAndProd(source),
                    digest: null
                };
            }
            function createCapturedValue(value, digest, stack) {
                return {
                    value: value,
                    source: null,
                    stack: stack != null ? stack : null,
                    digest: digest != null ? digest : null
                };
            }
            // This module is forked in different environments.
            // By default, return `true` to log errors to the console.
            // Forks can return `false` if this isn't desirable.
            function showErrorDialog(boundary, errorInfo) {
                return true;
            }
            function logCapturedError(boundary, errorInfo) {
                try {
                    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
                    // This enables renderers like ReactNative to better manage redbox behavior.
                    if (logError === false) {
                        return;
                    }
                    var error = errorInfo.value;
                    if (true) {
                        var source = errorInfo.source;
                        var stack = errorInfo.stack;
                        var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
                        // `preventDefault()` in window `error` handler.
                        // We record this information as an expando on the error.
                        if (error != null && error._suppressLogging) {
                            if (boundary.tag === ClassComponent) {
                                // The error is recoverable and was silenced.
                                // Ignore it and don't print the stack addendum.
                                // This is handy for testing error boundaries without noise.
                                return;
                            } // The error is fatal. Since the silencing might have
                            // been accidental, we'll surface it anyway.
                            // However, the browser would have silenced the original error
                            // so we'll print it first, and then print the stack addendum.
                            console['error'](error); // Don't transform to our wrapper
                        // For a more detailed description of this block, see:
                        // https://github.com/facebook/react/pull/13384
                        }
                        var componentName = source ? getComponentNameFromFiber(source) : null;
                        var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
                        var errorBoundaryMessage;
                        if (boundary.tag === HostRoot) {
                            errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';
                        } else {
                            var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous';
                            errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                        }
                        var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
                        // We don't include the original error message and JS stack because the browser
                        // has already printed it. Even if the application swallows the error, it is still
                        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
                        console['error'](combinedMessage); // Don't transform to our wrapper
                    }
                } catch (e) {
                    // This method must not throw, or React internal state will get messed up.
                    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
                    // we want to report this error outside of the normal stack as a last resort.
                    // https://github.com/facebook/react/issues/13188
                    setTimeout(function() {
                        throw e;
                    });
                }
            }
            var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;
            function createRootErrorUpdate(fiber, errorInfo, lane) {
                var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.
                update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
                // being called "element".
                update.payload = {
                    element: null
                };
                var error = errorInfo.value;
                update.callback = function() {
                    onUncaughtError(error);
                    logCapturedError(fiber, errorInfo);
                };
                return update;
            }
            function createClassErrorUpdate(fiber, errorInfo, lane) {
                var update = createUpdate(NoTimestamp, lane);
                update.tag = CaptureUpdate;
                var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
                if (typeof getDerivedStateFromError === 'function') {
                    var error$1 = errorInfo.value;
                    update.payload = function() {
                        return getDerivedStateFromError(error$1);
                    };
                    update.callback = function() {
                        {
                            markFailedErrorBoundaryForHotReloading(fiber);
                        }
                        logCapturedError(fiber, errorInfo);
                    };
                }
                var inst = fiber.stateNode;
                if (inst !== null && typeof inst.componentDidCatch === 'function') {
                    update.callback = function callback() {
                        {
                            markFailedErrorBoundaryForHotReloading(fiber);
                        }
                        logCapturedError(fiber, errorInfo);
                        if (typeof getDerivedStateFromError !== 'function') {
                            // To preserve the preexisting retry behavior of error boundaries,
                            // we keep track of which ones already failed during this batch.
                            // This gets reset before we yield back to the browser.
                            // TODO: Warn in strict mode if getDerivedStateFromError is
                            // not defined.
                            markLegacyErrorBoundaryAsFailed(this);
                        }
                        var error$1 = errorInfo.value;
                        var stack = errorInfo.stack;
                        this.componentDidCatch(error$1, {
                            componentStack: stack !== null ? stack : ''
                        });
                        {
                            if (typeof getDerivedStateFromError !== 'function') {
                                // If componentDidCatch is the only error boundary method defined,
                                // then it needs to call setState to recover from errors.
                                // If no state update is scheduled then the boundary will swallow the error.
                                if (!includesSomeLane(fiber.lanes, SyncLane)) {
                                    error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');
                                }
                            }
                        }
                    };
                }
                return update;
            }
            function attachPingListener(root, wakeable, lanes) {
                // Attach a ping listener
                //
                // The data might resolve before we have a chance to commit the fallback. Or,
                // in the case of a refresh, we'll never commit a fallback. So we need to
                // attach a listener now. When it resolves ("pings"), we can decide whether to
                // try rendering the tree again.
                //
                // Only attach a listener if one does not already exist for the lanes
                // we're currently rendering (which acts like a "thread ID" here).
                //
                // We only need to do this in concurrent mode. Legacy Suspense always
                // commits fallbacks synchronously, so there are no pings.
                var pingCache = root.pingCache;
                var threadIDs;
                if (pingCache === null) {
                    pingCache = root.pingCache = new PossiblyWeakMap$1();
                    threadIDs = new Set();
                    pingCache.set(wakeable, threadIDs);
                } else {
                    threadIDs = pingCache.get(wakeable);
                    if (threadIDs === undefined) {
                        threadIDs = new Set();
                        pingCache.set(wakeable, threadIDs);
                    }
                }
                if (!threadIDs.has(lanes)) {
                    // Memoize using the thread ID to prevent redundant listeners.
                    threadIDs.add(lanes);
                    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
                    {
                        if (isDevToolsPresent) {
                            // If we have pending work still, restore the original updaters
                            restorePendingUpdaters(root, lanes);
                        }
                    }
                    wakeable.then(ping, ping);
                }
            }
            function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {
                // Retry listener
                //
                // If the fallback does commit, we need to attach a different type of
                // listener. This one schedules an update on the Suspense boundary to turn
                // the fallback state off.
                //
                // Stash the wakeable on the boundary fiber so we can access it in the
                // commit phase.
                //
                // When the wakeable resolves, we'll attempt to render the boundary
                // again ("retry").
                var wakeables = suspenseBoundary.updateQueue;
                if (wakeables === null) {
                    var updateQueue = new Set();
                    updateQueue.add(wakeable);
                    suspenseBoundary.updateQueue = updateQueue;
                } else {
                    wakeables.add(wakeable);
                }
            }
            function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
                // A legacy mode Suspense quirk, only relevant to hook components.
                var tag = sourceFiber.tag;
                if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
                    var currentSource = sourceFiber.alternate;
                    if (currentSource) {
                        sourceFiber.updateQueue = currentSource.updateQueue;
                        sourceFiber.memoizedState = currentSource.memoizedState;
                        sourceFiber.lanes = currentSource.lanes;
                    } else {
                        sourceFiber.updateQueue = null;
                        sourceFiber.memoizedState = null;
                    }
                }
            }
            function getNearestSuspenseBoundaryToCapture(returnFiber) {
                var node = returnFiber;
                do {
                    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                        return node;
                    } // This boundary already captured during this render. Continue to the next
                    // boundary.
                    node = node.return;
                }while (node !== null);
                return null;
            }
            function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {
                // This marks a Suspense boundary so that when we're unwinding the stack,
                // it captures the suspended "exception" and does a second (fallback) pass.
                if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
                    // Legacy Mode Suspense
                    //
                    // If the boundary is in legacy mode, we should *not*
                    // suspend the commit. Pretend as if the suspended component rendered
                    // null and keep rendering. When the Suspense boundary completes,
                    // we'll do a second pass to render the fallback.
                    if (suspenseBoundary === returnFiber) {
                        // Special case where we suspended while reconciling the children of
                        // a Suspense boundary's inner Offscreen wrapper fiber. This happens
                        // when a React.lazy component is a direct child of a
                        // Suspense boundary.
                        //
                        // Suspense boundaries are implemented as multiple fibers, but they
                        // are a single conceptual unit. The legacy mode behavior where we
                        // pretend the suspended fiber committed as `null` won't work,
                        // because in this case the "suspended" fiber is the inner
                        // Offscreen wrapper.
                        //
                        // Because the contents of the boundary haven't started rendering
                        // yet (i.e. nothing in the tree has partially rendered) we can
                        // switch to the regular, concurrent mode behavior: mark the
                        // boundary with ShouldCapture and enter the unwind phase.
                        suspenseBoundary.flags |= ShouldCapture;
                    } else {
                        suspenseBoundary.flags |= DidCapture;
                        sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
                        // But we shouldn't call any lifecycle methods or callbacks. Remove
                        // all lifecycle effect tags.
                        sourceFiber.flags &= -52805;
                        if (sourceFiber.tag === ClassComponent) {
                            var currentSourceFiber = sourceFiber.alternate;
                            if (currentSourceFiber === null) {
                                // This is a new mount. Change the tag so it's not mistaken for a
                                // completed class component. For example, we should not call
                                // componentWillUnmount if it is deleted.
                                sourceFiber.tag = IncompleteClassComponent;
                            } else {
                                // When we try rendering again, we should not reuse the current fiber,
                                // since it's known to be in an inconsistent state. Use a force update to
                                // prevent a bail out.
                                var update = createUpdate(NoTimestamp, SyncLane);
                                update.tag = ForceUpdate;
                                enqueueUpdate(sourceFiber, update, SyncLane);
                            }
                        } // The source fiber did not complete. Mark it with Sync priority to
                        // indicate that it still has pending work.
                        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                    }
                    return suspenseBoundary;
                } // Confirmed that the boundary is in a concurrent mode tree. Continue
                // with the normal suspend path.
                //
                // After this we'll use a set of heuristics to determine whether this
                // render pass will run to completion or restart or "suspend" the commit.
                // The actual logic for this is spread out in different places.
                //
                // This first principle is that if we're going to suspend when we complete
                // a root, then we should also restart if we get an update or ping that
                // might unsuspend it, and vice versa. The only reason to suspend is
                // because you think you might want to restart before committing. However,
                // it doesn't make sense to restart only while in the period we're suspended.
                //
                // Restarting too aggressively is also not good because it starves out any
                // intermediate loading state. So we use heuristics to determine when.
                // Suspense Heuristics
                //
                // If nothing threw a Promise or all the same fallbacks are already showing,
                // then don't suspend/restart.
                //
                // If this is an initial render of a new tree of Suspense boundaries and
                // those trigger a fallback, then don't suspend/restart. We want to ensure
                // that we can show the initial loading state as quickly as possible.
                //
                // If we hit a "Delayed" case, such as when we'd switch from content back into
                // a fallback, then we should always suspend/restart. Transitions apply
                // to this case. If none is defined, JND is used instead.
                //
                // If we're already showing a fallback and it gets "retried", allowing us to show
                // another level, but there's still an inner boundary that would show a fallback,
                // then we suspend/restart for 500ms since the last time we showed a fallback
                // anywhere in the tree. This effectively throttles progressive loading into a
                // consistent train of commits. This also gives us an opportunity to restart to
                // get to the completed state slightly earlier.
                //
                // If there's ambiguity due to batching it's resolved in preference of:
                // 1) "delayed", 2) "initial render", 3) "retry".
                //
                // We want to ensure that a "busy" state doesn't get force committed. We want to
                // ensure that new initial loading states can commit as soon as possible.
                suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in
                // the begin phase to prevent an early bailout.
                suspenseBoundary.lanes = rootRenderLanes;
                return suspenseBoundary;
            }
            function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
                // The source fiber did not complete.
                sourceFiber.flags |= Incomplete;
                {
                    if (isDevToolsPresent) {
                        // If we have pending work still, restore the original updaters
                        restorePendingUpdaters(root, rootRenderLanes);
                    }
                }
                if (value !== null && (typeof value === "undefined" ? "undefined" : _type_of(value)) === 'object' && typeof value.then === 'function') {
                    // This is a wakeable. The component suspended.
                    var wakeable = value;
                    resetSuspendedComponent(sourceFiber);
                    {
                        if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                            markDidThrowWhileHydratingDEV();
                        }
                    }
                    var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                    if (suspenseBoundary !== null) {
                        suspenseBoundary.flags &= -257;
                        markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always
                        // commits fallbacks synchronously, so there are no pings.
                        if (suspenseBoundary.mode & ConcurrentMode) {
                            attachPingListener(root, wakeable, rootRenderLanes);
                        }
                        attachRetryListener(suspenseBoundary, root, wakeable);
                        return;
                    } else {
                        // No boundary was found. Unless this is a sync update, this is OK.
                        // We can suspend and wait for more data to arrive.
                        if (!includesSyncLane(rootRenderLanes)) {
                            // This is not a sync update. Suspend. Since we're not activating a
                            // Suspense boundary, this will unwind all the way to the root without
                            // performing a second pass to render a fallback. (This is arguably how
                            // refresh transitions should work, too, since we're not going to commit
                            // the fallbacks anyway.)
                            //
                            // This case also applies to initial hydration.
                            attachPingListener(root, wakeable, rootRenderLanes);
                            renderDidSuspendDelayIfPossible();
                            return;
                        } // This is a sync/discrete update. We treat this case like an error
                        // because discrete renders are expected to produce a complete tree
                        // synchronously to maintain consistency with external state.
                        var uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.'); // If we're outside a transition, fall through to the regular error path.
                        // The error will be caught by the nearest suspense boundary.
                        value = uncaughtSuspenseError;
                    }
                } else {
                    // This is a regular error, not a Suspense wakeable.
                    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                        markDidThrowWhileHydratingDEV();
                        var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by
                        // discarding the dehydrated content and switching to a client render.
                        // Instead of surfacing the error, find the nearest Suspense boundary
                        // and render it again without hydration.
                        if (_suspenseBoundary !== null) {
                            if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                                // Set a flag to indicate that we should try rendering the normal
                                // children again, not the fallback.
                                _suspenseBoundary.flags |= ForceClientRender;
                            }
                            markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should
                            // still log it so it can be fixed.
                            queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                            return;
                        }
                    }
                }
                value = createCapturedValueAtFiber(value, sourceFiber);
                renderDidError(value); // We didn't find a boundary that could handle this type of exception. Start
                // over and traverse parent path again, this time treating the exception
                // as an error.
                var workInProgress = returnFiber;
                do {
                    switch(workInProgress.tag){
                        case HostRoot:
                            {
                                var _errorInfo = value;
                                workInProgress.flags |= ShouldCapture;
                                var lane = pickArbitraryLane(rootRenderLanes);
                                workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
                                var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);
                                enqueueCapturedUpdate(workInProgress, update);
                                return;
                            }
                        case ClassComponent:
                            // Capture and retry
                            var errorInfo = value;
                            var ctor = workInProgress.type;
                            var instance = workInProgress.stateNode;
                            if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                                workInProgress.flags |= ShouldCapture;
                                var _lane = pickArbitraryLane(rootRenderLanes);
                                workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state
                                var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);
                                enqueueCapturedUpdate(workInProgress, _update);
                                return;
                            }
                            break;
                    }
                    workInProgress = workInProgress.return;
                }while (workInProgress !== null);
            }
            function getSuspendedCache() {
                {
                    return null;
                }
            }
            var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
            var didReceiveUpdate = false;
            var didWarnAboutBadClass;
            var didWarnAboutModulePatternComponent;
            var didWarnAboutContextTypeOnFunctionComponent;
            var didWarnAboutGetDerivedStateOnFunctionComponent;
            var didWarnAboutFunctionRefs;
            var didWarnAboutReassigningProps;
            var didWarnAboutRevealOrder;
            var didWarnAboutTailOptions;
            var didWarnAboutDefaultPropsOnFunctionComponent;
            {
                didWarnAboutBadClass = {};
                didWarnAboutModulePatternComponent = {};
                didWarnAboutContextTypeOnFunctionComponent = {};
                didWarnAboutGetDerivedStateOnFunctionComponent = {};
                didWarnAboutFunctionRefs = {};
                didWarnAboutReassigningProps = false;
                didWarnAboutRevealOrder = {};
                didWarnAboutTailOptions = {};
                didWarnAboutDefaultPropsOnFunctionComponent = {};
            }
            function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
                if (current === null) {
                    // If this is a fresh new component that hasn't been rendered yet, we
                    // won't update its child set by applying minimal side-effects. Instead,
                    // we will add them all to the child before it gets rendered. That means
                    // we can optimize this reconciliation pass by not tracking side-effects.
                    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
                } else {
                    // If the current child is the same as the work in progress, it means that
                    // we haven't yet started any work on these children. Therefore, we use
                    // the clone algorithm to create a copy of all the current children.
                    // If we had any progressed work already, that is invalid at this point so
                    // let's throw it out.
                    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
                }
            }
            function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
                // This function is fork of reconcileChildren. It's used in cases where we
                // want to reconcile without matching against the existing set. This has the
                // effect of all current children being unmounted; even if the type and key
                // are the same, the old child is unmounted and a new child is created.
                //
                // To do this, we're going to go through the reconcile algorithm twice. In
                // the first pass, we schedule a deletion for all the current children by
                // passing null.
                workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we
                // pass null in place of where we usually pass the current child set. This has
                // the effect of remounting all children regardless of whether their
                // identities match.
                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
            }
            function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
                // TODO: current can be non-null here even if the component
                // hasn't yet mounted. This happens after the first render suspends.
                // We'll need to figure out if this is fine or can cause issues.
                {
                    if (workInProgress.type !== workInProgress.elementType) {
                        // Lazy component props can't be validated in createElement
                        // because they're only guaranteed to be resolved here.
                        var innerPropTypes = Component.propTypes;
                        if (innerPropTypes) {
                            checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(Component));
                        }
                    }
                }
                var render = Component.render;
                var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
                var nextChildren;
                var hasId;
                prepareToReadContext(workInProgress, renderLanes);
                {
                    markComponentRenderStarted(workInProgress);
                }
                {
                    ReactCurrentOwner$1.current = workInProgress;
                    setIsRendering(true);
                    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
                    hasId = checkDidRenderIdHook();
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
                            hasId = checkDidRenderIdHook();
                        } finally{
                            setIsStrictModeForDevtools(false);
                        }
                    }
                    setIsRendering(false);
                }
                {
                    markComponentRenderStopped();
                }
                if (current !== null && !didReceiveUpdate) {
                    bailoutHooks(current, workInProgress, renderLanes);
                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                }
                if (getIsHydrating() && hasId) {
                    pushMaterializedTreeId(workInProgress);
                } // React DevTools reads this flag.
                workInProgress.flags |= PerformedWork;
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
                if (current === null) {
                    var type = Component.type;
                    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
                    Component.defaultProps === undefined) {
                        var resolvedType = type;
                        {
                            resolvedType = resolveFunctionForHotReloading(type);
                        }
                        // and with only the default shallow comparison, we upgrade it
                        // to a SimpleMemoComponent to allow fast path updates.
                        workInProgress.tag = SimpleMemoComponent;
                        workInProgress.type = resolvedType;
                        {
                            validateFunctionComponentInDev(workInProgress, type);
                        }
                        return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);
                    }
                    {
                        var innerPropTypes = type.propTypes;
                        if (innerPropTypes) {
                            // Inner memo component props aren't currently validated in createElement.
                            // We could move it there, but we'd still need this for lazy code path.
                            checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(type));
                        }
                        if (Component.defaultProps !== undefined) {
                            var componentName = getComponentNameFromType(type) || 'Unknown';
                            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                                error('%s: Support for defaultProps will be removed from memo components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);
                                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                            }
                        }
                    }
                    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
                    child.ref = workInProgress.ref;
                    child.return = workInProgress;
                    workInProgress.child = child;
                    return child;
                }
                {
                    var _type = Component.type;
                    var _innerPropTypes = _type.propTypes;
                    if (_innerPropTypes) {
                        // Inner memo component props aren't currently validated in createElement.
                        // We could move it there, but we'd still need this for lazy code path.
                        checkPropTypes(_innerPropTypes, nextProps, 'prop', getComponentNameFromType(_type));
                    }
                }
                var currentChild = current.child; // This is always exactly one child
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);
                if (!hasScheduledUpdateOrContext) {
                    // This will be the props with resolved defaultProps,
                    // unlike current.memoizedProps which will be the unresolved ones.
                    var prevProps = currentChild.memoizedProps; // Default to shallow comparison
                    var compare = Component.compare;
                    compare = compare !== null ? compare : shallowEqual;
                    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                    }
                } // React DevTools reads this flag.
                workInProgress.flags |= PerformedWork;
                var newChild = createWorkInProgress(currentChild, nextProps);
                newChild.ref = workInProgress.ref;
                newChild.return = workInProgress;
                workInProgress.child = newChild;
                return newChild;
            }
            function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
                // TODO: current can be non-null here even if the component
                // hasn't yet mounted. This happens when the inner render suspends.
                // We'll need to figure out if this is fine or can cause issues.
                {
                    if (workInProgress.type !== workInProgress.elementType) {
                        // Lazy component props can't be validated in createElement
                        // because they're only guaranteed to be resolved here.
                        var outerMemoType = workInProgress.elementType;
                        if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                            // We warn when you define propTypes on lazy()
                            // so let's just skip over it to find memo() outer wrapper.
                            // Inner props for memo are validated later.
                            var lazyComponent = outerMemoType;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                outerMemoType = init(payload);
                            } catch (x) {
                                outerMemoType = null;
                            } // Inner propTypes will be validated in the function component path.
                            var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                            if (outerPropTypes) {
                                checkPropTypes(outerPropTypes, nextProps, 'prop', getComponentNameFromType(outerMemoType));
                            }
                        }
                    }
                }
                if (current !== null) {
                    var prevProps = current.memoizedProps;
                    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {
                        didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we
                        // would during a normal fiber bailout.
                        //
                        // We don't have strong guarantees that the props object is referentially
                        // equal during updates where we can't bail out anyway — like if the props
                        // are shallowly equal, but there's a local state or context update in the
                        // same batch.
                        //
                        // However, as a principle, we should aim to make the behavior consistent
                        // across different ways of memoizing a component. For example, React.memo
                        // has a different internal Fiber layout if you pass a normal function
                        // component (SimpleMemoComponent) versus if you pass a different type
                        // like forwardRef (MemoComponent). But this is an implementation detail.
                        // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't
                        // affect whether the props object is reused during a bailout.
                        workInProgress.pendingProps = nextProps = prevProps;
                        if (!checkScheduledUpdateOrContext(current, renderLanes)) {
                            // The pending lanes were cleared at the beginning of beginWork. We're
                            // about to bail out, but there might be other lanes that weren't
                            // included in the current render. Usually, the priority level of the
                            // remaining updates is accumulated during the evaluation of the
                            // component (i.e. when processing the update queue). But since since
                            // we're bailing out early *without* evaluating the component, we need
                            // to account for it here, too. Reset to the value of the current fiber.
                            // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
                            // because a MemoComponent fiber does not have hooks or an update queue;
                            // rather, it wraps around an inner component, which may or may not
                            // contains hooks.
                            // TODO: Move the reset at in beginWork out of the common path so that
                            // this is no longer necessary.
                            workInProgress.lanes = current.lanes;
                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                        } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                            // This is a special case that only exists for legacy mode.
                            // See https://github.com/facebook/react/pull/19216.
                            didReceiveUpdate = true;
                        }
                    }
                }
                return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
            }
            function updateOffscreenComponent(current, workInProgress, renderLanes) {
                var nextProps = workInProgress.pendingProps;
                var nextChildren = nextProps.children;
                var prevState = current !== null ? current.memoizedState : null;
                if (nextProps.mode === 'hidden' || enableLegacyHidden) {
                    // Rendering a hidden tree.
                    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                        // In legacy sync mode, don't defer the subtree. Render it now.
                        // TODO: Consider how Offscreen should work with transitions in the future
                        var nextState = {
                            baseLanes: NoLanes,
                            cachePool: null,
                            transitions: null
                        };
                        workInProgress.memoizedState = nextState;
                        pushRenderLanes(workInProgress, renderLanes);
                    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
                        var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out
                        // and resume this tree later.
                        var nextBaseLanes;
                        if (prevState !== null) {
                            var prevBaseLanes = prevState.baseLanes;
                            nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
                        } else {
                            nextBaseLanes = renderLanes;
                        } // Schedule this fiber to re-render at offscreen priority. Then bailout.
                        workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
                        var _nextState = {
                            baseLanes: nextBaseLanes,
                            cachePool: spawnedCachePool,
                            transitions: null
                        };
                        workInProgress.memoizedState = _nextState;
                        workInProgress.updateQueue = null;
                        // to avoid a push/pop misalignment.
                        pushRenderLanes(workInProgress, nextBaseLanes);
                        return null;
                    } else {
                        // This is the second render. The surrounding visible content has already
                        // committed. Now we resume rendering the hidden tree.
                        // Rendering at offscreen, so we can clear the base lanes.
                        var _nextState2 = {
                            baseLanes: NoLanes,
                            cachePool: null,
                            transitions: null
                        };
                        workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.
                        var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
                        pushRenderLanes(workInProgress, subtreeRenderLanes);
                    }
                } else {
                    // Rendering a visible tree.
                    var _subtreeRenderLanes;
                    if (prevState !== null) {
                        // We're going from hidden -> visible.
                        _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);
                        workInProgress.memoizedState = null;
                    } else {
                        // We weren't previously hidden, and we still aren't, so there's nothing
                        // special to do. Need to push to the stack regardless, though, to avoid
                        // a push/pop misalignment.
                        _subtreeRenderLanes = renderLanes;
                    }
                    pushRenderLanes(workInProgress, _subtreeRenderLanes);
                }
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            } // Note: These happen to have identical begin phases, for now. We shouldn't hold
            function updateFragment(current, workInProgress, renderLanes) {
                var nextChildren = workInProgress.pendingProps;
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function updateMode(current, workInProgress, renderLanes) {
                var nextChildren = workInProgress.pendingProps.children;
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function updateProfiler(current, workInProgress, renderLanes) {
                {
                    workInProgress.flags |= Update;
                    {
                        // Reset effect durations for the next eventual effect phase.
                        // These are reset during render to allow the DevTools commit hook a chance to read them,
                        var stateNode = workInProgress.stateNode;
                        stateNode.effectDuration = 0;
                        stateNode.passiveEffectDuration = 0;
                    }
                }
                var nextProps = workInProgress.pendingProps;
                var nextChildren = nextProps.children;
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function markRef(current, workInProgress) {
                var ref = workInProgress.ref;
                if (current === null && ref !== null || current !== null && current.ref !== ref) {
                    // Schedule a Ref effect
                    workInProgress.flags |= Ref;
                    {
                        workInProgress.flags |= RefStatic;
                    }
                }
            }
            function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
                {
                    if (workInProgress.type !== workInProgress.elementType) {
                        // Lazy component props can't be validated in createElement
                        // because they're only guaranteed to be resolved here.
                        var innerPropTypes = Component.propTypes;
                        if (innerPropTypes) {
                            checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(Component));
                        }
                    }
                }
                var context;
                {
                    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
                    context = getMaskedContext(workInProgress, unmaskedContext);
                }
                var nextChildren;
                var hasId;
                prepareToReadContext(workInProgress, renderLanes);
                {
                    markComponentRenderStarted(workInProgress);
                }
                {
                    ReactCurrentOwner$1.current = workInProgress;
                    setIsRendering(true);
                    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
                    hasId = checkDidRenderIdHook();
                    if (workInProgress.mode & StrictLegacyMode) {
                        setIsStrictModeForDevtools(true);
                        try {
                            nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
                            hasId = checkDidRenderIdHook();
                        } finally{
                            setIsStrictModeForDevtools(false);
                        }
                    }
                    setIsRendering(false);
                }
                {
                    markComponentRenderStopped();
                }
                if (current !== null && !didReceiveUpdate) {
                    bailoutHooks(current, workInProgress, renderLanes);
                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                }
                if (getIsHydrating() && hasId) {
                    pushMaterializedTreeId(workInProgress);
                } // React DevTools reads this flag.
                workInProgress.flags |= PerformedWork;
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
                {
                    // This is used by DevTools to force a boundary to error.
                    switch(shouldError(workInProgress)){
                        case false:
                            {
                                var _instance = workInProgress.stateNode;
                                var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.
                                // Is there a better way to do this?
                                var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);
                                var state = tempInstance.state;
                                _instance.updater.enqueueSetState(_instance, state, null);
                                break;
                            }
                        case true:
                            {
                                workInProgress.flags |= DidCapture;
                                workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes
                                var error$1 = new Error('Simulated error coming from DevTools');
                                var lane = pickArbitraryLane(renderLanes);
                                workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state
                                var update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error$1, workInProgress), lane);
                                enqueueCapturedUpdate(workInProgress, update);
                                break;
                            }
                    }
                    if (workInProgress.type !== workInProgress.elementType) {
                        // Lazy component props can't be validated in createElement
                        // because they're only guaranteed to be resolved here.
                        var innerPropTypes = Component.propTypes;
                        if (innerPropTypes) {
                            checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentNameFromType(Component));
                        }
                    }
                }
                // During mounting we don't know the child context yet as the instance doesn't exist.
                // We will invalidate the child context in finishClassComponent() right after rendering.
                var hasContext;
                if (isContextProvider(Component)) {
                    hasContext = true;
                    pushContextProvider(workInProgress);
                } else {
                    hasContext = false;
                }
                prepareToReadContext(workInProgress, renderLanes);
                var instance = workInProgress.stateNode;
                var shouldUpdate;
                if (instance === null) {
                    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); // In the initial pass we might need to construct the instance.
                    constructClassInstance(workInProgress, Component, nextProps);
                    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
                    shouldUpdate = true;
                } else if (current === null) {
                    // In a resume, we'll already have an instance we can reuse.
                    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
                } else {
                    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
                }
                var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);
                {
                    var inst = workInProgress.stateNode;
                    if (shouldUpdate && inst.props !== nextProps) {
                        if (!didWarnAboutReassigningProps) {
                            error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');
                        }
                        didWarnAboutReassigningProps = true;
                    }
                }
                return nextUnitOfWork;
            }
            function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
                // Refs should update even if shouldComponentUpdate returns false
                markRef(current, workInProgress);
                var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;
                if (!shouldUpdate && !didCaptureError) {
                    // Context providers should defer to sCU for rendering
                    if (hasContext) {
                        invalidateContextProvider(workInProgress, Component, false);
                    }
                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                }
                var instance = workInProgress.stateNode; // Rerender
                ReactCurrentOwner$1.current = workInProgress;
                var nextChildren;
                if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
                    // If we captured an error, but getDerivedStateFromError is not defined,
                    // unmount all the children. componentDidCatch will schedule an update to
                    // re-render a fallback. This is temporary until we migrate everyone to
                    // the new API.
                    // TODO: Warn in a future release.
                    nextChildren = null;
                    {
                        stopProfilerTimerIfRunning();
                    }
                } else {
                    {
                        markComponentRenderStarted(workInProgress);
                    }
                    {
                        setIsRendering(true);
                        nextChildren = instance.render();
                        if (workInProgress.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                instance.render();
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                        setIsRendering(false);
                    }
                    {
                        markComponentRenderStopped();
                    }
                } // React DevTools reads this flag.
                workInProgress.flags |= PerformedWork;
                if (current !== null && didCaptureError) {
                    // If we're recovering from an error, reconcile without reusing any of
                    // the existing children. Conceptually, the normal children and the children
                    // that are shown on error are two different sets, so we shouldn't reuse
                    // normal children even if their identities match.
                    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
                } else {
                    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                } // Memoize state using the values we just used to render.
                // TODO: Restructure so we never read values from the instance.
                workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.
                if (hasContext) {
                    invalidateContextProvider(workInProgress, Component, true);
                }
                return workInProgress.child;
            }
            function pushHostRootContext(workInProgress) {
                var root = workInProgress.stateNode;
                if (root.pendingContext) {
                    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
                } else if (root.context) {
                    // Should always be set
                    pushTopLevelContextObject(workInProgress, root.context, false);
                }
                pushHostContainer(workInProgress, root.containerInfo);
            }
            function updateHostRoot(current, workInProgress, renderLanes) {
                pushHostRootContext(workInProgress);
                if (current === null) {
                    throw new Error('Should have a current fiber. This is a bug in React.');
                }
                var nextProps = workInProgress.pendingProps;
                var prevState = workInProgress.memoizedState;
                var prevChildren = prevState.element;
                cloneUpdateQueue(current, workInProgress);
                processUpdateQueue(workInProgress, nextProps, null, renderLanes);
                var nextState = workInProgress.memoizedState;
                workInProgress.stateNode;
                // being called "element".
                var nextChildren = nextState.element;
                if (supportsHydration && prevState.isDehydrated) {
                    // This is a hydration root whose shell has not yet hydrated. We should
                    // attempt to hydrate.
                    // Flip isDehydrated to false to indicate that when this render
                    // finishes, the root will no longer be dehydrated.
                    var overrideState = {
                        element: nextChildren,
                        isDehydrated: false,
                        cache: nextState.cache,
                        pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                        transitions: nextState.transitions
                    };
                    var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't
                    // have reducer functions so it doesn't need rebasing.
                    updateQueue.baseState = overrideState;
                    workInProgress.memoizedState = overrideState;
                    if (workInProgress.flags & ForceClientRender) {
                        // Something errored during a previous attempt to hydrate the shell, so we
                        // forced a client render.
                        var recoverableError = createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.'), workInProgress);
                        return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);
                    } else if (nextChildren !== prevChildren) {
                        var _recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);
                        return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);
                    } else {
                        // The outermost shell has not hydrated yet. Start hydrating.
                        enterHydrationState(workInProgress);
                        var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
                        workInProgress.child = child;
                        var node = child;
                        while(node){
                            // Mark each child as hydrating. This is a fast path to know whether this
                            // tree is part of a hydrating tree. This is used to determine if a child
                            // node has fully mounted yet, and for scheduling event replaying.
                            // Conceptually this is similar to Placement in that a new subtree is
                            // inserted into the React tree here. It just happens to not need DOM
                            // mutations because it already exists.
                            node.flags = node.flags & -3 | Hydrating;
                            node = node.sibling;
                        }
                    }
                } else {
                    // Root is not dehydrated. Either this is a client-only root, or it
                    // already hydrated.
                    resetHydrationState();
                    if (nextChildren === prevChildren) {
                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                    }
                    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                }
                return workInProgress.child;
            }
            function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {
                // Revert to client rendering.
                resetHydrationState();
                queueHydrationError(recoverableError);
                workInProgress.flags |= ForceClientRender;
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function updateHostComponent(current, workInProgress, renderLanes) {
                pushHostContext(workInProgress);
                if (current === null) {
                    tryToClaimNextHydratableInstance(workInProgress);
                }
                var type = workInProgress.type;
                var nextProps = workInProgress.pendingProps;
                var prevProps = current !== null ? current.memoizedProps : null;
                var nextChildren = nextProps.children;
                var isDirectTextChild = shouldSetTextContent(type, nextProps);
                if (isDirectTextChild) {
                    // We special case a direct text child of a host node. This is a common
                    // case. We won't handle it as a reified child. We will instead handle
                    // this in the host environment that also has access to this prop. That
                    // avoids allocating another HostText fiber and traversing it.
                    nextChildren = null;
                } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
                    // If we're switching from a direct text child to a normal child, or to
                    // empty, we need to schedule the text content to be reset.
                    workInProgress.flags |= ContentReset;
                }
                markRef(current, workInProgress);
                reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                return workInProgress.child;
            }
            function updateHostText(current, workInProgress) {
                if (current === null) {
                    tryToClaimNextHydratableInstance(workInProgress);
                } // Nothing to do here. This is terminal. We'll do the completion step
                // immediately after.
                return null;
            }
            function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {
                resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);
                var props = workInProgress.pendingProps;
                var lazyComponent = elementType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                var Component = init(payload); // Store the unwrapped component in the type.
                workInProgress.type = Component;
                var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
                var resolvedProps = resolveDefaultProps(Component, props);
                var child;
                switch(resolvedTag){
                    case FunctionComponent:
                        {
                            {
                                validateFunctionComponentInDev(workInProgress, Component);
                                workInProgress.type = Component = resolveFunctionForHotReloading(Component);
                            }
                            child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
                            return child;
                        }
                    case ClassComponent:
                        {
                            {
                                workInProgress.type = Component = resolveClassForHotReloading(Component);
                            }
                            child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
                            return child;
                        }
                    case ForwardRef:
                        {
                            {
                                workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
                            }
                            child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
                            return child;
                        }
                    case MemoComponent:
                        {
                            {
                                if (workInProgress.type !== workInProgress.elementType) {
                                    var outerPropTypes = Component.propTypes;
                                    if (outerPropTypes) {
                                        checkPropTypes(outerPropTypes, resolvedProps, 'prop', getComponentNameFromType(Component));
                                    }
                                }
                            }
                            child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes);
                            return child;
                        }
                }
                var hint = '';
                {
                    if (Component !== null && (typeof Component === "undefined" ? "undefined" : _type_of(Component)) === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
                        hint = ' Did you wrap a component in React.lazy() more than once?';
                    }
                }
                // because the fact that it's a separate type of work is an
                // implementation detail.
                throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
            }
            function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
                resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); // Promote the fiber to a class and try rendering again.
                workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
                // Push context providers early to prevent context stack mismatches.
                // During mounting we don't know the child context yet as the instance doesn't exist.
                // We will invalidate the child context in finishClassComponent() right after rendering.
                var hasContext;
                if (isContextProvider(Component)) {
                    hasContext = true;
                    pushContextProvider(workInProgress);
                } else {
                    hasContext = false;
                }
                prepareToReadContext(workInProgress, renderLanes);
                constructClassInstance(workInProgress, Component, nextProps);
                mountClassInstance(workInProgress, Component, nextProps, renderLanes);
                return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
            }
            function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
                resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);
                var props = workInProgress.pendingProps;
                var context;
                {
                    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
                    context = getMaskedContext(workInProgress, unmaskedContext);
                }
                prepareToReadContext(workInProgress, renderLanes);
                var value;
                var hasId;
                {
                    markComponentRenderStarted(workInProgress);
                }
                {
                    if (Component.prototype && typeof Component.prototype.render === 'function') {
                        var componentName = getComponentNameFromType(Component) || 'Unknown';
                        if (!didWarnAboutBadClass[componentName]) {
                            error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
                            didWarnAboutBadClass[componentName] = true;
                        }
                    }
                    if (workInProgress.mode & StrictLegacyMode) {
                        ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
                    }
                    setIsRendering(true);
                    ReactCurrentOwner$1.current = workInProgress;
                    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
                    hasId = checkDidRenderIdHook();
                    setIsRendering(false);
                }
                {
                    markComponentRenderStopped();
                }
                workInProgress.flags |= PerformedWork;
                {
                    // Support for module components is deprecated and is removed behind a flag.
                    // Whether or not it would crash later, we want to show a good message in DEV first.
                    if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
                        var _componentName = getComponentNameFromType(Component) || 'Unknown';
                        if (!didWarnAboutModulePatternComponent[_componentName]) {
                            error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);
                            didWarnAboutModulePatternComponent[_componentName] = true;
                        }
                    }
                }
                if (// Eventually we'll delete this branch altogether.
                (typeof value === "undefined" ? "undefined" : _type_of(value)) === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
                    {
                        var _componentName2 = getComponentNameFromType(Component) || 'Unknown';
                        if (!didWarnAboutModulePatternComponent[_componentName2]) {
                            error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);
                            didWarnAboutModulePatternComponent[_componentName2] = true;
                        }
                    }
                    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.
                    workInProgress.memoizedState = null;
                    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
                    // During mounting we don't know the child context yet as the instance doesn't exist.
                    // We will invalidate the child context in finishClassComponent() right after rendering.
                    var hasContext = false;
                    if (isContextProvider(Component)) {
                        hasContext = true;
                        pushContextProvider(workInProgress);
                    } else {
                        hasContext = false;
                    }
                    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
                    initializeUpdateQueue(workInProgress);
                    adoptClassInstance(workInProgress, value);
                    mountClassInstance(workInProgress, Component, props, renderLanes);
                    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
                } else {
                    // Proceed under the assumption that this is a function component
                    workInProgress.tag = FunctionComponent;
                    {
                        if (workInProgress.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                                value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
                                hasId = checkDidRenderIdHook();
                            } finally{
                                setIsStrictModeForDevtools(false);
                            }
                        }
                    }
                    if (getIsHydrating() && hasId) {
                        pushMaterializedTreeId(workInProgress);
                    }
                    reconcileChildren(null, workInProgress, value, renderLanes);
                    {
                        validateFunctionComponentInDev(workInProgress, Component);
                    }
                    return workInProgress.child;
                }
            }
            function validateFunctionComponentInDev(workInProgress, Component) {
                {
                    if (Component) {
                        if (Component.childContextTypes) {
                            error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
                        }
                    }
                    if (workInProgress.ref !== null) {
                        var info = '';
                        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                        if (ownerName) {
                            info += '\n\nCheck the render method of `' + ownerName + '`.';
                        }
                        var warningKey = ownerName || '';
                        var debugSource = workInProgress._debugSource;
                        if (debugSource) {
                            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
                        }
                        if (!didWarnAboutFunctionRefs[warningKey]) {
                            didWarnAboutFunctionRefs[warningKey] = true;
                            error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
                        }
                    }
                    if (Component.defaultProps !== undefined) {
                        var componentName = getComponentNameFromType(Component) || 'Unknown';
                        if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                            error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);
                            didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                        }
                    }
                    if (typeof Component.getDerivedStateFromProps === 'function') {
                        var _componentName3 = getComponentNameFromType(Component) || 'Unknown';
                        if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                            error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);
                            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                        }
                    }
                    if (_type_of(Component.contextType) === 'object' && Component.contextType !== null) {
                        var _componentName4 = getComponentNameFromType(Component) || 'Unknown';
                        if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                            error('%s: Function components do not support contextType.', _componentName4);
                            didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                        }
                    }
                }
            }
            var SUSPENDED_MARKER = {
                dehydrated: null,
                treeContext: null,
                retryLane: NoLane
            };
            function mountSuspenseOffscreenState(renderLanes) {
                return {
                    baseLanes: renderLanes,
                    cachePool: getSuspendedCache(),
                    transitions: null
                };
            }
            function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
                var cachePool = null;
                return {
                    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),
                    cachePool: cachePool,
                    transitions: prevOffscreenState.transitions
                };
            } // TODO: Probably should inline this back
            function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
                // If we're already showing a fallback, there are cases where we need to
                // remain on that fallback regardless of whether the content has resolved.
                // For example, SuspenseList coordinates when nested content appears.
                if (current !== null) {
                    var suspenseState = current.memoizedState;
                    if (suspenseState === null) {
                        // Currently showing content. Don't hide it, even if ForceSuspenseFallback
                        // is true. More precise name might be "ForceRemainSuspenseFallback".
                        // Note: This is a factoring smell. Can't remain on a fallback if there's
                        // no fallback to remain on.
                        return false;
                    }
                } // Not currently showing content. Consult the Suspense context.
                return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            }
            function getRemainingWorkInPrimaryTree(current, renderLanes) {
                // TODO: Should not remove render lanes that were pinged during this render
                return removeLanes(current.childLanes, renderLanes);
            }
            function updateSuspenseComponent(current, workInProgress, renderLanes) {
                var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.
                {
                    if (shouldSuspend(workInProgress)) {
                        workInProgress.flags |= DidCapture;
                    }
                }
                var suspenseContext = suspenseStackCursor.current;
                var showFallback = false;
                var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;
                if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
                    // Something in this boundary's subtree already suspended. Switch to
                    // rendering the fallback children.
                    showFallback = true;
                    workInProgress.flags &= -129;
                } else {
                    // Attempting the main content
                    if (current === null || current.memoizedState !== null) {
                        // This is a new mount or this boundary is already showing a fallback state.
                        // Mark this subtree context as having at least one invisible parent that could
                        // handle the fallback state.
                        // Avoided boundaries are not considered since they cannot handle preferred fallback states.
                        {
                            suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                        }
                    }
                }
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
                // boundary's children. This involves some custom reconciliation logic. Two
                // main reasons this is so complicated.
                //
                // First, Legacy Mode has different semantics for backwards compatibility. The
                // primary tree will commit in an inconsistent state, so when we do the
                // second pass to render the fallback, we do some exceedingly, uh, clever
                // hacks to make that not totally break. Like transferring effects and
                // deletions from hidden tree. In Concurrent Mode, it's much simpler,
                // because we bailout on the primary tree completely and leave it in its old
                // state, no effects. Same as what we do for Offscreen (except that
                // Offscreen doesn't have the first render pass).
                //
                // Second is hydration. During hydration, the Suspense fiber has a slightly
                // different layout, where the child points to a dehydrated fragment, which
                // contains the DOM rendered by the server.
                //
                // Third, even if you set all that aside, Suspense is like error boundaries in
                // that we first we try to render one tree, and if that fails, we render again
                // and switch to a different tree. Like a try/catch block. So we have to track
                // which branch we're currently rendering. Ideally we would model this using
                // a stack.
                if (current === null) {
                    // Initial mount
                    // Special path for hydration
                    // If we're currently hydrating, try to hydrate this boundary.
                    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
                    var suspenseState = workInProgress.memoizedState;
                    if (suspenseState !== null) {
                        var dehydrated = suspenseState.dehydrated;
                        if (dehydrated !== null) {
                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);
                        }
                    }
                    var nextPrimaryChildren = nextProps.children;
                    var nextFallbackChildren = nextProps.fallback;
                    if (showFallback) {
                        var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
                        var primaryChildFragment = workInProgress.child;
                        primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
                        workInProgress.memoizedState = SUSPENDED_MARKER;
                        return fallbackFragment;
                    } else {
                        return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);
                    }
                } else {
                    // This is an update.
                    // Special path for hydration
                    var prevState = current.memoizedState;
                    if (prevState !== null) {
                        var _dehydrated = prevState.dehydrated;
                        if (_dehydrated !== null) {
                            return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, _dehydrated, prevState, renderLanes);
                        }
                    }
                    if (showFallback) {
                        var _nextFallbackChildren = nextProps.fallback;
                        var _nextPrimaryChildren = nextProps.children;
                        var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);
                        var _primaryChildFragment2 = workInProgress.child;
                        var prevOffscreenState = current.child.memoizedState;
                        _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
                        _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
                        workInProgress.memoizedState = SUSPENDED_MARKER;
                        return fallbackChildFragment;
                    } else {
                        var _nextPrimaryChildren2 = nextProps.children;
                        var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2, renderLanes);
                        workInProgress.memoizedState = null;
                        return _primaryChildFragment3;
                    }
                }
            }
            function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
                var mode = workInProgress.mode;
                var primaryChildProps = {
                    mode: 'visible',
                    children: primaryChildren
                };
                var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
                primaryChildFragment.return = workInProgress;
                workInProgress.child = primaryChildFragment;
                return primaryChildFragment;
            }
            function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
                var mode = workInProgress.mode;
                var progressedPrimaryFragment = workInProgress.child;
                var primaryChildProps = {
                    mode: 'hidden',
                    children: primaryChildren
                };
                var primaryChildFragment;
                var fallbackChildFragment;
                if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
                    // In legacy mode, we commit the primary tree as if it successfully
                    // completed, even though it's in an inconsistent state.
                    primaryChildFragment = progressedPrimaryFragment;
                    primaryChildFragment.childLanes = NoLanes;
                    primaryChildFragment.pendingProps = primaryChildProps;
                    if (workInProgress.mode & ProfileMode) {
                        // Reset the durations from the first pass so they aren't included in the
                        // final amounts. This seems counterintuitive, since we're intentionally
                        // not measuring part of the render phase, but this makes it match what we
                        // do in Concurrent Mode.
                        primaryChildFragment.actualDuration = 0;
                        primaryChildFragment.actualStartTime = -1;
                        primaryChildFragment.selfBaseDuration = 0;
                        primaryChildFragment.treeBaseDuration = 0;
                    }
                    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
                } else {
                    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
                    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
                }
                primaryChildFragment.return = workInProgress;
                fallbackChildFragment.return = workInProgress;
                primaryChildFragment.sibling = fallbackChildFragment;
                workInProgress.child = primaryChildFragment;
                return fallbackChildFragment;
            }
            function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {
                // The props argument to `createFiberFromOffscreen` is `any` typed, so we use
                // this wrapper function to constrain it.
                return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
            }
            function updateWorkInProgressOffscreenFiber(current, offscreenProps) {
                // The props argument to `createWorkInProgress` is `any` typed, so we use this
                // wrapper function to constrain it.
                return createWorkInProgress(current, offscreenProps);
            }
            function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
                var currentPrimaryChildFragment = current.child;
                var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
                var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
                    mode: 'visible',
                    children: primaryChildren
                });
                if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                    primaryChildFragment.lanes = renderLanes;
                }
                primaryChildFragment.return = workInProgress;
                primaryChildFragment.sibling = null;
                if (currentFallbackChildFragment !== null) {
                    // Delete the fallback child fragment
                    var deletions = workInProgress.deletions;
                    if (deletions === null) {
                        workInProgress.deletions = [
                            currentFallbackChildFragment
                        ];
                        workInProgress.flags |= ChildDeletion;
                    } else {
                        deletions.push(currentFallbackChildFragment);
                    }
                }
                workInProgress.child = primaryChildFragment;
                return primaryChildFragment;
            }
            function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
                var mode = workInProgress.mode;
                var currentPrimaryChildFragment = current.child;
                var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
                var primaryChildProps = {
                    mode: 'hidden',
                    children: primaryChildren
                };
                var primaryChildFragment;
                if (// completed, even though it's in an inconsistent state.
                (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
                // already cloned. In legacy mode, the only case where this isn't true is
                // when DevTools forces us to display a fallback; we skip the first render
                // pass entirely and go straight to rendering the fallback. (In Concurrent
                // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
                // only codepath.)
                workInProgress.child !== currentPrimaryChildFragment) {
                    var progressedPrimaryFragment = workInProgress.child;
                    primaryChildFragment = progressedPrimaryFragment;
                    primaryChildFragment.childLanes = NoLanes;
                    primaryChildFragment.pendingProps = primaryChildProps;
                    if (workInProgress.mode & ProfileMode) {
                        // Reset the durations from the first pass so they aren't included in the
                        // final amounts. This seems counterintuitive, since we're intentionally
                        // not measuring part of the render phase, but this makes it match what we
                        // do in Concurrent Mode.
                        primaryChildFragment.actualDuration = 0;
                        primaryChildFragment.actualStartTime = -1;
                        primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                        primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
                    } // The fallback fiber was added as a deletion during the first pass.
                    // However, since we're going to remain on the fallback, we no longer want
                    // to delete it.
                    workInProgress.deletions = null;
                } else {
                    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.
                    // (We don't do this in legacy mode, because in legacy mode we don't re-use
                    // the current tree; see previous branch.)
                    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
                }
                var fallbackChildFragment;
                if (currentFallbackChildFragment !== null) {
                    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
                } else {
                    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already
                    // mounted but this is a new fiber.
                    fallbackChildFragment.flags |= Placement;
                }
                fallbackChildFragment.return = workInProgress;
                primaryChildFragment.return = workInProgress;
                primaryChildFragment.sibling = fallbackChildFragment;
                workInProgress.child = primaryChildFragment;
                return fallbackChildFragment;
            }
            function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {
                // Falling back to client rendering. Because this has performance
                // implications, it's considered a recoverable error, even though the user
                // likely won't observe anything wrong with the UI.
                //
                // The error is passed in as an argument to enforce that every caller provide
                // a custom message, or explicitly opt out (currently the only path that opts
                // out is legacy mode; every concurrent path provides an error).
                if (recoverableError !== null) {
                    queueHydrationError(recoverableError);
                } // This will add the old fiber to the deletion list
                reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.
                var nextProps = workInProgress.pendingProps;
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already
                // mounted but this is a new fiber.
                primaryChildFragment.flags |= Placement;
                workInProgress.memoizedState = null;
                return primaryChildFragment;
            }
            function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
                var fiberMode = workInProgress.mode;
                var primaryChildProps = {
                    mode: 'visible',
                    children: primaryChildren
                };
                var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
                var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense
                // boundary) already mounted but this is a new fiber.
                fallbackChildFragment.flags |= Placement;
                primaryChildFragment.return = workInProgress;
                fallbackChildFragment.return = workInProgress;
                primaryChildFragment.sibling = fallbackChildFragment;
                workInProgress.child = primaryChildFragment;
                if ((workInProgress.mode & ConcurrentMode) !== NoMode) {
                    // We will have dropped the effect list which contains the
                    // deletion. We need to reconcile to delete the current child.
                    reconcileChildFibers(workInProgress, current.child, null, renderLanes);
                }
                return fallbackChildFragment;
            }
            function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {
                // During the first pass, we'll bail out and not drill into the children.
                // Instead, we'll leave the content in place and try to hydrate it later.
                if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                    {
                        error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');
                    }
                    workInProgress.lanes = laneToLanes(SyncLane);
                } else if (isSuspenseInstanceFallback(suspenseInstance)) {
                    // This is a client-only boundary. Since we won't get any content from the server
                    // for this, we need to schedule that at a higher priority based on when it would
                    // have timed out. In theory we could render it in this pass but it would have the
                    // wrong priority associated with it and will prevent hydration of parent path.
                    // Instead, we'll leave work left on it to render it in a separate commit.
                    // TODO This time should be the time at which the server rendered response that is
                    // a parent to this boundary was displayed. However, since we currently don't have
                    // a protocol to transfer that time, we'll just estimate it by using the current
                    // time. This will mean that Suspense timeouts are slightly shifted to later than
                    // they should be.
                    // Schedule a normal pri update to render this content.
                    workInProgress.lanes = laneToLanes(DefaultHydrationLane);
                } else {
                    // We'll continue hydrating the rest at offscreen priority since we'll already
                    // be showing the right content coming from the server, it is no rush.
                    workInProgress.lanes = laneToLanes(OffscreenLane);
                }
                return null;
            }
            function updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {
                if (!didSuspend) {
                    // This is the first render pass. Attempt to hydrate.
                    // We should never be hydrating at this point because it is the first pass,
                    // but after we've already committed once.
                    warnIfHydrating();
                    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                        return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // required — every concurrent mode path that causes hydration to
                        // de-opt to client rendering should have an error message.
                        null);
                    }
                    if (isSuspenseInstanceFallback(suspenseInstance)) {
                        // This boundary is in a permanent fallback state. In this case, we'll never
                        // get an update and we'll never be able to hydrate the final content. Let's just try the
                        // client side render instead.
                        var digest, message, stack;
                        {
                            var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                            digest = _getSuspenseInstanceF.digest;
                            message = _getSuspenseInstanceF.message;
                            stack = _getSuspenseInstanceF.stack;
                        }
                        var error;
                        if (message) {
                            // eslint-disable-next-line react-internal/prod-error-codes
                            error = new Error(message);
                        } else {
                            error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.');
                        }
                        var capturedValue = createCapturedValue(error, digest, stack);
                        return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);
                    }
                    // any context has changed, we need to treat is as if the input might have changed.
                    var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);
                    if (didReceiveUpdate || hasContextChanged) {
                        // This boundary has changed since the first render. This means that we are now unable to
                        // hydrate it. We might still be able to hydrate it using a higher priority lane.
                        var root = getWorkInProgressRoot();
                        if (root !== null) {
                            var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);
                            if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                                // Intentionally mutating since this render will get interrupted. This
                                // is one of the very rare times where we mutate the current tree
                                // during the render phase.
                                suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render
                                var eventTime = NoTimestamp;
                                enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);
                                scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime);
                            }
                        } // If we have scheduled higher pri work above, this will probably just abort the render
                        // since we now have higher priority work, but in case it doesn't, we need to prepare to
                        // render something, if we time out. Even if that requires us to delete everything and
                        // skip hydration.
                        // Delay having to do this as long as the suspense timeout allows us.
                        renderDidSuspendDelayIfPossible();
                        var _capturedValue = createCapturedValue(new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));
                        return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue);
                    } else if (isSuspenseInstancePending(suspenseInstance)) {
                        // This component is still pending more data from the server, so we can't hydrate its
                        // content. We treat it as if this component suspended itself. It might seem as if
                        // we could just try to render it client-side instead. However, this will perform a
                        // lot of unnecessary work and is unlikely to complete since it often will suspend
                        // on missing data anyway. Additionally, the server might be able to render more
                        // than we can on the client yet. In that case we'd end up with more fallback states
                        // on the client than if we just leave it alone. If the server times out or errors
                        // these should update this boundary to the permanent Fallback state instead.
                        // Mark it as having captured (i.e. suspended).
                        workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.
                        workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.
                        var retry = retryDehydratedSuspenseBoundary.bind(null, current);
                        registerSuspenseInstanceRetry(suspenseInstance, retry);
                        return null;
                    } else {
                        // This is the first attempt.
                        reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);
                        var primaryChildren = nextProps.children;
                        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this
                        // tree is part of a hydrating tree. This is used to determine if a child
                        // node has fully mounted yet, and for scheduling event replaying.
                        // Conceptually this is similar to Placement in that a new subtree is
                        // inserted into the React tree here. It just happens to not need DOM
                        // mutations because it already exists.
                        primaryChildFragment.flags |= Hydrating;
                        return primaryChildFragment;
                    }
                } else {
                    // This is the second render pass. We already attempted to hydrated, but
                    // something either suspended or errored.
                    if (workInProgress.flags & ForceClientRender) {
                        // Something errored during hydration. Try again without hydrating.
                        workInProgress.flags &= -257;
                        var _capturedValue2 = createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));
                        return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue2);
                    } else if (workInProgress.memoizedState !== null) {
                        // Something suspended and we should still be in dehydrated mode.
                        // Leave the existing child in place.
                        workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there
                        // but the normal suspense pass doesn't.
                        workInProgress.flags |= DidCapture;
                        return null;
                    } else {
                        // Suspended but we should no longer be in dehydrated mode.
                        // Therefore we now have to render the fallback.
                        var nextPrimaryChildren = nextProps.children;
                        var nextFallbackChildren = nextProps.fallback;
                        var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
                        var _primaryChildFragment4 = workInProgress.child;
                        _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);
                        workInProgress.memoizedState = SUSPENDED_MARKER;
                        return fallbackChildFragment;
                    }
                }
            }
            function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                var alternate = fiber.alternate;
                if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                }
                scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
            }
            function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
                // Mark any Suspense boundaries with fallbacks as having work to do.
                // If they were previously forced into fallbacks, they may now be able
                // to unblock.
                var node = firstChild;
                while(node !== null){
                    if (node.tag === SuspenseComponent) {
                        var state = node.memoizedState;
                        if (state !== null) {
                            scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);
                        }
                    } else if (node.tag === SuspenseListComponent) {
                        // If the tail is hidden there might not be an Suspense boundaries
                        // to schedule work on. In this case we have to schedule it on the
                        // list itself.
                        // We don't have to traverse to the children of the list since
                        // the list will propagate the change when it rerenders.
                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);
                    } else if (node.child !== null) {
                        node.child.return = node;
                        node = node.child;
                        continue;
                    }
                    if (node === workInProgress) {
                        return;
                    }
                    while(node.sibling === null){
                        if (node.return === null || node.return === workInProgress) {
                            return;
                        }
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                }
            }
            function findLastContentRow(firstChild) {
                // This is going to find the last row among these children that is already
                // showing content on the screen, as opposed to being in fallback state or
                // new. If a row has multiple Suspense boundaries, any of them being in the
                // fallback state, counts as the whole row being in a fallback state.
                // Note that the "rows" will be workInProgress, but any nested children
                // will still be current since we haven't rendered them yet. The mounted
                // order may not be the same as the new order. We use the new order.
                var row = firstChild;
                var lastContentRow = null;
                while(row !== null){
                    var currentRow = row.alternate; // New rows can't be content rows.
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                        lastContentRow = row;
                    }
                    row = row.sibling;
                }
                return lastContentRow;
            }
            function validateRevealOrder(revealOrder) {
                {
                    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
                        didWarnAboutRevealOrder[revealOrder] = true;
                        if (typeof revealOrder === 'string') {
                            switch(revealOrder.toLowerCase()){
                                case 'together':
                                case 'forwards':
                                case 'backwards':
                                    {
                                        error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                                        break;
                                    }
                                case 'forward':
                                case 'backward':
                                    {
                                        error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                                        break;
                                    }
                                default:
                                    error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
                                    break;
                            }
                        } else {
                            error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
                        }
                    }
                }
            }
            function validateTailOptions(tailMode, revealOrder) {
                {
                    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
                        if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
                            didWarnAboutTailOptions[tailMode] = true;
                            error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
                        } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
                            didWarnAboutTailOptions[tailMode] = true;
                            error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
                        }
                    }
                }
            }
            function validateSuspenseListNestedChild(childSlot, index) {
                {
                    var isAnArray = isArray(childSlot);
                    var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';
                    if (isAnArray || isIterable) {
                        var type = isAnArray ? 'array' : 'iterable';
                        error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);
                        return false;
                    }
                }
                return true;
            }
            function validateSuspenseListChildren(children, revealOrder) {
                {
                    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
                        if (isArray(children)) {
                            for(var i = 0; i < children.length; i++){
                                if (!validateSuspenseListNestedChild(children[i], i)) {
                                    return;
                                }
                            }
                        } else {
                            var iteratorFn = getIteratorFn(children);
                            if (typeof iteratorFn === 'function') {
                                var childrenIterator = iteratorFn.call(children);
                                if (childrenIterator) {
                                    var step = childrenIterator.next();
                                    var _i = 0;
                                    for(; !step.done; step = childrenIterator.next()){
                                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                                            return;
                                        }
                                        _i++;
                                    }
                                }
                            } else {
                                error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);
                            }
                        }
                    }
                }
            }
            function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
                var renderState = workInProgress.memoizedState;
                if (renderState === null) {
                    workInProgress.memoizedState = {
                        isBackwards: isBackwards,
                        rendering: null,
                        renderingStartTime: 0,
                        last: lastContentRow,
                        tail: tail,
                        tailMode: tailMode
                    };
                } else {
                    // We can reuse the existing object from previous renders.
                    renderState.isBackwards = isBackwards;
                    renderState.rendering = null;
                    renderState.renderingStartTime = 0;
                    renderState.last = lastContentRow;
                    renderState.tail = tail;
                    renderState.tailMode = tailMode;
                }
            } // This can end up rendering this component multiple passes.
            // The first pass splits the children fibers into two sets. A head and tail.
            // We first render the head. If anything is in fallback state, we do another
            // pass through beginWork to rerender all children (including the tail) with
            // the force suspend context. If the first render didn't have anything in
            // in fallback state. Then we render each row in the tail one-by-one.
            // That happens in the completeWork phase without going back to beginWork.
            function updateSuspenseListComponent(current, workInProgress, renderLanes) {
                var nextProps = workInProgress.pendingProps;
                var revealOrder = nextProps.revealOrder;
                var tailMode = nextProps.tail;
                var newChildren = nextProps.children;
                validateRevealOrder(revealOrder);
                validateTailOptions(tailMode, revealOrder);
                validateSuspenseListChildren(newChildren, revealOrder);
                reconcileChildren(current, workInProgress, newChildren, renderLanes);
                var suspenseContext = suspenseStackCursor.current;
                var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
                if (shouldForceFallback) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                    workInProgress.flags |= DidCapture;
                } else {
                    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;
                    if (didSuspendBefore) {
                        // If we previously forced a fallback, we need to schedule work
                        // on any nested boundaries to let them know to try to render
                        // again. This is the same as context updating.
                        propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
                    }
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress, suspenseContext);
                if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                    // In legacy mode, SuspenseList doesn't work so we just
                    // use make it a noop by treating it as the default revealOrder.
                    workInProgress.memoizedState = null;
                } else {
                    switch(revealOrder){
                        case 'forwards':
                            {
                                var lastContentRow = findLastContentRow(workInProgress.child);
                                var tail;
                                if (lastContentRow === null) {
                                    // The whole list is part of the tail.
                                    // TODO: We could fast path by just rendering the tail now.
                                    tail = workInProgress.child;
                                    workInProgress.child = null;
                                } else {
                                    // Disconnect the tail rows after the content row.
                                    // We're going to render them separately later.
                                    tail = lastContentRow.sibling;
                                    lastContentRow.sibling = null;
                                }
                                initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);
                                break;
                            }
                        case 'backwards':
                            {
                                // We're going to find the first row that has existing content.
                                // At the same time we're going to reverse the list of everything
                                // we pass in the meantime. That's going to be our tail in reverse
                                // order.
                                var _tail = null;
                                var row = workInProgress.child;
                                workInProgress.child = null;
                                while(row !== null){
                                    var currentRow = row.alternate; // New rows can't be content rows.
                                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                                        // This is the beginning of the main content.
                                        workInProgress.child = row;
                                        break;
                                    }
                                    var nextRow = row.sibling;
                                    row.sibling = _tail;
                                    _tail = row;
                                    row = nextRow;
                                } // TODO: If workInProgress.child is null, we can continue on the tail immediately.
                                initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);
                                break;
                            }
                        case 'together':
                            {
                                initSuspenseListRenderState(workInProgress, false, null, null, undefined);
                                break;
                            }
                        default:
                            {
                                // The default reveal order is the same as not having
                                // a boundary.
                                workInProgress.memoizedState = null;
                            }
                    }
                }
                return workInProgress.child;
            }
            function updatePortalComponent(current, workInProgress, renderLanes) {
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                var nextChildren = workInProgress.pendingProps;
                if (current === null) {
                    // Portals are special because we don't append the children during mount
                    // but at commit. Therefore we need to track insertions which the normal
                    // flow doesn't do during mount. This doesn't happen at the root because
                    // the root always starts with a "current" with a null child.
                    // TODO: Consider unifying this with how the root works.
                    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
                } else {
                    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
                }
                return workInProgress.child;
            }
            var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
            function updateContextProvider(current, workInProgress, renderLanes) {
                var providerType = workInProgress.type;
                var context = providerType._context;
                var newProps = workInProgress.pendingProps;
                var oldProps = workInProgress.memoizedProps;
                var newValue = newProps.value;
                {
                    if (!('value' in newProps)) {
                        if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                            hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                            error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
                        }
                    }
                    var providerPropTypes = workInProgress.type.propTypes;
                    if (providerPropTypes) {
                        checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
                    }
                }
                pushProvider(workInProgress, context, newValue);
                {
                    if (oldProps !== null) {
                        var oldValue = oldProps.value;
                        if (objectIs(oldValue, newValue)) {
                            // No change. Bailout early if children are the same.
                            if (oldProps.children === newProps.children && !hasContextChanged()) {
                                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                            }
                        } else {
                            // The context value changed. Search for matching consumers and schedule
                            // them to update.
                            propagateContextChange(workInProgress, context, renderLanes);
                        }
                    }
                }
                var newChildren = newProps.children;
                reconcileChildren(current, workInProgress, newChildren, renderLanes);
                return workInProgress.child;
            }
            var hasWarnedAboutUsingContextAsConsumer = false;
            function updateContextConsumer(current, workInProgress, renderLanes) {
                var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
                // DEV mode, we create a separate object for Context.Consumer that acts
                // like a proxy to Context. This proxy object adds unnecessary code in PROD
                // so we use the old behaviour (Context.Consumer references Context) to
                // reduce size and overhead. The separate object references context via
                // a property called "_context", which also gives us the ability to check
                // in DEV mode if this property exists or not and warn if it does not.
                {
                    if (context._context === undefined) {
                        // This may be because it's a Context (rather than a Consumer).
                        // Or it may be because it's older React where they're the same thing.
                        // We only want to warn if we're sure it's a new React.
                        if (context !== context.Consumer) {
                            if (!hasWarnedAboutUsingContextAsConsumer) {
                                hasWarnedAboutUsingContextAsConsumer = true;
                                error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                            }
                        }
                    } else {
                        context = context._context;
                    }
                }
                var newProps = workInProgress.pendingProps;
                var render = newProps.children;
                {
                    if (typeof render !== 'function') {
                        error('A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
                    }
                }
                prepareToReadContext(workInProgress, renderLanes);
                var newValue = readContext(context);
                {
                    markComponentRenderStarted(workInProgress);
                }
                var newChildren;
                {
                    ReactCurrentOwner$1.current = workInProgress;
                    setIsRendering(true);
                    newChildren = render(newValue);
                    setIsRendering(false);
                }
                {
                    markComponentRenderStopped();
                }
                workInProgress.flags |= PerformedWork;
                reconcileChildren(current, workInProgress, newChildren, renderLanes);
                return workInProgress.child;
            }
            function markWorkInProgressReceivedUpdate() {
                didReceiveUpdate = true;
            }
            function resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {
                if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                    if (current !== null) {
                        // A lazy component only mounts if it suspended inside a non-
                        // concurrent tree, in an inconsistent state. We want to treat it like
                        // a new mount, even though an empty version of it already committed.
                        // Disconnect the alternate pointers.
                        current.alternate = null;
                        workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
                        workInProgress.flags |= Placement;
                    }
                }
            }
            function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
                if (current !== null) {
                    // Reuse previous dependencies
                    workInProgress.dependencies = current.dependencies;
                }
                {
                    // Don't update "base" render times for bailouts.
                    stopProfilerTimerIfRunning();
                }
                markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.
                if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
                    // The children don't have any work either. We can skip them.
                    // TODO: Once we add back resuming, we should check if the children are
                    // a work-in-progress set. If so, we need to transfer their effects.
                    {
                        return null;
                    }
                } // This fiber doesn't have work, but its subtree does. Clone the child
                // fibers and continue.
                cloneChildFibers(current, workInProgress);
                return workInProgress.child;
            }
            function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
                {
                    var returnFiber = oldWorkInProgress.return;
                    if (returnFiber === null) {
                        // eslint-disable-next-line react-internal/prod-error-codes
                        throw new Error('Cannot swap the root fiber.');
                    } // Disconnect from the old current.
                    // It will get deleted.
                    current.alternate = null;
                    oldWorkInProgress.alternate = null; // Connect to the new tree.
                    newWorkInProgress.index = oldWorkInProgress.index;
                    newWorkInProgress.sibling = oldWorkInProgress.sibling;
                    newWorkInProgress.return = oldWorkInProgress.return;
                    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.
                    if (oldWorkInProgress === returnFiber.child) {
                        returnFiber.child = newWorkInProgress;
                    } else {
                        var prevSibling = returnFiber.child;
                        if (prevSibling === null) {
                            // eslint-disable-next-line react-internal/prod-error-codes
                            throw new Error('Expected parent to have a child.');
                        }
                        while(prevSibling.sibling !== oldWorkInProgress){
                            prevSibling = prevSibling.sibling;
                            if (prevSibling === null) {
                                // eslint-disable-next-line react-internal/prod-error-codes
                                throw new Error('Expected to find the previous sibling.');
                            }
                        }
                        prevSibling.sibling = newWorkInProgress;
                    } // Delete the old fiber and place the new one.
                    // Since the old fiber is disconnected, we have to schedule it manually.
                    var deletions = returnFiber.deletions;
                    if (deletions === null) {
                        returnFiber.deletions = [
                            current
                        ];
                        returnFiber.flags |= ChildDeletion;
                    } else {
                        deletions.push(current);
                    }
                    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.
                    return newWorkInProgress;
                }
            }
            function checkScheduledUpdateOrContext(current, renderLanes) {
                // Before performing an early bailout, we must check if there are pending
                // updates or context.
                var updateLanes = current.lanes;
                if (includesSomeLane(updateLanes, renderLanes)) {
                    return true;
                } // No pending update, but because context is propagated lazily, we need
                return false;
            }
            function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
                // This fiber does not have any pending work. Bailout without entering
                // the begin phase. There's still some bookkeeping we that needs to be done
                // in this optimized path, mostly pushing stuff onto the stack.
                switch(workInProgress.tag){
                    case HostRoot:
                        pushHostRootContext(workInProgress);
                        workInProgress.stateNode;
                        resetHydrationState();
                        break;
                    case HostComponent:
                        pushHostContext(workInProgress);
                        break;
                    case ClassComponent:
                        {
                            var Component = workInProgress.type;
                            if (isContextProvider(Component)) {
                                pushContextProvider(workInProgress);
                            }
                            break;
                        }
                    case HostPortal:
                        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                        break;
                    case ContextProvider:
                        {
                            var newValue = workInProgress.memoizedProps.value;
                            var context = workInProgress.type._context;
                            pushProvider(workInProgress, context, newValue);
                            break;
                        }
                    case Profiler:
                        {
                            // Profiler should only call onRender when one of its descendants actually rendered.
                            var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);
                            if (hasChildWork) {
                                workInProgress.flags |= Update;
                            }
                            {
                                // Reset effect durations for the next eventual effect phase.
                                // These are reset during render to allow the DevTools commit hook a chance to read them,
                                var stateNode = workInProgress.stateNode;
                                stateNode.effectDuration = 0;
                                stateNode.passiveEffectDuration = 0;
                            }
                        }
                        break;
                    case SuspenseComponent:
                        {
                            var state = workInProgress.memoizedState;
                            if (state !== null) {
                                if (state.dehydrated !== null) {
                                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has
                                    // been unsuspended it has committed as a resolved Suspense component.
                                    // If it needs to be retried, it should have work scheduled on it.
                                    workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we
                                    // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.
                                    return null;
                                } // If this boundary is currently timed out, we need to decide
                                // whether to retry the primary children, or to skip over it and
                                // go straight to the fallback. Check the priority of the primary
                                // child fragment.
                                var primaryChildFragment = workInProgress.child;
                                var primaryChildLanes = primaryChildFragment.childLanes;
                                if (includesSomeLane(renderLanes, primaryChildLanes)) {
                                    // The primary children have pending work. Use the normal path
                                    // to attempt to render the primary children again.
                                    return updateSuspenseComponent(current, workInProgress, renderLanes);
                                } else {
                                    // The primary child fragment does not have pending work marked
                                    // on it
                                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                                    // priority. Bailout.
                                    var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                                    if (child !== null) {
                                        // The fallback children have pending work. Skip over the
                                        // primary children and work on the fallback.
                                        return child.sibling;
                                    } else {
                                        // Note: We can return `null` here because we already checked
                                        // whether there were nested context consumers, via the call to
                                        // `bailoutOnAlreadyFinishedWork` above.
                                        return null;
                                    }
                                }
                            } else {
                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                            }
                            break;
                        }
                    case SuspenseListComponent:
                        {
                            var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;
                            var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);
                            if (didSuspendBefore) {
                                if (_hasChildWork) {
                                    // If something was in fallback state last time, and we have all the
                                    // same children then we're still in progressive loading state.
                                    // Something might get unblocked by state updates or retries in the
                                    // tree which will affect the tail. So we need to use the normal
                                    // path to compute the correct tail.
                                    return updateSuspenseListComponent(current, workInProgress, renderLanes);
                                } // If none of the children had any work, that means that none of
                                // them got retried so they'll still be blocked in the same way
                                // as before. We can fast bail out.
                                workInProgress.flags |= DidCapture;
                            } // If nothing suspended before and we're rendering the same children,
                            // then the tail doesn't matter. Anything new that suspends will work
                            // in the "together" mode, so we can continue from the state we had.
                            var renderState = workInProgress.memoizedState;
                            if (renderState !== null) {
                                // Reset to the "together" mode in case we've started a different
                                // update in the past but didn't complete it.
                                renderState.rendering = null;
                                renderState.tail = null;
                                renderState.lastEffect = null;
                            }
                            pushSuspenseContext(workInProgress, suspenseStackCursor.current);
                            if (_hasChildWork) {
                                break;
                            } else {
                                // If none of the children had any work, that means that none of
                                // them got retried so they'll still be blocked in the same way
                                // as before. We can fast bail out.
                                return null;
                            }
                        }
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                        {
                            // Need to check if the tree still needs to be deferred. This is
                            // almost identical to the logic used in the normal update path,
                            // so we'll just enter that. The only difference is we'll bail out
                            // at the next level instead of this one, because the child props
                            // have not changed. Which is fine.
                            // TODO: Probably should refactor `beginWork` to split the bailout
                            // path from the normal path. I'm tempted to do a labeled break here
                            // but I won't :)
                            workInProgress.lanes = NoLanes;
                            return updateOffscreenComponent(current, workInProgress, renderLanes);
                        }
                }
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            }
            function beginWork(current, workInProgress, renderLanes) {
                {
                    if (workInProgress._debugNeedsRemount && current !== null) {
                        // This will restart the begin phase with a new fiber.
                        return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
                    }
                }
                if (current !== null) {
                    var oldProps = current.memoizedProps;
                    var newProps = workInProgress.pendingProps;
                    if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {
                        // If props or context changed, mark the fiber as having performed work.
                        // This may be unset if the props are determined to be equal later (memo).
                        didReceiveUpdate = true;
                    } else {
                        // Neither props nor legacy context changes. Check if there's a pending
                        // update or context change.
                        var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);
                        if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                        // may not be work scheduled on `current`, so we check for this flag.
                        (workInProgress.flags & DidCapture) === NoFlags) {
                            // No pending updates or context. Bail out now.
                            didReceiveUpdate = false;
                            return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
                        }
                        if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                            // This is a special case that only exists for legacy mode.
                            // See https://github.com/facebook/react/pull/19216.
                            didReceiveUpdate = true;
                        } else {
                            // An update was scheduled on this fiber, but there are no new props
                            // nor legacy context. Set this to false. If an update queue or context
                            // consumer produces a changed value, it will set this to true. Otherwise,
                            // the component will assume the children have not changed and bail out.
                            didReceiveUpdate = false;
                        }
                    }
                } else {
                    didReceiveUpdate = false;
                    if (getIsHydrating() && isForkedChild(workInProgress)) {
                        // Check if this child belongs to a list of muliple children in
                        // its parent.
                        //
                        // In a true multi-threaded implementation, we would render children on
                        // parallel threads. This would represent the beginning of a new render
                        // thread for this subtree.
                        //
                        // We only use this for id generation during hydration, which is why the
                        // logic is located in this special branch.
                        var slotIndex = workInProgress.index;
                        var numberOfForks = getForksAtLevel();
                        pushTreeId(workInProgress, numberOfForks, slotIndex);
                    }
                } // Before entering the begin phase, clear pending update priority.
                // TODO: This assumes that we're about to evaluate the component and process
                // the update queue. However, there's an exception: SimpleMemoComponent
                // sometimes bails out later in the begin phase. This indicates that we should
                // move this assignment out of the common path and into each branch.
                workInProgress.lanes = NoLanes;
                switch(workInProgress.tag){
                    case IndeterminateComponent:
                        {
                            return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
                        }
                    case LazyComponent:
                        {
                            var elementType = workInProgress.elementType;
                            return mountLazyComponent(current, workInProgress, elementType, renderLanes);
                        }
                    case FunctionComponent:
                        {
                            var Component = workInProgress.type;
                            var unresolvedProps = workInProgress.pendingProps;
                            var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
                            return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);
                        }
                    case ClassComponent:
                        {
                            var _Component = workInProgress.type;
                            var _unresolvedProps = workInProgress.pendingProps;
                            var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                            return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);
                        }
                    case HostRoot:
                        return updateHostRoot(current, workInProgress, renderLanes);
                    case HostComponent:
                        return updateHostComponent(current, workInProgress, renderLanes);
                    case HostText:
                        return updateHostText(current, workInProgress);
                    case SuspenseComponent:
                        return updateSuspenseComponent(current, workInProgress, renderLanes);
                    case HostPortal:
                        return updatePortalComponent(current, workInProgress, renderLanes);
                    case ForwardRef:
                        {
                            var type = workInProgress.type;
                            var _unresolvedProps2 = workInProgress.pendingProps;
                            var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                            return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
                        }
                    case Fragment:
                        return updateFragment(current, workInProgress, renderLanes);
                    case Mode:
                        return updateMode(current, workInProgress, renderLanes);
                    case Profiler:
                        return updateProfiler(current, workInProgress, renderLanes);
                    case ContextProvider:
                        return updateContextProvider(current, workInProgress, renderLanes);
                    case ContextConsumer:
                        return updateContextConsumer(current, workInProgress, renderLanes);
                    case MemoComponent:
                        {
                            var _type2 = workInProgress.type;
                            var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.
                            var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                            {
                                if (workInProgress.type !== workInProgress.elementType) {
                                    var outerPropTypes = _type2.propTypes;
                                    if (outerPropTypes) {
                                        checkPropTypes(outerPropTypes, _resolvedProps3, 'prop', getComponentNameFromType(_type2));
                                    }
                                }
                            }
                            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                            return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);
                        }
                    case SimpleMemoComponent:
                        {
                            return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
                        }
                    case IncompleteClassComponent:
                        {
                            var _Component2 = workInProgress.type;
                            var _unresolvedProps4 = workInProgress.pendingProps;
                            var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                            return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);
                        }
                    case SuspenseListComponent:
                        {
                            return updateSuspenseListComponent(current, workInProgress, renderLanes);
                        }
                    case ScopeComponent:
                        {
                            break;
                        }
                    case OffscreenComponent:
                        {
                            return updateOffscreenComponent(current, workInProgress, renderLanes);
                        }
                }
                throw new Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in " + 'React. Please file an issue.');
            }
            function markUpdate(workInProgress) {
                // Tag the fiber with an update effect. This turns a Placement into
                // a PlacementAndUpdate.
                workInProgress.flags |= Update;
            }
            function markRef$1(workInProgress) {
                workInProgress.flags |= Ref;
                {
                    workInProgress.flags |= RefStatic;
                }
            }
            function hadNoMutationsEffects(current, completedWork) {
                var didBailout = current !== null && current.child === completedWork.child;
                if (didBailout) {
                    return true;
                }
                if ((completedWork.flags & ChildDeletion) !== NoFlags) {
                    return false;
                } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`
                // then we only have to check the `completedWork.subtreeFlags`.
                var child = completedWork.child;
                while(child !== null){
                    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {
                        return false;
                    }
                    child = child.sibling;
                }
                return true;
            }
            var appendAllChildren;
            var updateHostContainer;
            var updateHostComponent$1;
            var updateHostText$1;
            if (supportsMutation) {
                // Mutation mode
                appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
                    // We only have the top Fiber that was created but we need recurse down its
                    // children to find all the terminal nodes.
                    var node = workInProgress.child;
                    while(node !== null){
                        if (node.tag === HostComponent || node.tag === HostText) {
                            appendInitialChild(parent, node.stateNode);
                        } else if (node.tag === HostPortal) ;
                        else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        }
                        if (node === workInProgress) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === workInProgress) {
                                return;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                };
                updateHostContainer = function updateHostContainer(current, workInProgress) {};
                updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
                    // If we have an alternate, that means this is an update and we need to
                    // schedule a side-effect to do the updates.
                    var oldProps = current.memoizedProps;
                    if (oldProps === newProps) {
                        // In mutation mode, this is sufficient for a bailout because
                        // we won't touch this node even if children changed.
                        return;
                    } // If we get updated because one of our children updated, we don't
                    // have newProps so we'll have to reuse them.
                    // TODO: Split the update API as separate for the props vs. children.
                    // Even better would be if children weren't special cased at all tho.
                    var instance = workInProgress.stateNode;
                    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
                    // component is hitting the resume path. Figure out why. Possibly
                    // related to `hidden`.
                    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.
                    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
                    // is a new ref we mark this as an update. All the work is done in commitWork.
                    if (updatePayload) {
                        markUpdate(workInProgress);
                    }
                };
                updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
                    // If the text differs, mark it as an update. All the work in done in commitWork.
                    if (oldText !== newText) {
                        markUpdate(workInProgress);
                    }
                };
            } else if (supportsPersistence) {
                // Persistent host tree mode
                appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {
                    // We only have the top Fiber that was created but we need recurse down its
                    // children to find all the terminal nodes.
                    var node = workInProgress.child;
                    while(node !== null){
                        // eslint-disable-next-line no-labels
                        if (node.tag === HostComponent) {
                            var instance = node.stateNode;
                            if (needsVisibilityToggle && isHidden) {
                                // This child is inside a timed out tree. Hide it.
                                var props = node.memoizedProps;
                                var type = node.type;
                                instance = cloneHiddenInstance(instance, type, props, node);
                            }
                            appendInitialChild(parent, instance);
                        } else if (node.tag === HostText) {
                            var _instance = node.stateNode;
                            if (needsVisibilityToggle && isHidden) {
                                // This child is inside a timed out tree. Hide it.
                                var text = node.memoizedProps;
                                _instance = cloneHiddenTextInstance(_instance, text, node);
                            }
                            appendInitialChild(parent, _instance);
                        } else if (node.tag === HostPortal) ;
                        else if (node.tag === OffscreenComponent && node.memoizedState !== null) {
                            // The children in this boundary are hidden. Toggle their visibility
                            // before appending.
                            var child = node.child;
                            if (child !== null) {
                                child.return = node;
                            }
                            appendAllChildren(parent, node, true, true);
                        } else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        } // $FlowFixMe This is correct but Flow is confused by the labeled break.
                        node = node;
                        if (node === workInProgress) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === workInProgress) {
                                return;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                }; // An unfortunate fork of appendAllChildren because we have two different parent types.
                var appendAllChildrenToContainer = function appendAllChildrenToContainer1(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
                    // We only have the top Fiber that was created but we need recurse down its
                    // children to find all the terminal nodes.
                    var node = workInProgress.child;
                    while(node !== null){
                        // eslint-disable-next-line no-labels
                        if (node.tag === HostComponent) {
                            var instance = node.stateNode;
                            if (needsVisibilityToggle && isHidden) {
                                // This child is inside a timed out tree. Hide it.
                                var props = node.memoizedProps;
                                var type = node.type;
                                instance = cloneHiddenInstance(instance, type, props, node);
                            }
                            appendChildToContainerChildSet(containerChildSet, instance);
                        } else if (node.tag === HostText) {
                            var _instance2 = node.stateNode;
                            if (needsVisibilityToggle && isHidden) {
                                // This child is inside a timed out tree. Hide it.
                                var text = node.memoizedProps;
                                _instance2 = cloneHiddenTextInstance(_instance2, text, node);
                            }
                            appendChildToContainerChildSet(containerChildSet, _instance2);
                        } else if (node.tag === HostPortal) ;
                        else if (node.tag === OffscreenComponent && node.memoizedState !== null) {
                            // The children in this boundary are hidden. Toggle their visibility
                            // before appending.
                            var child = node.child;
                            if (child !== null) {
                                child.return = node;
                            }
                            appendAllChildrenToContainer(containerChildSet, node, true, true);
                        } else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        } // $FlowFixMe This is correct but Flow is confused by the labeled break.
                        node = node;
                        if (node === workInProgress) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === workInProgress) {
                                return;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                };
                updateHostContainer = function updateHostContainer(current, workInProgress) {
                    var portalOrRoot = workInProgress.stateNode;
                    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);
                    if (childrenUnchanged) ;
                    else {
                        var container = portalOrRoot.containerInfo;
                        var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.
                        appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
                        portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.
                        markUpdate(workInProgress);
                        finalizeContainerChildren(container, newChildSet);
                    }
                };
                updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
                    var currentInstance = current.stateNode;
                    var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.
                    // This guarantees that we can reuse all of them.
                    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);
                    if (childrenUnchanged && oldProps === newProps) {
                        // No changes, just reuse the existing instance.
                        // Note that this might release a previous clone.
                        workInProgress.stateNode = currentInstance;
                        return;
                    }
                    var recyclableInstance = workInProgress.stateNode;
                    var currentHostContext = getHostContext();
                    var updatePayload = null;
                    if (oldProps !== newProps) {
                        updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
                    }
                    if (childrenUnchanged && updatePayload === null) {
                        // No changes, just reuse the existing instance.
                        // Note that this might release a previous clone.
                        workInProgress.stateNode = currentInstance;
                        return;
                    }
                    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
                    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
                        markUpdate(workInProgress);
                    }
                    workInProgress.stateNode = newInstance;
                    if (childrenUnchanged) {
                        // If there are no other effects in this tree, we need to flag this node as having one.
                        // Even though we're not going to use it for anything.
                        // Otherwise parents won't know that there are new children to propagate upwards.
                        markUpdate(workInProgress);
                    } else {
                        // If children might have changed, we have to add them all to the set.
                        appendAllChildren(newInstance, workInProgress, false, false);
                    }
                };
                updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
                    if (oldText !== newText) {
                        // If the text content differs, we'll create a new text instance for it.
                        var rootContainerInstance = getRootHostContainer();
                        var currentHostContext = getHostContext();
                        workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.
                        // This lets the parents know that at least one of their children has changed.
                        markUpdate(workInProgress);
                    } else {
                        workInProgress.stateNode = current.stateNode;
                    }
                };
            } else {
                // No host operations
                updateHostContainer = function updateHostContainer(current, workInProgress) {};
                updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};
                updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};
            }
            function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
                if (getIsHydrating()) {
                    // If we're hydrating, we should consume as many items as we can
                    // so we don't leave any behind.
                    return;
                }
                switch(renderState.tailMode){
                    case 'hidden':
                        {
                            // Any insertions at the end of the tail list after this point
                            // should be invisible. If there are already mounted boundaries
                            // anything before them are not considered for collapsing.
                            // Therefore we need to go through the whole tail to find if
                            // there are any.
                            var tailNode = renderState.tail;
                            var lastTailNode = null;
                            while(tailNode !== null){
                                if (tailNode.alternate !== null) {
                                    lastTailNode = tailNode;
                                }
                                tailNode = tailNode.sibling;
                            } // Next we're simply going to delete all insertions after the
                            // last rendered item.
                            if (lastTailNode === null) {
                                // All remaining items in the tail are insertions.
                                renderState.tail = null;
                            } else {
                                // Detach the insertion after the last node that was already
                                // inserted.
                                lastTailNode.sibling = null;
                            }
                            break;
                        }
                    case 'collapsed':
                        {
                            // Any insertions at the end of the tail list after this point
                            // should be invisible. If there are already mounted boundaries
                            // anything before them are not considered for collapsing.
                            // Therefore we need to go through the whole tail to find if
                            // there are any.
                            var _tailNode = renderState.tail;
                            var _lastTailNode = null;
                            while(_tailNode !== null){
                                if (_tailNode.alternate !== null) {
                                    _lastTailNode = _tailNode;
                                }
                                _tailNode = _tailNode.sibling;
                            } // Next we're simply going to delete all insertions after the
                            // last rendered item.
                            if (_lastTailNode === null) {
                                // All remaining items in the tail are insertions.
                                if (!hasRenderedATailFallback && renderState.tail !== null) {
                                    // We suspended during the head. We want to show at least one
                                    // row at the tail. So we'll keep on and cut off the rest.
                                    renderState.tail.sibling = null;
                                } else {
                                    renderState.tail = null;
                                }
                            } else {
                                // Detach the insertion after the last node that was already
                                // inserted.
                                _lastTailNode.sibling = null;
                            }
                            break;
                        }
                }
            }
            function bubbleProperties(completedWork) {
                var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
                var newChildLanes = NoLanes;
                var subtreeFlags = NoFlags;
                if (!didBailout) {
                    // Bubble up the earliest expiration time.
                    if ((completedWork.mode & ProfileMode) !== NoMode) {
                        // In profiling mode, resetChildExpirationTime is also used to reset
                        // profiler durations.
                        var actualDuration = completedWork.actualDuration;
                        var treeBaseDuration = completedWork.selfBaseDuration;
                        var child = completedWork.child;
                        while(child !== null){
                            newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                            subtreeFlags |= child.subtreeFlags;
                            subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will
                            // only be updated if work is done on the fiber (i.e. it doesn't bailout).
                            // When work is done, it should bubble to the parent's actualDuration. If
                            // the fiber has not been cloned though, (meaning no work was done), then
                            // this value will reflect the amount of time spent working on a previous
                            // render. In that case it should not bubble. We determine whether it was
                            // cloned by comparing the child pointer.
                            actualDuration += child.actualDuration;
                            treeBaseDuration += child.treeBaseDuration;
                            child = child.sibling;
                        }
                        completedWork.actualDuration = actualDuration;
                        completedWork.treeBaseDuration = treeBaseDuration;
                    } else {
                        var _child = completedWork.child;
                        while(_child !== null){
                            newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                            subtreeFlags |= _child.subtreeFlags;
                            subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code
                            // smell because it assumes the commit phase is never concurrent with
                            // the render phase. Will address during refactor to alternate model.
                            _child.return = completedWork;
                            _child = _child.sibling;
                        }
                    }
                    completedWork.subtreeFlags |= subtreeFlags;
                } else {
                    // Bubble up the earliest expiration time.
                    if ((completedWork.mode & ProfileMode) !== NoMode) {
                        // In profiling mode, resetChildExpirationTime is also used to reset
                        // profiler durations.
                        var _treeBaseDuration = completedWork.selfBaseDuration;
                        var _child2 = completedWork.child;
                        while(_child2 !== null){
                            newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // "Static" flags share the lifetime of the fiber/hook they belong to,
                            // so we should bubble those up even during a bailout. All the other
                            // flags have a lifetime only of a single render + commit, so we should
                            // ignore them.
                            subtreeFlags |= _child2.subtreeFlags & StaticMask;
                            subtreeFlags |= _child2.flags & StaticMask;
                            _treeBaseDuration += _child2.treeBaseDuration;
                            _child2 = _child2.sibling;
                        }
                        completedWork.treeBaseDuration = _treeBaseDuration;
                    } else {
                        var _child3 = completedWork.child;
                        while(_child3 !== null){
                            newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // "Static" flags share the lifetime of the fiber/hook they belong to,
                            // so we should bubble those up even during a bailout. All the other
                            // flags have a lifetime only of a single render + commit, so we should
                            // ignore them.
                            subtreeFlags |= _child3.subtreeFlags & StaticMask;
                            subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code
                            // smell because it assumes the commit phase is never concurrent with
                            // the render phase. Will address during refactor to alternate model.
                            _child3.return = completedWork;
                            _child3 = _child3.sibling;
                        }
                    }
                    completedWork.subtreeFlags |= subtreeFlags;
                }
                completedWork.childLanes = newChildLanes;
                return didBailout;
            }
            function completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {
                if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {
                    warnIfUnhydratedTailNodes(workInProgress);
                    resetHydrationState();
                    workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;
                    return false;
                }
                var wasHydrated = popHydrationState(workInProgress);
                if (nextState !== null && nextState.dehydrated !== null) {
                    // We might be inside a hydration state the first time we're picking up this
                    // Suspense boundary, and also after we've reentered it for further hydration.
                    if (current === null) {
                        if (!wasHydrated) {
                            throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');
                        }
                        prepareToHydrateHostSuspenseInstance(workInProgress);
                        bubbleProperties(workInProgress);
                        {
                            if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                var isTimedOutSuspense = nextState !== null;
                                if (isTimedOutSuspense) {
                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.
                                    var primaryChildFragment = workInProgress.child;
                                    if (primaryChildFragment !== null) {
                                        // $FlowFixMe Flow doesn't support type casting in combination with the -= operator
                                        workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                                    }
                                }
                            }
                        }
                        return false;
                    } else {
                        // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration
                        // state since we're now exiting out of it. popHydrationState doesn't do that for us.
                        resetHydrationState();
                        if ((workInProgress.flags & DidCapture) === NoFlags) {
                            // This boundary did not suspend so it's now hydrated and unsuspended.
                            workInProgress.memoizedState = null;
                        } // If nothing suspended, we need to schedule an effect to mark this boundary
                        // as having hydrated so events know that they're free to be invoked.
                        // It's also a signal to replay events and the suspense callback.
                        // If something suspended, schedule an effect to attach retry listeners.
                        // So we might as well always mark this.
                        workInProgress.flags |= Update;
                        bubbleProperties(workInProgress);
                        {
                            if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                var _isTimedOutSuspense = nextState !== null;
                                if (_isTimedOutSuspense) {
                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.
                                    var _primaryChildFragment = workInProgress.child;
                                    if (_primaryChildFragment !== null) {
                                        // $FlowFixMe Flow doesn't support type casting in combination with the -= operator
                                        workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                } else {
                    // Successfully completed this tree. If this was a forced client render,
                    // there may have been recoverable errors during first hydration
                    // attempt. If so, add them to a queue so we can log them in the
                    // commit phase.
                    upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path
                    return true;
                }
            }
            function completeWork(current, workInProgress, renderLanes) {
                var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing
                // to the current tree provider fiber is just as fast and less error-prone.
                // Ideally we would have a special version of the work loop only
                // for hydration.
                popTreeContext(workInProgress);
                switch(workInProgress.tag){
                    case IndeterminateComponent:
                    case LazyComponent:
                    case SimpleMemoComponent:
                    case FunctionComponent:
                    case ForwardRef:
                    case Fragment:
                    case Mode:
                    case Profiler:
                    case ContextConsumer:
                    case MemoComponent:
                        bubbleProperties(workInProgress);
                        return null;
                    case ClassComponent:
                        {
                            var Component = workInProgress.type;
                            if (isContextProvider(Component)) {
                                popContext(workInProgress);
                            }
                            bubbleProperties(workInProgress);
                            return null;
                        }
                    case HostRoot:
                        {
                            var fiberRoot = workInProgress.stateNode;
                            popHostContainer(workInProgress);
                            popTopLevelContextObject(workInProgress);
                            resetWorkInProgressVersions();
                            if (fiberRoot.pendingContext) {
                                fiberRoot.context = fiberRoot.pendingContext;
                                fiberRoot.pendingContext = null;
                            }
                            if (current === null || current.child === null) {
                                // If we hydrated, pop so that we can delete any remaining children
                                // that weren't hydrated.
                                var wasHydrated = popHydrationState(workInProgress);
                                if (wasHydrated) {
                                    // If we hydrated, then we'll need to schedule an update for
                                    // the commit side-effects on the root.
                                    markUpdate(workInProgress);
                                } else {
                                    if (current !== null) {
                                        var prevState = current.memoizedState;
                                        if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                                        (workInProgress.flags & ForceClientRender) !== NoFlags) {
                                            // Schedule an effect to clear this container at the start of the
                                            // next commit. This handles the case of React rendering into a
                                            // container with previous children. It's also safe to do for
                                            // updates too, because current.child would only be null if the
                                            // previous render was null (so the container would already
                                            // be empty).
                                            workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been
                                            // recoverable errors during first hydration attempt. If so, add
                                            // them to a queue so we can log them in the commit phase.
                                            upgradeHydrationErrorsToRecoverable();
                                        }
                                    }
                                }
                            }
                            updateHostContainer(current, workInProgress);
                            bubbleProperties(workInProgress);
                            return null;
                        }
                    case HostComponent:
                        {
                            popHostContext(workInProgress);
                            var rootContainerInstance = getRootHostContainer();
                            var type = workInProgress.type;
                            if (current !== null && workInProgress.stateNode != null) {
                                updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);
                                if (current.ref !== workInProgress.ref) {
                                    markRef$1(workInProgress);
                                }
                            } else {
                                if (!newProps) {
                                    if (workInProgress.stateNode === null) {
                                        throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');
                                    } // This can happen when we abort work.
                                    bubbleProperties(workInProgress);
                                    return null;
                                }
                                var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
                                // "stack" as the parent. Then append children as we go in beginWork
                                // or completeWork depending on whether we want to add them top->down or
                                // bottom->up. Top->down is faster in IE11.
                                var _wasHydrated = popHydrationState(workInProgress);
                                if (_wasHydrated) {
                                    // TODO: Move this and createInstance step into the beginPhase
                                    // to consolidate.
                                    if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                                        // If changes to the hydrated node need to be applied at the
                                        // commit-phase we mark this as such.
                                        markUpdate(workInProgress);
                                    }
                                } else {
                                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
                                    appendAllChildren(instance, workInProgress, false, false);
                                    workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
                                    // (eg DOM renderer supports auto-focus for certain elements).
                                    // Make sure such renderers get scheduled for later work.
                                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                                        markUpdate(workInProgress);
                                    }
                                }
                                if (workInProgress.ref !== null) {
                                    // If there is a ref on a host node we need to schedule a callback
                                    markRef$1(workInProgress);
                                }
                            }
                            bubbleProperties(workInProgress);
                            return null;
                        }
                    case HostText:
                        {
                            var newText = newProps;
                            if (current && workInProgress.stateNode != null) {
                                var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
                                // to schedule a side-effect to do the updates.
                                updateHostText$1(current, workInProgress, oldText, newText);
                            } else {
                                if (typeof newText !== 'string') {
                                    if (workInProgress.stateNode === null) {
                                        throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');
                                    } // This can happen when we abort work.
                                }
                                var _rootContainerInstance = getRootHostContainer();
                                var _currentHostContext = getHostContext();
                                var _wasHydrated2 = popHydrationState(workInProgress);
                                if (_wasHydrated2) {
                                    if (prepareToHydrateHostTextInstance(workInProgress)) {
                                        markUpdate(workInProgress);
                                    }
                                } else {
                                    workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                                }
                            }
                            bubbleProperties(workInProgress);
                            return null;
                        }
                    case SuspenseComponent:
                        {
                            popSuspenseContext(workInProgress);
                            var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this
                            // to its own fiber type so that we can add other kinds of hydration
                            // boundaries that aren't associated with a Suspense tree. In anticipation
                            // of such a refactor, all the hydration logic is contained in
                            // this branch.
                            if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {
                                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);
                                if (!fallthroughToNormalSuspensePath) {
                                    if (workInProgress.flags & ShouldCapture) {
                                        // Special case. There were remaining unhydrated nodes. We treat
                                        // this as a mismatch. Revert to client rendering.
                                        return workInProgress;
                                    } else {
                                        // Did not finish hydrating, either because this is the initial
                                        // render or because something suspended.
                                        return null;
                                    }
                                } // Continue with the normal Suspense path.
                            }
                            if ((workInProgress.flags & DidCapture) !== NoFlags) {
                                // Something suspended. Re-render with the fallback children.
                                workInProgress.lanes = renderLanes; // Do not reset the effect list.
                                if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                    transferActualDuration(workInProgress);
                                } // Don't bubble properties in this case.
                                return workInProgress;
                            }
                            var nextDidTimeout = nextState !== null;
                            var prevDidTimeout = current !== null && current.memoizedState !== null;
                            // a passive effect, which is when we process the transitions
                            if (nextDidTimeout !== prevDidTimeout) {
                                // an effect to toggle the subtree's visibility. When we switch from
                                // fallback -> primary, the inner Offscreen fiber schedules this effect
                                // as part of its normal complete phase. But when we switch from
                                // primary -> fallback, the inner Offscreen fiber does not have a complete
                                // phase. So we need to schedule its effect here.
                                //
                                // We also use this flag to connect/disconnect the effects, but the same
                                // logic applies: when re-connecting, the Offscreen fiber's complete
                                // phase will handle scheduling the effect. It's only when the fallback
                                // is active that we have to do anything special.
                                if (nextDidTimeout) {
                                    var _offscreenFiber2 = workInProgress.child;
                                    _offscreenFiber2.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything
                                    // in the concurrent tree already suspended during this render.
                                    // This is a known bug.
                                    if ((workInProgress.mode & ConcurrentMode) !== NoMode) {
                                        // TODO: Move this back to throwException because this is too late
                                        // if this is a large tree which is common for initial loads. We
                                        // don't know if we should restart a render or not until we get
                                        // this marker, and this is too late.
                                        // If this render already had a ping or lower pri updates,
                                        // and this is the first time we know we're going to suspend we
                                        // should be able to immediately restart from within throwException.
                                        var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || true);
                                        if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                                            // If this was in an invisible tree or a new render, then showing
                                            // this boundary is ok.
                                            renderDidSuspend();
                                        } else {
                                            // Otherwise, we're going to have to hide content so we should
                                            // suspend for longer if possible.
                                            renderDidSuspendDelayIfPossible();
                                        }
                                    }
                                }
                            }
                            var wakeables = workInProgress.updateQueue;
                            if (wakeables !== null) {
                                // Schedule an effect to attach a retry listener to the promise.
                                // TODO: Move to passive phase
                                workInProgress.flags |= Update;
                            }
                            bubbleProperties(workInProgress);
                            {
                                if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                    if (nextDidTimeout) {
                                        // Don't count time spent in a timed out Suspense subtree as part of the base duration.
                                        var primaryChildFragment = workInProgress.child;
                                        if (primaryChildFragment !== null) {
                                            // $FlowFixMe Flow doesn't support type casting in combination with the -= operator
                                            workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                                        }
                                    }
                                }
                            }
                            return null;
                        }
                    case HostPortal:
                        popHostContainer(workInProgress);
                        updateHostContainer(current, workInProgress);
                        if (current === null) {
                            preparePortalMount(workInProgress.stateNode.containerInfo);
                        }
                        bubbleProperties(workInProgress);
                        return null;
                    case ContextProvider:
                        // Pop provider fiber
                        var context = workInProgress.type._context;
                        popProvider(context, workInProgress);
                        bubbleProperties(workInProgress);
                        return null;
                    case IncompleteClassComponent:
                        {
                            // Same as class component case. I put it down here so that the tags are
                            // sequential to ensure this switch is compiled to a jump table.
                            var _Component = workInProgress.type;
                            if (isContextProvider(_Component)) {
                                popContext(workInProgress);
                            }
                            bubbleProperties(workInProgress);
                            return null;
                        }
                    case SuspenseListComponent:
                        {
                            popSuspenseContext(workInProgress);
                            var renderState = workInProgress.memoizedState;
                            if (renderState === null) {
                                // We're running in the default, "independent" mode.
                                // We don't do anything in this mode.
                                bubbleProperties(workInProgress);
                                return null;
                            }
                            var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
                            var renderedTail = renderState.rendering;
                            if (renderedTail === null) {
                                // We just rendered the head.
                                if (!didSuspendAlready) {
                                    // This is the first pass. We need to figure out if anything is still
                                    // suspended in the rendered set.
                                    // If new content unsuspended, but there's still some content that
                                    // didn't. Then we need to do a second pass that forces everything
                                    // to keep showing their fallbacks.
                                    // We might be suspended if something in this render pass suspended, or
                                    // something in the previous committed pass suspended. Otherwise,
                                    // there's no chance so we can skip the expensive call to
                                    // findFirstSuspended.
                                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);
                                    if (!cannotBeSuspended) {
                                        var row = workInProgress.child;
                                        while(row !== null){
                                            var suspended = findFirstSuspended(row);
                                            if (suspended !== null) {
                                                didSuspendAlready = true;
                                                workInProgress.flags |= DidCapture;
                                                cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                                                // part of the second pass. In that case nothing will subscribe to
                                                // its thenables. Instead, we'll transfer its thenables to the
                                                // SuspenseList so that it can retry if they resolve.
                                                // There might be multiple of these in the list but since we're
                                                // going to wait for all of them anyway, it doesn't really matter
                                                // which ones gets to ping. In theory we could get clever and keep
                                                // track of how many dependencies remain but it gets tricky because
                                                // in the meantime, we can add/remove/change items and dependencies.
                                                // We might bail out of the loop before finding any but that
                                                // doesn't matter since that means that the other boundaries that
                                                // we did find already has their listeners attached.
                                                var newThenables = suspended.updateQueue;
                                                if (newThenables !== null) {
                                                    workInProgress.updateQueue = newThenables;
                                                    workInProgress.flags |= Update;
                                                } // Rerender the whole list, but this time, we'll force fallbacks
                                                // to stay in place.
                                                // Reset the effect flags before doing the second pass since that's now invalid.
                                                // Reset the child fibers to their original state.
                                                workInProgress.subtreeFlags = NoFlags;
                                                resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                                                // rerender the children.
                                                pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.
                                                return workInProgress.child;
                                            }
                                            row = row.sibling;
                                        }
                                    }
                                    if (renderState.tail !== null && now() > getRenderTargetTime()) {
                                        // We have already passed our CPU deadline but we still have rows
                                        // left in the tail. We'll just give up further attempts to render
                                        // the main content and only render fallbacks.
                                        workInProgress.flags |= DidCapture;
                                        didSuspendAlready = true;
                                        cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
                                        // to get it started back up to attempt the next item. While in terms
                                        // of priority this work has the same priority as this current render,
                                        // it's not part of the same transition once the transition has
                                        // committed. If it's sync, we still want to yield so that it can be
                                        // painted. Conceptually, this is really the same as pinging.
                                        // We can use any RetryLane even if it's the one currently rendering
                                        // since we're leaving it behind on this node.
                                        workInProgress.lanes = SomeRetryLane;
                                    }
                                } else {
                                    cutOffTailIfNeeded(renderState, false);
                                } // Next we're going to render the tail.
                            } else {
                                // Append the rendered row to the child list.
                                if (!didSuspendAlready) {
                                    var _suspended = findFirstSuspended(renderedTail);
                                    if (_suspended !== null) {
                                        workInProgress.flags |= DidCapture;
                                        didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
                                        // get lost if this row ends up dropped during a second pass.
                                        var _newThenables = _suspended.updateQueue;
                                        if (_newThenables !== null) {
                                            workInProgress.updateQueue = _newThenables;
                                            workInProgress.flags |= Update;
                                        }
                                        cutOffTailIfNeeded(renderState, true); // This might have been modified.
                                        if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
                                        ) {
                                            // We're done.
                                            bubbleProperties(workInProgress);
                                            return null;
                                        }
                                    } else if (// time we have to render. So rendering one more row would likely
                                    // exceed it.
                                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
                                        // We have now passed our CPU deadline and we'll just give up further
                                        // attempts to render the main content and only render fallbacks.
                                        // The assumption is that this is usually faster.
                                        workInProgress.flags |= DidCapture;
                                        didSuspendAlready = true;
                                        cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
                                        // to get it started back up to attempt the next item. While in terms
                                        // of priority this work has the same priority as this current render,
                                        // it's not part of the same transition once the transition has
                                        // committed. If it's sync, we still want to yield so that it can be
                                        // painted. Conceptually, this is really the same as pinging.
                                        // We can use any RetryLane even if it's the one currently rendering
                                        // since we're leaving it behind on this node.
                                        workInProgress.lanes = SomeRetryLane;
                                    }
                                }
                                if (renderState.isBackwards) {
                                    // The effect list of the backwards tail will have been added
                                    // to the end. This breaks the guarantee that life-cycles fire in
                                    // sibling order but that isn't a strong guarantee promised by React.
                                    // Especially since these might also just pop in during future commits.
                                    // Append to the beginning of the list.
                                    renderedTail.sibling = workInProgress.child;
                                    workInProgress.child = renderedTail;
                                } else {
                                    var previousSibling = renderState.last;
                                    if (previousSibling !== null) {
                                        previousSibling.sibling = renderedTail;
                                    } else {
                                        workInProgress.child = renderedTail;
                                    }
                                    renderState.last = renderedTail;
                                }
                            }
                            if (renderState.tail !== null) {
                                // We still have tail rows to render.
                                // Pop a row.
                                var next = renderState.tail;
                                renderState.rendering = next;
                                renderState.tail = next.sibling;
                                renderState.renderingStartTime = now();
                                next.sibling = null; // Restore the context.
                                // TODO: We can probably just avoid popping it instead and only
                                // setting it the first time we go from not suspended to suspended.
                                var suspenseContext = suspenseStackCursor.current;
                                if (didSuspendAlready) {
                                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                                } else {
                                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                                }
                                pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.
                                // Don't bubble properties in this case.
                                return next;
                            }
                            bubbleProperties(workInProgress);
                            return null;
                        }
                    case ScopeComponent:
                        {
                            break;
                        }
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                        {
                            popRenderLanes(workInProgress);
                            var _nextState = workInProgress.memoizedState;
                            var nextIsHidden = _nextState !== null;
                            if (current !== null) {
                                var _prevState = current.memoizedState;
                                var prevIsHidden = _prevState !== null;
                                if (prevIsHidden !== nextIsHidden && true) {
                                    workInProgress.flags |= Visibility;
                                }
                            }
                            if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {
                                bubbleProperties(workInProgress);
                            } else {
                                // Don't bubble properties for hidden children unless we're rendering
                                // at offscreen priority.
                                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                                    bubbleProperties(workInProgress);
                                    if (supportsMutation) {
                                        // Check if there was an insertion or update in the hidden subtree.
                                        // If so, we need to hide those nodes in the commit phase, so
                                        // schedule a visibility effect.
                                        if (workInProgress.subtreeFlags & (Placement | Update)) {
                                            workInProgress.flags |= Visibility;
                                        }
                                    }
                                }
                            }
                            return null;
                        }
                    case CacheComponent:
                        {
                            return null;
                        }
                    case TracingMarkerComponent:
                        {
                            return null;
                        }
                }
                throw new Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in " + 'React. Please file an issue.');
            }
            function unwindWork(current, workInProgress, renderLanes) {
                // Note: This intentionally doesn't check if we're hydrating because comparing
                // to the current tree provider fiber is just as fast and less error-prone.
                // Ideally we would have a special version of the work loop only
                // for hydration.
                popTreeContext(workInProgress);
                switch(workInProgress.tag){
                    case ClassComponent:
                        {
                            var Component = workInProgress.type;
                            if (isContextProvider(Component)) {
                                popContext(workInProgress);
                            }
                            var flags = workInProgress.flags;
                            if (flags & ShouldCapture) {
                                workInProgress.flags = flags & -65537 | DidCapture;
                                if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                    transferActualDuration(workInProgress);
                                }
                                return workInProgress;
                            }
                            return null;
                        }
                    case HostRoot:
                        {
                            workInProgress.stateNode;
                            popHostContainer(workInProgress);
                            popTopLevelContextObject(workInProgress);
                            resetWorkInProgressVersions();
                            var _flags = workInProgress.flags;
                            if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                                // There was an error during render that wasn't captured by a suspense
                                // boundary. Do a second pass on the root to unmount the children.
                                workInProgress.flags = _flags & -65537 | DidCapture;
                                return workInProgress;
                            } // We unwound to the root without completing it. Exit.
                            return null;
                        }
                    case HostComponent:
                        {
                            // TODO: popHydrationState
                            popHostContext(workInProgress);
                            return null;
                        }
                    case SuspenseComponent:
                        {
                            popSuspenseContext(workInProgress);
                            var suspenseState = workInProgress.memoizedState;
                            if (suspenseState !== null && suspenseState.dehydrated !== null) {
                                if (workInProgress.alternate === null) {
                                    throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');
                                }
                                resetHydrationState();
                            }
                            var _flags2 = workInProgress.flags;
                            if (_flags2 & ShouldCapture) {
                                workInProgress.flags = _flags2 & -65537 | DidCapture; // Captured a suspense effect. Re-render the boundary.
                                if ((workInProgress.mode & ProfileMode) !== NoMode) {
                                    transferActualDuration(workInProgress);
                                }
                                return workInProgress;
                            }
                            return null;
                        }
                    case SuspenseListComponent:
                        {
                            popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
                            // caught by a nested boundary. If not, it should bubble through.
                            return null;
                        }
                    case HostPortal:
                        popHostContainer(workInProgress);
                        return null;
                    case ContextProvider:
                        var context = workInProgress.type._context;
                        popProvider(context, workInProgress);
                        return null;
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                        popRenderLanes(workInProgress);
                        return null;
                    case CacheComponent:
                        return null;
                    default:
                        return null;
                }
            }
            function unwindInterruptedWork(current, interruptedWork, renderLanes) {
                // Note: This intentionally doesn't check if we're hydrating because comparing
                // to the current tree provider fiber is just as fast and less error-prone.
                // Ideally we would have a special version of the work loop only
                // for hydration.
                popTreeContext(interruptedWork);
                switch(interruptedWork.tag){
                    case ClassComponent:
                        {
                            var childContextTypes = interruptedWork.type.childContextTypes;
                            if (childContextTypes !== null && childContextTypes !== undefined) {
                                popContext(interruptedWork);
                            }
                            break;
                        }
                    case HostRoot:
                        {
                            interruptedWork.stateNode;
                            popHostContainer(interruptedWork);
                            popTopLevelContextObject(interruptedWork);
                            resetWorkInProgressVersions();
                            break;
                        }
                    case HostComponent:
                        {
                            popHostContext(interruptedWork);
                            break;
                        }
                    case HostPortal:
                        popHostContainer(interruptedWork);
                        break;
                    case SuspenseComponent:
                        popSuspenseContext(interruptedWork);
                        break;
                    case SuspenseListComponent:
                        popSuspenseContext(interruptedWork);
                        break;
                    case ContextProvider:
                        var context = interruptedWork.type._context;
                        popProvider(context, interruptedWork);
                        break;
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                        popRenderLanes(interruptedWork);
                        break;
                }
            }
            function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                try {
                    func.apply(context, funcArgs);
                } catch (error) {
                    this.onError(error);
                }
            }
            var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
            {
                // In DEV mode, we swap out invokeGuardedCallback for a special version
                // that plays more nicely with the browser's DevTools. The idea is to preserve
                // "Pause on exceptions" behavior. Because React wraps all user-provided
                // functions in invokeGuardedCallback, and the production version of
                // invokeGuardedCallback uses a try-catch, all user exceptions are treated
                // like caught exceptions, and the DevTools won't pause unless the developer
                // takes the extra step of enabling pause on caught exceptions. This is
                // unintuitive, though, because even though React has caught the error, from
                // the developer's perspective, the error is uncaught.
                //
                // To preserve the expected "Pause on exceptions" behavior, we don't use a
                // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
                // DOM node, and call the user-provided callback from inside an event handler
                // for that fake event. If the callback throws, the error is "captured" using
                // a global event handler. But because the error happens in a different
                // event loop context, it does not interrupt the normal program flow.
                // Effectively, this gives us try-catch behavior without actually using
                // try-catch. Neat!
                // Check that the browser supports the APIs we need to implement our special
                // DEV version of invokeGuardedCallback
                if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
                    var fakeNode = document.createElement('react');
                    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
                        // If document doesn't exist we know for sure we will crash in this method
                        // when we call document.createEvent(). However this can cause confusing
                        // errors: https://github.com/facebook/create-react-app/issues/3482
                        // So we preemptively throw with a better message instead.
                        if (typeof document === 'undefined' || document === null) {
                            throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');
                        }
                        var evt = document.createEvent('Event');
                        var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
                        // set this to true at the beginning, then set it to false right after
                        // calling the function. If the function errors, `didError` will never be
                        // set to false. This strategy works even if the browser is flaky and
                        // fails to call our global error handler, because it doesn't rely on
                        // the error event at all.
                        var didError = true; // Keeps track of the value of window.event so that we can reset it
                        // during the callback to let user code access window.event in the
                        // browsers that support it.
                        var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
                        // dispatching: https://github.com/facebook/react/issues/13688
                        var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
                        function restoreAfterDispatch() {
                            // We immediately remove the callback from event listeners so that
                            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
                            // nested call would trigger the fake event handlers of any call higher
                            // in the stack.
                            fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
                            // window.event assignment in both IE <= 10 as they throw an error
                            // "Member not found" in strict mode, and in Firefox which does not
                            // support window.event.
                            if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
                                window.event = windowEvent;
                            }
                        } // Create an event handler for our fake event. We will synchronously
                        // dispatch our fake event using `dispatchEvent`. Inside the handler, we
                        // call the user-provided callback.
                        var funcArgs = Array.prototype.slice.call(arguments, 3);
                        function callCallback() {
                            didCall = true;
                            restoreAfterDispatch();
                            func.apply(context, funcArgs);
                            didError = false;
                        } // Create a global error event handler. We use this to capture the value
                        // that was thrown. It's possible that this error handler will fire more
                        // than once; for example, if non-React code also calls `dispatchEvent`
                        // and a handler for that event throws. We should be resilient to most of
                        // those cases. Even if our error event handler fires more than once, the
                        // last error event is always used. If the callback actually does error,
                        // we know that the last error event is the correct one, because it's not
                        // possible for anything else to have happened in between our callback
                        // erroring and the code that follows the `dispatchEvent` call below. If
                        // the callback doesn't error, but the error event was fired, we know to
                        // ignore it because `didError` will be false, as described above.
                        var error; // Use this to track whether the error event is ever called.
                        var didSetError = false;
                        var isCrossOriginError = false;
                        function handleWindowError(event) {
                            error = event.error;
                            didSetError = true;
                            if (error === null && event.colno === 0 && event.lineno === 0) {
                                isCrossOriginError = true;
                            }
                            if (event.defaultPrevented) {
                                // Some other error handler has prevented default.
                                // Browsers silence the error report if this happens.
                                // We'll remember this to later decide whether to log it or not.
                                if (error != null && (typeof error === "undefined" ? "undefined" : _type_of(error)) === 'object') {
                                    try {
                                        error._suppressLogging = true;
                                    } catch (inner) {}
                                }
                            }
                        } // Create a fake event type.
                        var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers
                        window.addEventListener('error', handleWindowError);
                        fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
                        // errors, it will trigger our global error handler.
                        evt.initEvent(evtType, false, false);
                        fakeNode.dispatchEvent(evt);
                        if (windowEventDescriptor) {
                            Object.defineProperty(window, 'event', windowEventDescriptor);
                        }
                        if (didCall && didError) {
                            if (!didSetError) {
                                // The callback errored, but the error event never fired.
                                // eslint-disable-next-line react-internal/prod-error-codes
                                error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
                            } else if (isCrossOriginError) {
                                // eslint-disable-next-line react-internal/prod-error-codes
                                error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
                            }
                            this.onError(error);
                        } // Remove our event listeners
                        window.removeEventListener('error', handleWindowError);
                        if (!didCall) {
                            // Something went really wrong, and our event was not dispatched.
                            // https://github.com/facebook/react/issues/16734
                            // https://github.com/facebook/react/issues/16585
                            // Fall back to the production implementation.
                            restoreAfterDispatch();
                            return invokeGuardedCallbackProd.apply(this, arguments);
                        }
                    };
                }
            }
            var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
            var hasError = false;
            var caughtError = null; // Used by event system to capture/rethrow the first error.
            var reporter = {
                onError: function onError(error) {
                    hasError = true;
                    caughtError = error;
                }
            };
            /**
	 * Call a function while guarding against errors that happens within it.
	 * Returns an error if it throws, otherwise null.
	 *
	 * In production, this is implemented using a try-catch. The reason we don't
	 * use a try-catch directly is so that we can swap out a different
	 * implementation in DEV mode.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} context The context to use when calling the function
	 * @param {...*} args Arguments for function
	 */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
                hasError = false;
                caughtError = null;
                invokeGuardedCallbackImpl$1.apply(reporter, arguments);
            }
            function hasCaughtError() {
                return hasError;
            }
            function clearCaughtError() {
                if (hasError) {
                    var error = caughtError;
                    hasError = false;
                    caughtError = null;
                    return error;
                } else {
                    throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');
                }
            }
            var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
            {
                didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
            }
            // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.
            // Only used when enableSuspenseLayoutEffectSemantics is enabled.
            var offscreenSubtreeIsHidden = false;
            var offscreenSubtreeWasHidden = false;
            var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
            var nextEffect = null; // Used for Profiling builds to track updaters.
            var inProgressLanes = null;
            var inProgressRoot = null;
            function reportUncaughtErrorInDEV(error) {
                // Wrapping each small part of the commit phase into a guarded
                // callback is a bit too slow (https://github.com/facebook/react/pull/21666).
                // But we rely on it to surface errors to DEV tools like overlays
                // (https://github.com/facebook/react/issues/21712).
                // As a compromise, rethrow only caught errors in a guard.
                {
                    invokeGuardedCallback(null, function() {
                        throw error;
                    });
                    clearCaughtError();
                }
            }
            var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current, instance) {
                instance.props = current.memoizedProps;
                instance.state = current.memoizedState;
                if (current.mode & ProfileMode) {
                    try {
                        startLayoutEffectTimer();
                        instance.componentWillUnmount();
                    } finally{
                        recordLayoutEffectDuration(current);
                    }
                } else {
                    instance.componentWillUnmount();
                }
            }; // Capture errors so they don't interrupt mounting.
            function safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {
                try {
                    commitHookEffectListMount(Layout, current);
                } catch (error) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error);
                }
            } // Capture errors so they don't interrupt unmounting.
            function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
                try {
                    callComponentWillUnmountWithTimer(current, instance);
                } catch (error) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error);
                }
            } // Capture errors so they don't interrupt mounting.
            function safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {
                try {
                    instance.componentDidMount();
                } catch (error) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error);
                }
            } // Capture errors so they don't interrupt mounting.
            function safelyAttachRef(current, nearestMountedAncestor) {
                try {
                    commitAttachRef(current);
                } catch (error) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error);
                }
            }
            function safelyDetachRef(current, nearestMountedAncestor) {
                var ref = current.ref;
                if (ref !== null) {
                    if (typeof ref === 'function') {
                        var retVal;
                        try {
                            if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {
                                try {
                                    startLayoutEffectTimer();
                                    retVal = ref(null);
                                } finally{
                                    recordLayoutEffectDuration(current);
                                }
                            } else {
                                retVal = ref(null);
                            }
                        } catch (error) {
                            captureCommitPhaseError(current, nearestMountedAncestor, error);
                        }
                        {
                            if (typeof retVal === 'function') {
                                error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));
                            }
                        }
                    } else {
                        ref.current = null;
                    }
                }
            }
            function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
                try {
                    destroy();
                } catch (error) {
                    captureCommitPhaseError(current, nearestMountedAncestor, error);
                }
            }
            var shouldFireAfterActiveInstanceBlur = false;
            function commitBeforeMutationEffects(root, firstChild) {
                prepareForCommit(root.containerInfo);
                nextEffect = firstChild;
                commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber
                var shouldFire = shouldFireAfterActiveInstanceBlur;
                shouldFireAfterActiveInstanceBlur = false;
                return shouldFire;
            }
            function commitBeforeMutationEffects_begin() {
                while(nextEffect !== null){
                    var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.
                    var child = fiber.child;
                    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                        child.return = fiber;
                        nextEffect = child;
                    } else {
                        commitBeforeMutationEffects_complete();
                    }
                }
            }
            function commitBeforeMutationEffects_complete() {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    setCurrentFiber(fiber);
                    try {
                        commitBeforeMutationEffectsOnFiber(fiber);
                    } catch (error) {
                        captureCommitPhaseError(fiber, fiber.return, error);
                    }
                    resetCurrentFiber();
                    var sibling = fiber.sibling;
                    if (sibling !== null) {
                        sibling.return = fiber.return;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = fiber.return;
                }
            }
            function commitBeforeMutationEffectsOnFiber(finishedWork) {
                var current = finishedWork.alternate;
                var flags = finishedWork.flags;
                if ((flags & Snapshot) !== NoFlags) {
                    setCurrentFiber(finishedWork);
                    switch(finishedWork.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                break;
                            }
                        case ClassComponent:
                            {
                                if (current !== null) {
                                    var prevProps = current.memoizedProps;
                                    var prevState = current.memoizedState;
                                    var instance = finishedWork.stateNode; // We could update instance props and state here,
                                    // but instead we rely on them being set during last render.
                                    // TODO: revisit this when we implement resuming.
                                    {
                                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                            if (instance.props !== finishedWork.memoizedProps) {
                                                error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                            }
                                            if (instance.state !== finishedWork.memoizedState) {
                                                error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                            }
                                        }
                                    }
                                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                                    {
                                        var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                                        if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                                            didWarnSet.add(finishedWork.type);
                                            error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));
                                        }
                                    }
                                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                                }
                                break;
                            }
                        case HostRoot:
                            {
                                if (supportsMutation) {
                                    var root = finishedWork.stateNode;
                                    clearContainer(root.containerInfo);
                                }
                                break;
                            }
                        case HostComponent:
                        case HostText:
                        case HostPortal:
                        case IncompleteClassComponent:
                            break;
                        default:
                            {
                                throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
                            }
                    }
                    resetCurrentFiber();
                }
            }
            function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
                var updateQueue = finishedWork.updateQueue;
                var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
                if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                        if ((effect.tag & flags) === flags) {
                            // Unmount
                            var destroy = effect.destroy;
                            effect.destroy = undefined;
                            if (destroy !== undefined) {
                                {
                                    if ((flags & Passive$1) !== NoFlags$1) {
                                        markComponentPassiveEffectUnmountStarted(finishedWork);
                                    } else if ((flags & Layout) !== NoFlags$1) {
                                        markComponentLayoutEffectUnmountStarted(finishedWork);
                                    }
                                }
                                {
                                    if ((flags & Insertion) !== NoFlags$1) {
                                        setIsRunningInsertionEffect(true);
                                    }
                                }
                                safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                                {
                                    if ((flags & Insertion) !== NoFlags$1) {
                                        setIsRunningInsertionEffect(false);
                                    }
                                }
                                {
                                    if ((flags & Passive$1) !== NoFlags$1) {
                                        markComponentPassiveEffectUnmountStopped();
                                    } else if ((flags & Layout) !== NoFlags$1) {
                                        markComponentLayoutEffectUnmountStopped();
                                    }
                                }
                            }
                        }
                        effect = effect.next;
                    }while (effect !== firstEffect);
                }
            }
            function commitHookEffectListMount(flags, finishedWork) {
                var updateQueue = finishedWork.updateQueue;
                var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
                if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                        if ((effect.tag & flags) === flags) {
                            {
                                if ((flags & Passive$1) !== NoFlags$1) {
                                    markComponentPassiveEffectMountStarted(finishedWork);
                                } else if ((flags & Layout) !== NoFlags$1) {
                                    markComponentLayoutEffectMountStarted(finishedWork);
                                }
                            }
                            var create = effect.create;
                            {
                                if ((flags & Insertion) !== NoFlags$1) {
                                    setIsRunningInsertionEffect(true);
                                }
                            }
                            effect.destroy = create();
                            {
                                if ((flags & Insertion) !== NoFlags$1) {
                                    setIsRunningInsertionEffect(false);
                                }
                            }
                            {
                                if ((flags & Passive$1) !== NoFlags$1) {
                                    markComponentPassiveEffectMountStopped();
                                } else if ((flags & Layout) !== NoFlags$1) {
                                    markComponentLayoutEffectMountStopped();
                                }
                            }
                            {
                                var destroy = effect.destroy;
                                if (destroy !== undefined && typeof destroy !== 'function') {
                                    var hookName = void 0;
                                    if ((effect.tag & Layout) !== NoFlags) {
                                        hookName = 'useLayoutEffect';
                                    } else if ((effect.tag & Insertion) !== NoFlags) {
                                        hookName = 'useInsertionEffect';
                                    } else {
                                        hookName = 'useEffect';
                                    }
                                    var addendum = void 0;
                                    if (destroy === null) {
                                        addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
                                    } else if (typeof destroy.then === 'function') {
                                        addendum = '\n\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + hookName + '(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + "}, [someId]); // Or [] if effect doesn't need props or state\n\n" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';
                                    } else {
                                        addendum = ' You returned: ' + destroy;
                                    }
                                    error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);
                                }
                            }
                        }
                        effect = effect.next;
                    }while (effect !== firstEffect);
                }
            }
            function commitPassiveEffectDurations(finishedRoot, finishedWork) {
                {
                    // Only Profilers with work in their subtree will have an Update effect scheduled.
                    if ((finishedWork.flags & Update) !== NoFlags) {
                        switch(finishedWork.tag){
                            case Profiler:
                                {
                                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                                    var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.
                                    // It does not get reset until the start of the next commit phase.
                                    var commitTime = getCommitTime();
                                    var phase = finishedWork.alternate === null ? 'mount' : 'update';
                                    {
                                        if (isCurrentUpdateNested()) {
                                            phase = 'nested-update';
                                        }
                                    }
                                    if (typeof onPostCommit === 'function') {
                                        onPostCommit(id, phase, passiveEffectDuration, commitTime);
                                    } // Bubble times to the next nearest ancestor Profiler.
                                    // After we process that Profiler, we'll bubble further up.
                                    var parentFiber = finishedWork.return;
                                    outer: while(parentFiber !== null){
                                        switch(parentFiber.tag){
                                            case HostRoot:
                                                var root = parentFiber.stateNode;
                                                root.passiveEffectDuration += passiveEffectDuration;
                                                break outer;
                                            case Profiler:
                                                var parentStateNode = parentFiber.stateNode;
                                                parentStateNode.passiveEffectDuration += passiveEffectDuration;
                                                break outer;
                                        }
                                        parentFiber = parentFiber.return;
                                    }
                                    break;
                                }
                        }
                    }
                }
            }
            function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {
                if ((finishedWork.flags & LayoutMask) !== NoFlags) {
                    switch(finishedWork.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                if (!offscreenSubtreeWasHidden) {
                                    // At this point layout effects have already been destroyed (during mutation phase).
                                    // This is done to prevent sibling component effects from interfering with each other,
                                    // e.g. a destroy function in one component should never override a ref set
                                    // by a create function in another component during the same commit.
                                    if (finishedWork.mode & ProfileMode) {
                                        try {
                                            startLayoutEffectTimer();
                                            commitHookEffectListMount(Layout | HasEffect, finishedWork);
                                        } finally{
                                            recordLayoutEffectDuration(finishedWork);
                                        }
                                    } else {
                                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                                    }
                                }
                                break;
                            }
                        case ClassComponent:
                            {
                                var instance = finishedWork.stateNode;
                                if (finishedWork.flags & Update) {
                                    if (!offscreenSubtreeWasHidden) {
                                        if (current === null) {
                                            // We could update instance props and state here,
                                            // but instead we rely on them being set during last render.
                                            // TODO: revisit this when we implement resuming.
                                            {
                                                if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                    if (instance.props !== finishedWork.memoizedProps) {
                                                        error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                    }
                                                    if (instance.state !== finishedWork.memoizedState) {
                                                        error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                    }
                                                }
                                            }
                                            if (finishedWork.mode & ProfileMode) {
                                                try {
                                                    startLayoutEffectTimer();
                                                    instance.componentDidMount();
                                                } finally{
                                                    recordLayoutEffectDuration(finishedWork);
                                                }
                                            } else {
                                                instance.componentDidMount();
                                            }
                                        } else {
                                            var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
                                            var prevState = current.memoizedState; // We could update instance props and state here,
                                            // but instead we rely on them being set during last render.
                                            // TODO: revisit this when we implement resuming.
                                            {
                                                if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                                    if (instance.props !== finishedWork.memoizedProps) {
                                                        error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                    }
                                                    if (instance.state !== finishedWork.memoizedState) {
                                                        error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                                    }
                                                }
                                            }
                                            if (finishedWork.mode & ProfileMode) {
                                                try {
                                                    startLayoutEffectTimer();
                                                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                                                } finally{
                                                    recordLayoutEffectDuration(finishedWork);
                                                }
                                            } else {
                                                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                                            }
                                        }
                                    }
                                } // TODO: I think this is now always non-null by the time it reaches the
                                // commit phase. Consider removing the type check.
                                var updateQueue = finishedWork.updateQueue;
                                if (updateQueue !== null) {
                                    {
                                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                                            if (instance.props !== finishedWork.memoizedProps) {
                                                error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                            }
                                            if (instance.state !== finishedWork.memoizedState) {
                                                error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');
                                            }
                                        }
                                    }
                                    // but instead we rely on them being set during last render.
                                    // TODO: revisit this when we implement resuming.
                                    commitUpdateQueue(finishedWork, updateQueue, instance);
                                }
                                break;
                            }
                        case HostRoot:
                            {
                                // TODO: I think this is now always non-null by the time it reaches the
                                // commit phase. Consider removing the type check.
                                var _updateQueue = finishedWork.updateQueue;
                                if (_updateQueue !== null) {
                                    var _instance = null;
                                    if (finishedWork.child !== null) {
                                        switch(finishedWork.child.tag){
                                            case HostComponent:
                                                _instance = getPublicInstance(finishedWork.child.stateNode);
                                                break;
                                            case ClassComponent:
                                                _instance = finishedWork.child.stateNode;
                                                break;
                                        }
                                    }
                                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                                }
                                break;
                            }
                        case HostComponent:
                            {
                                var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
                                // (eg DOM renderer may schedule auto-focus for inputs and form controls).
                                // These effects should only be committed when components are first mounted,
                                // aka when there is no current/alternate.
                                if (current === null && finishedWork.flags & Update) {
                                    var type = finishedWork.type;
                                    var props = finishedWork.memoizedProps;
                                    commitMount(_instance2, type, props, finishedWork);
                                }
                                break;
                            }
                        case HostText:
                            {
                                break;
                            }
                        case HostPortal:
                            {
                                break;
                            }
                        case Profiler:
                            {
                                {
                                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                                    var effectDuration = finishedWork.stateNode.effectDuration;
                                    var commitTime = getCommitTime();
                                    var phase = current === null ? 'mount' : 'update';
                                    {
                                        if (isCurrentUpdateNested()) {
                                            phase = 'nested-update';
                                        }
                                    }
                                    if (typeof onRender === 'function') {
                                        onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);
                                    }
                                    {
                                        if (typeof onCommit === 'function') {
                                            onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);
                                        } // Schedule a passive effect for this Profiler to call onPostCommit hooks.
                                        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,
                                        // because the effect is also where times bubble to parent Profilers.
                                        enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.
                                        // Do not reset these values until the next render so DevTools has a chance to read them first.
                                        var parentFiber = finishedWork.return;
                                        outer: while(parentFiber !== null){
                                            switch(parentFiber.tag){
                                                case HostRoot:
                                                    var root = parentFiber.stateNode;
                                                    root.effectDuration += effectDuration;
                                                    break outer;
                                                case Profiler:
                                                    var parentStateNode = parentFiber.stateNode;
                                                    parentStateNode.effectDuration += effectDuration;
                                                    break outer;
                                            }
                                            parentFiber = parentFiber.return;
                                        }
                                    }
                                }
                                break;
                            }
                        case SuspenseComponent:
                            {
                                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                                break;
                            }
                        case SuspenseListComponent:
                        case IncompleteClassComponent:
                        case ScopeComponent:
                        case OffscreenComponent:
                        case LegacyHiddenComponent:
                        case TracingMarkerComponent:
                            {
                                break;
                            }
                        default:
                            throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');
                    }
                }
                if (!offscreenSubtreeWasHidden) {
                    {
                        if (finishedWork.flags & Ref) {
                            commitAttachRef(finishedWork);
                        }
                    }
                }
            }
            function reappearLayoutEffectsOnFiber(node) {
                // Turn on layout effects in a tree that previously disappeared.
                // TODO (Offscreen) Check: flags & LayoutStatic
                switch(node.tag){
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            if (node.mode & ProfileMode) {
                                try {
                                    startLayoutEffectTimer();
                                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                                } finally{
                                    recordLayoutEffectDuration(node);
                                }
                            } else {
                                safelyCallCommitHookLayoutEffectListMount(node, node.return);
                            }
                            break;
                        }
                    case ClassComponent:
                        {
                            var instance = node.stateNode;
                            if (typeof instance.componentDidMount === 'function') {
                                safelyCallComponentDidMount(node, node.return, instance);
                            }
                            safelyAttachRef(node, node.return);
                            break;
                        }
                    case HostComponent:
                        {
                            safelyAttachRef(node, node.return);
                            break;
                        }
                }
            }
            function hideOrUnhideAllChildren(finishedWork, isHidden) {
                // Only hide or unhide the top-most host nodes.
                var hostSubtreeRoot = null;
                if (supportsMutation) {
                    // We only have the top Fiber that was inserted but we need to recurse down its
                    // children to find all the terminal nodes.
                    var node = finishedWork;
                    while(true){
                        if (node.tag === HostComponent) {
                            if (hostSubtreeRoot === null) {
                                hostSubtreeRoot = node;
                                try {
                                    var instance = node.stateNode;
                                    if (isHidden) {
                                        hideInstance(instance);
                                    } else {
                                        unhideInstance(node.stateNode, node.memoizedProps);
                                    }
                                } catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                            }
                        } else if (node.tag === HostText) {
                            if (hostSubtreeRoot === null) {
                                try {
                                    var _instance3 = node.stateNode;
                                    if (isHidden) {
                                        hideTextInstance(_instance3);
                                    } else {
                                        unhideTextInstance(_instance3, node.memoizedProps);
                                    }
                                } catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                            }
                        } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
                        else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        }
                        if (node === finishedWork) {
                            return;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === finishedWork) {
                                return;
                            }
                            if (hostSubtreeRoot === node) {
                                hostSubtreeRoot = null;
                            }
                            node = node.return;
                        }
                        if (hostSubtreeRoot === node) {
                            hostSubtreeRoot = null;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                }
            }
            function commitAttachRef(finishedWork) {
                var ref = finishedWork.ref;
                if (ref !== null) {
                    var instance = finishedWork.stateNode;
                    var instanceToUse;
                    switch(finishedWork.tag){
                        case HostComponent:
                            instanceToUse = getPublicInstance(instance);
                            break;
                        default:
                            instanceToUse = instance;
                    } // Moved outside to ensure DCE works with this flag
                    if (typeof ref === 'function') {
                        var retVal;
                        if (finishedWork.mode & ProfileMode) {
                            try {
                                startLayoutEffectTimer();
                                retVal = ref(instanceToUse);
                            } finally{
                                recordLayoutEffectDuration(finishedWork);
                            }
                        } else {
                            retVal = ref(instanceToUse);
                        }
                        {
                            if (typeof retVal === 'function') {
                                error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));
                            }
                        }
                    } else {
                        {
                            if (!ref.hasOwnProperty('current')) {
                                error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));
                            }
                        }
                        ref.current = instanceToUse;
                    }
                }
            }
            function detachFiberMutation(fiber) {
                // Cut off the return pointer to disconnect it from the tree.
                // This enables us to detect and warn against state updates on an unmounted component.
                // It also prevents events from bubbling from within disconnected components.
                //
                // Ideally, we should also clear the child pointer of the parent alternate to let this
                // get GC:ed but we don't know which for sure which parent is the current
                // one so we'll settle for GC:ing the subtree of this child.
                // This child itself will be GC:ed when the parent updates the next time.
                //
                // Note that we can't clear child or sibling pointers yet.
                // They're needed for passive effects and for findDOMNode.
                // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).
                //
                // Don't reset the alternate yet, either. We need that so we can detach the
                // alternate's fields in the passive phase. Clearing the return pointer is
                // sufficient for findDOMNode semantics.
                var alternate = fiber.alternate;
                if (alternate !== null) {
                    alternate.return = null;
                }
                fiber.return = null;
            }
            function detachFiberAfterEffects(fiber) {
                var alternate = fiber.alternate;
                if (alternate !== null) {
                    fiber.alternate = null;
                    detachFiberAfterEffects(alternate);
                } // Note: Defensively using negation instead of < in case
                // `deletedTreeCleanUpLevel` is undefined.
                {
                    // Clear cyclical Fiber fields. This level alone is designed to roughly
                    // approximate the planned Fiber refactor. In that world, `setState` will be
                    // bound to a special "instance" object instead of a Fiber. The Instance
                    // object will not have any of these fields. It will only be connected to
                    // the fiber tree via a single link at the root. So if this level alone is
                    // sufficient to fix memory issues, that bodes well for our plans.
                    fiber.child = null;
                    fiber.deletions = null;
                    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host
                    // tree, which has its own pointers to children, parents, and siblings.
                    // The other host nodes also point back to fibers, so we should detach that
                    // one, too.
                    if (fiber.tag === HostComponent) {
                        var hostInstance = fiber.stateNode;
                        if (hostInstance !== null) {
                            detachDeletedInstance(hostInstance);
                        }
                    }
                    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We
                    // already disconnect the `return` pointer at the root of the deleted
                    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not
                    // cyclical — it's only cyclical when combined with `child`, `sibling`, and
                    // `alternate`. But we'll clear it in the next level anyway, just in case.
                    {
                        fiber._debugOwner = null;
                    }
                    {
                        // Theoretically, nothing in here should be necessary, because we already
                        // disconnected the fiber from the tree. So even if something leaks this
                        // particular fiber, it won't leak anything else
                        //
                        // The purpose of this branch is to be super aggressive so we can measure
                        // if there's any difference in memory impact. If there is, that could
                        // indicate a React leak we don't know about.
                        fiber.return = null;
                        fiber.dependencies = null;
                        fiber.memoizedProps = null;
                        fiber.memoizedState = null;
                        fiber.pendingProps = null;
                        fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.
                        fiber.updateQueue = null;
                    }
                }
            }
            function emptyPortalContainer(current) {
                if (!supportsPersistence) {
                    return;
                }
                var portal = current.stateNode;
                var containerInfo = portal.containerInfo;
                var emptyChildSet = createContainerChildSet(containerInfo);
                replaceContainerChildren(containerInfo, emptyChildSet);
            }
            function getHostParentFiber(fiber) {
                var parent = fiber.return;
                while(parent !== null){
                    if (isHostParent(parent)) {
                        return parent;
                    }
                    parent = parent.return;
                }
                throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');
            }
            function isHostParent(fiber) {
                return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
            }
            function getHostSibling(fiber) {
                // We're going to search forward into the tree until we find a sibling host
                // node. Unfortunately, if multiple insertions are done in a row we have to
                // search past them. This leads to exponential search for the next sibling.
                // TODO: Find a more efficient way to do this.
                var node = fiber;
                siblings: while(true){
                    // If we didn't find anything, let's try the next sibling.
                    while(node.sibling === null){
                        if (node.return === null || isHostParent(node.return)) {
                            // If we pop out of the root or hit the parent the fiber we are the
                            // last sibling.
                            return null;
                        }
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                    while(node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment){
                        // If it is not host node and, we might have a host node inside it.
                        // Try to search down until we find one.
                        if (node.flags & Placement) {
                            continue siblings;
                        } // If we don't have a child, try the siblings instead.
                        // We also skip portals because they are not part of this host tree.
                        if (node.child === null || node.tag === HostPortal) {
                            continue siblings;
                        } else {
                            node.child.return = node;
                            node = node.child;
                        }
                    } // Check if this host node is stable or about to be placed.
                    if (!(node.flags & Placement)) {
                        // Found it!
                        return node.stateNode;
                    }
                }
            }
            function commitPlacement(finishedWork) {
                if (!supportsMutation) {
                    return;
                } // Recursively insert all host nodes into the parent.
                var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.
                switch(parentFiber.tag){
                    case HostComponent:
                        {
                            var parent = parentFiber.stateNode;
                            if (parentFiber.flags & ContentReset) {
                                // Reset the text content of the parent before doing any insertions
                                resetTextContent(parent); // Clear ContentReset from the effect tag
                                parentFiber.flags &= -33;
                            }
                            var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
                            // children to find all the terminal nodes.
                            insertOrAppendPlacementNode(finishedWork, before, parent);
                            break;
                        }
                    case HostRoot:
                    case HostPortal:
                        {
                            var _parent = parentFiber.stateNode.containerInfo;
                            var _before = getHostSibling(finishedWork);
                            insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                            break;
                        }
                    // eslint-disable-next-line-no-fallthrough
                    default:
                        throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');
                }
            }
            function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
                var tag = node.tag;
                var isHost = tag === HostComponent || tag === HostText;
                if (isHost) {
                    var stateNode = node.stateNode;
                    if (before) {
                        insertInContainerBefore(parent, stateNode, before);
                    } else {
                        appendChildToContainer(parent, stateNode);
                    }
                } else if (tag === HostPortal) ;
                else {
                    var child = node.child;
                    if (child !== null) {
                        insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                        var sibling = child.sibling;
                        while(sibling !== null){
                            insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                            sibling = sibling.sibling;
                        }
                    }
                }
            }
            function insertOrAppendPlacementNode(node, before, parent) {
                var tag = node.tag;
                var isHost = tag === HostComponent || tag === HostText;
                if (isHost) {
                    var stateNode = node.stateNode;
                    if (before) {
                        insertBefore(parent, stateNode, before);
                    } else {
                        appendChild(parent, stateNode);
                    }
                } else if (tag === HostPortal) ;
                else {
                    var child = node.child;
                    if (child !== null) {
                        insertOrAppendPlacementNode(child, before, parent);
                        var sibling = child.sibling;
                        while(sibling !== null){
                            insertOrAppendPlacementNode(sibling, before, parent);
                            sibling = sibling.sibling;
                        }
                    }
                }
            } // These are tracked on the stack as we recursively traverse a
            // deleted subtree.
            // TODO: Update these during the whole mutation phase, not just during
            // a deletion.
            var hostParent = null;
            var hostParentIsContainer = false;
            function commitDeletionEffects(root, returnFiber, deletedFiber) {
                if (supportsMutation) {
                    // We only have the top Fiber that was deleted but we need to recurse down its
                    // children to find all the terminal nodes.
                    // Recursively delete all host nodes from the parent, detach refs, clean
                    // up mounted layout effects, and call componentWillUnmount.
                    // We only need to remove the topmost host child in each branch. But then we
                    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We
                    // could split this into two separate traversals functions, where the second
                    // one doesn't include any removeChild logic. This is maybe the same
                    // function as "disappearLayoutEffects" (or whatever that turns into after
                    // the layout phase is refactored to use recursion).
                    // Before starting, find the nearest host parent on the stack so we know
                    // which instance/container to remove the children from.
                    // TODO: Instead of searching up the fiber return path on every deletion, we
                    // can track the nearest host component on the JS stack as we traverse the
                    // tree during the commit phase. This would make insertions faster, too.
                    var parent = returnFiber;
                    findParent: while(parent !== null){
                        switch(parent.tag){
                            case HostComponent:
                                {
                                    hostParent = parent.stateNode;
                                    hostParentIsContainer = false;
                                    break findParent;
                                }
                            case HostRoot:
                                {
                                    hostParent = parent.stateNode.containerInfo;
                                    hostParentIsContainer = true;
                                    break findParent;
                                }
                            case HostPortal:
                                {
                                    hostParent = parent.stateNode.containerInfo;
                                    hostParentIsContainer = true;
                                    break findParent;
                                }
                        }
                        parent = parent.return;
                    }
                    if (hostParent === null) {
                        throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');
                    }
                    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
                    hostParent = null;
                    hostParentIsContainer = false;
                } else {
                    // Detach refs and call componentWillUnmount() on the whole subtree.
                    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
                }
                detachFiberMutation(deletedFiber);
            }
            function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
                // TODO: Use a static flag to skip trees that don't have unmount effects
                var child = parent.child;
                while(child !== null){
                    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
                    child = child.sibling;
                }
            }
            function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
                onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse
                // into their subtree. There are simpler cases in the inner switch
                // that don't modify the stack.
                switch(deletedFiber.tag){
                    case HostComponent:
                        {
                            if (!offscreenSubtreeWasHidden) {
                                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                            } // Intentional fallthrough to next branch
                        }
                    // eslint-disable-next-line-no-fallthrough
                    case HostText:
                        {
                            // We only need to remove the nearest host child. Set the host parent
                            // to `null` on the stack to indicate that nested children don't
                            // need to be removed.
                            if (supportsMutation) {
                                var prevHostParent = hostParent;
                                var prevHostParentIsContainer = hostParentIsContainer;
                                hostParent = null;
                                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                                hostParent = prevHostParent;
                                hostParentIsContainer = prevHostParentIsContainer;
                                if (hostParent !== null) {
                                    // Now that all the child effects have unmounted, we can remove the
                                    // node from the tree.
                                    if (hostParentIsContainer) {
                                        removeChildFromContainer(hostParent, deletedFiber.stateNode);
                                    } else {
                                        removeChild(hostParent, deletedFiber.stateNode);
                                    }
                                }
                            } else {
                                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            }
                            return;
                        }
                    case DehydratedFragment:
                        {
                            // Delete the dehydrated suspense boundary and all of its content.
                            if (supportsMutation) {
                                if (hostParent !== null) {
                                    if (hostParentIsContainer) {
                                        clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                                    } else {
                                        clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                                    }
                                }
                            }
                            return;
                        }
                    case HostPortal:
                        {
                            if (supportsMutation) {
                                // When we go into a portal, it becomes the parent to remove from.
                                var _prevHostParent = hostParent;
                                var _prevHostParentIsContainer = hostParentIsContainer;
                                hostParent = deletedFiber.stateNode.containerInfo;
                                hostParentIsContainer = true;
                                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                                hostParent = _prevHostParent;
                                hostParentIsContainer = _prevHostParentIsContainer;
                            } else {
                                emptyPortalContainer(deletedFiber);
                                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            }
                            return;
                        }
                    case FunctionComponent:
                    case ForwardRef:
                    case MemoComponent:
                    case SimpleMemoComponent:
                        {
                            if (!offscreenSubtreeWasHidden) {
                                var updateQueue = deletedFiber.updateQueue;
                                if (updateQueue !== null) {
                                    var lastEffect = updateQueue.lastEffect;
                                    if (lastEffect !== null) {
                                        var firstEffect = lastEffect.next;
                                        var effect = firstEffect;
                                        do {
                                            var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                                            if (destroy !== undefined) {
                                                if ((tag & Insertion) !== NoFlags$1) {
                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                                                } else if ((tag & Layout) !== NoFlags$1) {
                                                    {
                                                        markComponentLayoutEffectUnmountStarted(deletedFiber);
                                                    }
                                                    if (deletedFiber.mode & ProfileMode) {
                                                        startLayoutEffectTimer();
                                                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                                                        recordLayoutEffectDuration(deletedFiber);
                                                    } else {
                                                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                                                    }
                                                    {
                                                        markComponentLayoutEffectUnmountStopped();
                                                    }
                                                }
                                            }
                                            effect = effect.next;
                                        }while (effect !== firstEffect);
                                    }
                                }
                            }
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            return;
                        }
                    case ClassComponent:
                        {
                            if (!offscreenSubtreeWasHidden) {
                                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                                var instance = deletedFiber.stateNode;
                                if (typeof instance.componentWillUnmount === 'function') {
                                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                                }
                            }
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            return;
                        }
                    case ScopeComponent:
                        {
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            return;
                        }
                    case OffscreenComponent:
                        {
                            if (deletedFiber.mode & ConcurrentMode) {
                                // If this offscreen component is hidden, we already unmounted it. Before
                                // deleting the children, track that it's already unmounted so that we
                                // don't attempt to unmount the effects again.
                                // TODO: If the tree is hidden, in most cases we should be able to skip
                                // over the nested children entirely. An exception is we haven't yet found
                                // the topmost host node to delete, which we already track on the stack.
                                // But the other case is portals, which need to be detached no matter how
                                // deeply they are nested. We should use a subtree flag to track whether a
                                // subtree includes a nested portal.
                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                            } else {
                                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            }
                            break;
                        }
                    default:
                        {
                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                            return;
                        }
                }
            }
            function commitSuspenseCallback(finishedWork) {
                // TODO: Move this to passive phase
                finishedWork.memoizedState;
            }
            function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
                if (!supportsHydration) {
                    return;
                }
                var newState = finishedWork.memoizedState;
                if (newState === null) {
                    var current = finishedWork.alternate;
                    if (current !== null) {
                        var prevState = current.memoizedState;
                        if (prevState !== null) {
                            var suspenseInstance = prevState.dehydrated;
                            if (suspenseInstance !== null) {
                                commitHydratedSuspenseInstance(suspenseInstance);
                            }
                        }
                    }
                }
            }
            function attachSuspenseRetryListeners(finishedWork) {
                // If this boundary just timed out, then it will have a set of wakeables.
                // For each wakeable, attach a listener so that when it resolves, React
                // attempts to re-render the boundary in the primary (pre-timeout) state.
                var wakeables = finishedWork.updateQueue;
                if (wakeables !== null) {
                    finishedWork.updateQueue = null;
                    var retryCache = finishedWork.stateNode;
                    if (retryCache === null) {
                        retryCache = finishedWork.stateNode = new PossiblyWeakSet();
                    }
                    wakeables.forEach(function(wakeable) {
                        // Memoize using the boundary fiber to prevent redundant listeners.
                        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                        if (!retryCache.has(wakeable)) {
                            retryCache.add(wakeable);
                            {
                                if (isDevToolsPresent) {
                                    if (inProgressLanes !== null && inProgressRoot !== null) {
                                        // If we have pending work still, associate the original updaters with it.
                                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                                    } else {
                                        throw Error('Expected finished root and lanes to be set. This is a bug in React.');
                                    }
                                }
                            }
                            wakeable.then(retry, retry);
                        }
                    });
                }
            } // This function detects when a Suspense boundary goes from visible to hidden.
            function commitMutationEffects(root, finishedWork, committedLanes) {
                inProgressLanes = committedLanes;
                inProgressRoot = root;
                setCurrentFiber(finishedWork);
                commitMutationEffectsOnFiber(finishedWork, root);
                setCurrentFiber(finishedWork);
                inProgressLanes = null;
                inProgressRoot = null;
            }
            function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {
                // Deletions effects can be scheduled on any fiber type. They need to happen
                // before the children effects hae fired.
                var deletions = parentFiber.deletions;
                if (deletions !== null) {
                    for(var i = 0; i < deletions.length; i++){
                        var childToDelete = deletions[i];
                        try {
                            commitDeletionEffects(root, parentFiber, childToDelete);
                        } catch (error) {
                            captureCommitPhaseError(childToDelete, parentFiber, error);
                        }
                    }
                }
                var prevDebugFiber = getCurrentFiber();
                if (parentFiber.subtreeFlags & MutationMask) {
                    var child = parentFiber.child;
                    while(child !== null){
                        setCurrentFiber(child);
                        commitMutationEffectsOnFiber(child, root);
                        child = child.sibling;
                    }
                }
                setCurrentFiber(prevDebugFiber);
            }
            function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
                var current = finishedWork.alternate;
                var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,
                // because the fiber tag is more specific. An exception is any flag related
                // to reconcilation, because those can be set on all fiber types.
                switch(finishedWork.tag){
                    case FunctionComponent:
                    case ForwardRef:
                    case MemoComponent:
                    case SimpleMemoComponent:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Update) {
                                try {
                                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                                } catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                } // Layout effects are destroyed during the mutation phase so that all
                                // destroy functions for all fibers are called before any create functions.
                                // This prevents sibling component effects from interfering with each other,
                                // e.g. a destroy function in one component should never override a ref set
                                // by a create function in another component during the same commit.
                                if (finishedWork.mode & ProfileMode) {
                                    try {
                                        startLayoutEffectTimer();
                                        commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                    } catch (error) {
                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                    }
                                    recordLayoutEffectDuration(finishedWork);
                                } else {
                                    try {
                                        commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                                    } catch (error) {
                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                    }
                                }
                            }
                            return;
                        }
                    case ClassComponent:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Ref) {
                                if (current !== null) {
                                    safelyDetachRef(current, current.return);
                                }
                            }
                            return;
                        }
                    case HostComponent:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Ref) {
                                if (current !== null) {
                                    safelyDetachRef(current, current.return);
                                }
                            }
                            if (supportsMutation) {
                                // TODO: ContentReset gets cleared by the children during the commit
                                // phase. This is a refactor hazard because it means we must read
                                // flags the flags after `commitReconciliationEffects` has already run;
                                // the order matters. We should refactor so that ContentReset does not
                                // rely on mutating the flag during commit. Like by setting a flag
                                // during the render phase instead.
                                if (finishedWork.flags & ContentReset) {
                                    var instance = finishedWork.stateNode;
                                    try {
                                        resetTextContent(instance);
                                    } catch (error) {
                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                    }
                                }
                                if (flags & Update) {
                                    var _instance4 = finishedWork.stateNode;
                                    if (_instance4 != null) {
                                        // Commit the work prepared earlier.
                                        var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                                        // as the newProps. The updatePayload will contain the real change in
                                        // this case.
                                        var oldProps = current !== null ? current.memoizedProps : newProps;
                                        var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.
                                        var updatePayload = finishedWork.updateQueue;
                                        finishedWork.updateQueue = null;
                                        if (updatePayload !== null) {
                                            try {
                                                commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                                            } catch (error) {
                                                captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                            }
                                        }
                                    }
                                }
                            }
                            return;
                        }
                    case HostText:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Update) {
                                if (supportsMutation) {
                                    if (finishedWork.stateNode === null) {
                                        throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');
                                    }
                                    var textInstance = finishedWork.stateNode;
                                    var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                                    // as the newProps. The updatePayload will contain the real change in
                                    // this case.
                                    var oldText = current !== null ? current.memoizedProps : newText;
                                    try {
                                        commitTextUpdate(textInstance, oldText, newText);
                                    } catch (error) {
                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                    }
                                }
                            }
                            return;
                        }
                    case HostRoot:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Update) {
                                if (supportsMutation && supportsHydration) {
                                    if (current !== null) {
                                        var prevRootState = current.memoizedState;
                                        if (prevRootState.isDehydrated) {
                                            try {
                                                commitHydratedContainer(root.containerInfo);
                                            } catch (error) {
                                                captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                            }
                                        }
                                    }
                                }
                                if (supportsPersistence) {
                                    var containerInfo = root.containerInfo;
                                    var pendingChildren = root.pendingChildren;
                                    try {
                                        replaceContainerChildren(containerInfo, pendingChildren);
                                    } catch (error) {
                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                    }
                                }
                            }
                            return;
                        }
                    case HostPortal:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Update) {
                                if (supportsPersistence) {
                                    var portal = finishedWork.stateNode;
                                    var _containerInfo = portal.containerInfo;
                                    var _pendingChildren = portal.pendingChildren;
                                    try {
                                        replaceContainerChildren(_containerInfo, _pendingChildren);
                                    } catch (error) {
                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                    }
                                }
                            }
                            return;
                        }
                    case SuspenseComponent:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            var offscreenFiber = finishedWork.child;
                            if (offscreenFiber.flags & Visibility) {
                                var offscreenInstance = offscreenFiber.stateNode;
                                var newState = offscreenFiber.memoizedState;
                                var isHidden = newState !== null; // Track the current state on the Offscreen instance so we can
                                // read it during an event
                                offscreenInstance.isHidden = isHidden;
                                if (isHidden) {
                                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                                    if (!wasHidden) {
                                        // TODO: Move to passive phase
                                        markCommitTimeOfFallback();
                                    }
                                }
                            }
                            if (flags & Update) {
                                try {
                                    commitSuspenseCallback(finishedWork);
                                } catch (error) {
                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                                }
                                attachSuspenseRetryListeners(finishedWork);
                            }
                            return;
                        }
                    case OffscreenComponent:
                        {
                            var _wasHidden = current !== null && current.memoizedState !== null;
                            if (finishedWork.mode & ConcurrentMode) {
                                // Before committing the children, track on the stack whether this
                                // offscreen subtree was already hidden, so that we don't unmount the
                                // effects again.
                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                                recursivelyTraverseMutationEffects(root, finishedWork);
                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                            } else {
                                recursivelyTraverseMutationEffects(root, finishedWork);
                            }
                            commitReconciliationEffects(finishedWork);
                            if (flags & Visibility) {
                                var _offscreenInstance = finishedWork.stateNode;
                                var _newState = finishedWork.memoizedState;
                                var _isHidden = _newState !== null;
                                var offscreenBoundary = finishedWork; // Track the current state on the Offscreen instance so we can
                                // read it during an event
                                _offscreenInstance.isHidden = _isHidden;
                                {
                                    if (_isHidden) {
                                        if (!_wasHidden) {
                                            if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                                                nextEffect = offscreenBoundary;
                                                var offscreenChild = offscreenBoundary.child;
                                                while(offscreenChild !== null){
                                                    nextEffect = offscreenChild;
                                                    disappearLayoutEffects_begin(offscreenChild);
                                                    offscreenChild = offscreenChild.sibling;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (supportsMutation) {
                                    // TODO: This needs to run whenever there's an insertion or update
                                    // inside a hidden Offscreen tree.
                                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                                }
                            }
                            return;
                        }
                    case SuspenseListComponent:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            if (flags & Update) {
                                attachSuspenseRetryListeners(finishedWork);
                            }
                            return;
                        }
                    case ScopeComponent:
                        {
                            return;
                        }
                    default:
                        {
                            recursivelyTraverseMutationEffects(root, finishedWork);
                            commitReconciliationEffects(finishedWork);
                            return;
                        }
                }
            }
            function commitReconciliationEffects(finishedWork) {
                // Placement effects (insertions, reorders) can be scheduled on any fiber
                // type. They needs to happen after the children effects have fired, but
                // before the effects on this fiber have fired.
                var flags = finishedWork.flags;
                if (flags & Placement) {
                    try {
                        commitPlacement(finishedWork);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    } // Clear the "placement" from effect tag so that we know that this is
                    // inserted, before any life-cycles like componentDidMount gets called.
                    // TODO: findDOMNode doesn't rely on this any more but isMounted does
                    // and isMounted is deprecated anyway so we should be able to kill this.
                    finishedWork.flags &= -3;
                }
                if (flags & Hydrating) {
                    finishedWork.flags &= -4097;
                }
            }
            function commitLayoutEffects(finishedWork, root, committedLanes) {
                inProgressLanes = committedLanes;
                inProgressRoot = root;
                nextEffect = finishedWork;
                commitLayoutEffects_begin(finishedWork, root, committedLanes);
                inProgressLanes = null;
                inProgressRoot = null;
            }
            function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {
                // Suspense layout effects semantics don't change for legacy roots.
                var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    var firstChild = fiber.child;
                    if (fiber.tag === OffscreenComponent && isModernRoot) {
                        // Keep track of the current Offscreen stack's state.
                        var isHidden = fiber.memoizedState !== null;
                        var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                        if (newOffscreenSubtreeIsHidden) {
                            // The Offscreen tree is hidden. Skip over its layout effects.
                            commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                            continue;
                        } else {
                            // TODO (Offscreen) Also check: subtreeFlags & LayoutMask
                            var current = fiber.alternate;
                            var wasHidden = current !== null && current.memoizedState !== null;
                            var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.
                            offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                            offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                            if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                                // This is the root of a reappearing boundary. Turn its layout effects
                                // back on.
                                nextEffect = fiber;
                                reappearLayoutEffects_begin(fiber);
                            }
                            var child = firstChild;
                            while(child !== null){
                                nextEffect = child;
                                commitLayoutEffects_begin(child, root, committedLanes);
                                child = child.sibling;
                            } // Restore Offscreen state and resume in our-progress traversal.
                            nextEffect = fiber;
                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                            commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                            continue;
                        }
                    }
                    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                        firstChild.return = fiber;
                        nextEffect = firstChild;
                    } else {
                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
                    }
                }
            }
            function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    if ((fiber.flags & LayoutMask) !== NoFlags) {
                        var current = fiber.alternate;
                        setCurrentFiber(fiber);
                        try {
                            commitLayoutEffectOnFiber(root, current, fiber, committedLanes);
                        } catch (error) {
                            captureCommitPhaseError(fiber, fiber.return, error);
                        }
                        resetCurrentFiber();
                    }
                    if (fiber === subtreeRoot) {
                        nextEffect = null;
                        return;
                    }
                    var sibling = fiber.sibling;
                    if (sibling !== null) {
                        sibling.return = fiber.return;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = fiber.return;
                }
            }
            function disappearLayoutEffects_begin(subtreeRoot) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)
                    switch(fiber.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case MemoComponent:
                        case SimpleMemoComponent:
                            {
                                if (fiber.mode & ProfileMode) {
                                    try {
                                        startLayoutEffectTimer();
                                        commitHookEffectListUnmount(Layout, fiber, fiber.return);
                                    } finally{
                                        recordLayoutEffectDuration(fiber);
                                    }
                                } else {
                                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                                }
                                break;
                            }
                        case ClassComponent:
                            {
                                // TODO (Offscreen) Check: flags & RefStatic
                                safelyDetachRef(fiber, fiber.return);
                                var instance = fiber.stateNode;
                                if (typeof instance.componentWillUnmount === 'function') {
                                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                                }
                                break;
                            }
                        case HostComponent:
                            {
                                safelyDetachRef(fiber, fiber.return);
                                break;
                            }
                        case OffscreenComponent:
                            {
                                // Check if this is a
                                var isHidden = fiber.memoizedState !== null;
                                if (isHidden) {
                                    // Nested Offscreen tree is already hidden. Don't disappear
                                    // its effects.
                                    disappearLayoutEffects_complete(subtreeRoot);
                                    continue;
                                }
                                break;
                            }
                    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic
                    if (firstChild !== null) {
                        firstChild.return = fiber;
                        nextEffect = firstChild;
                    } else {
                        disappearLayoutEffects_complete(subtreeRoot);
                    }
                }
            }
            function disappearLayoutEffects_complete(subtreeRoot) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    if (fiber === subtreeRoot) {
                        nextEffect = null;
                        return;
                    }
                    var sibling = fiber.sibling;
                    if (sibling !== null) {
                        sibling.return = fiber.return;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = fiber.return;
                }
            }
            function reappearLayoutEffects_begin(subtreeRoot) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    var firstChild = fiber.child;
                    if (fiber.tag === OffscreenComponent) {
                        var isHidden = fiber.memoizedState !== null;
                        if (isHidden) {
                            // Nested Offscreen tree is still hidden. Don't re-appear its effects.
                            reappearLayoutEffects_complete(subtreeRoot);
                            continue;
                        }
                    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic
                    if (firstChild !== null) {
                        // This node may have been reused from a previous render, so we can't
                        // assume its return pointer is correct.
                        firstChild.return = fiber;
                        nextEffect = firstChild;
                    } else {
                        reappearLayoutEffects_complete(subtreeRoot);
                    }
                }
            }
            function reappearLayoutEffects_complete(subtreeRoot) {
                while(nextEffect !== null){
                    var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic
                    setCurrentFiber(fiber);
                    try {
                        reappearLayoutEffectsOnFiber(fiber);
                    } catch (error) {
                        captureCommitPhaseError(fiber, fiber.return, error);
                    }
                    resetCurrentFiber();
                    if (fiber === subtreeRoot) {
                        nextEffect = null;
                        return;
                    }
                    var sibling = fiber.sibling;
                    if (sibling !== null) {
                        // This node may have been reused from a previous render, so we can't
                        // assume its return pointer is correct.
                        sibling.return = fiber.return;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = fiber.return;
                }
            }
            function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {
                nextEffect = finishedWork;
                commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);
            }
            function commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    var firstChild = fiber.child;
                    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                        firstChild.return = fiber;
                        nextEffect = firstChild;
                    } else {
                        commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);
                    }
                }
            }
            function commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    if ((fiber.flags & Passive) !== NoFlags) {
                        setCurrentFiber(fiber);
                        try {
                            commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);
                        } catch (error) {
                            captureCommitPhaseError(fiber, fiber.return, error);
                        }
                        resetCurrentFiber();
                    }
                    if (fiber === subtreeRoot) {
                        nextEffect = null;
                        return;
                    }
                    var sibling = fiber.sibling;
                    if (sibling !== null) {
                        sibling.return = fiber.return;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = fiber.return;
                }
            }
            function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
                switch(finishedWork.tag){
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            if (finishedWork.mode & ProfileMode) {
                                startPassiveEffectTimer();
                                try {
                                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                                } finally{
                                    recordPassiveEffectDuration(finishedWork);
                                }
                            } else {
                                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                            }
                            break;
                        }
                }
            }
            function commitPassiveUnmountEffects(firstChild) {
                nextEffect = firstChild;
                commitPassiveUnmountEffects_begin();
            }
            function commitPassiveUnmountEffects_begin() {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    var child = fiber.child;
                    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                        var deletions = fiber.deletions;
                        if (deletions !== null) {
                            for(var i = 0; i < deletions.length; i++){
                                var fiberToDelete = deletions[i];
                                nextEffect = fiberToDelete;
                                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                            }
                            {
                                // A fiber was deleted from this parent fiber, but it's still part of
                                // the previous (alternate) parent fiber's list of children. Because
                                // children are a linked list, an earlier sibling that's still alive
                                // will be connected to the deleted fiber via its `alternate`:
                                //
                                //   live fiber
                                //   --alternate--> previous live fiber
                                //   --sibling--> deleted fiber
                                //
                                // We can't disconnect `alternate` on nodes that haven't been deleted
                                // yet, but we can disconnect the `sibling` and `child` pointers.
                                var previousFiber = fiber.alternate;
                                if (previousFiber !== null) {
                                    var detachedChild = previousFiber.child;
                                    if (detachedChild !== null) {
                                        previousFiber.child = null;
                                        do {
                                            var detachedSibling = detachedChild.sibling;
                                            detachedChild.sibling = null;
                                            detachedChild = detachedSibling;
                                        }while (detachedChild !== null);
                                    }
                                }
                            }
                            nextEffect = fiber;
                        }
                    }
                    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                        child.return = fiber;
                        nextEffect = child;
                    } else {
                        commitPassiveUnmountEffects_complete();
                    }
                }
            }
            function commitPassiveUnmountEffects_complete() {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    if ((fiber.flags & Passive) !== NoFlags) {
                        setCurrentFiber(fiber);
                        commitPassiveUnmountOnFiber(fiber);
                        resetCurrentFiber();
                    }
                    var sibling = fiber.sibling;
                    if (sibling !== null) {
                        sibling.return = fiber.return;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = fiber.return;
                }
            }
            function commitPassiveUnmountOnFiber(finishedWork) {
                switch(finishedWork.tag){
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            if (finishedWork.mode & ProfileMode) {
                                startPassiveEffectTimer();
                                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                                recordPassiveEffectDuration(finishedWork);
                            } else {
                                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                            }
                            break;
                        }
                }
            }
            function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
                while(nextEffect !== null){
                    var fiber = nextEffect; // Deletion effects fire in parent -> child order
                    // TODO: Check if fiber has a PassiveStatic flag
                    setCurrentFiber(fiber);
                    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
                    resetCurrentFiber();
                    var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we
                    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)
                    if (child !== null) {
                        child.return = fiber;
                        nextEffect = child;
                    } else {
                        commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
                    }
                }
            }
            function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
                while(nextEffect !== null){
                    var fiber = nextEffect;
                    var sibling = fiber.sibling;
                    var returnFiber = fiber.return;
                    {
                        // Recursively traverse the entire deleted tree and clean up fiber fields.
                        // This is more aggressive than ideal, and the long term goal is to only
                        // have to detach the deleted tree at the root.
                        detachFiberAfterEffects(fiber);
                        if (fiber === deletedSubtreeRoot) {
                            nextEffect = null;
                            return;
                        }
                    }
                    if (sibling !== null) {
                        sibling.return = returnFiber;
                        nextEffect = sibling;
                        return;
                    }
                    nextEffect = returnFiber;
                }
            }
            function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {
                switch(current.tag){
                    case FunctionComponent:
                    case ForwardRef:
                    case SimpleMemoComponent:
                        {
                            if (current.mode & ProfileMode) {
                                startPassiveEffectTimer();
                                commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);
                                recordPassiveEffectDuration(current);
                            } else {
                                commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);
                            }
                            break;
                        }
                }
            } // TODO: Reuse reappearLayoutEffects traversal here?
            function invokeLayoutEffectMountInDEV(fiber) {
                {
                    // We don't need to re-check StrictEffectsMode here.
                    // This function is only called if that check has already passed.
                    switch(fiber.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                try {
                                    commitHookEffectListMount(Layout | HasEffect, fiber);
                                } catch (error) {
                                    captureCommitPhaseError(fiber, fiber.return, error);
                                }
                                break;
                            }
                        case ClassComponent:
                            {
                                var instance = fiber.stateNode;
                                try {
                                    instance.componentDidMount();
                                } catch (error) {
                                    captureCommitPhaseError(fiber, fiber.return, error);
                                }
                                break;
                            }
                    }
                }
            }
            function invokePassiveEffectMountInDEV(fiber) {
                {
                    // We don't need to re-check StrictEffectsMode here.
                    // This function is only called if that check has already passed.
                    switch(fiber.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                try {
                                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                                } catch (error) {
                                    captureCommitPhaseError(fiber, fiber.return, error);
                                }
                                break;
                            }
                    }
                }
            }
            function invokeLayoutEffectUnmountInDEV(fiber) {
                {
                    // We don't need to re-check StrictEffectsMode here.
                    // This function is only called if that check has already passed.
                    switch(fiber.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                try {
                                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                                } catch (error) {
                                    captureCommitPhaseError(fiber, fiber.return, error);
                                }
                                break;
                            }
                        case ClassComponent:
                            {
                                var instance = fiber.stateNode;
                                if (typeof instance.componentWillUnmount === 'function') {
                                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                                }
                                break;
                            }
                    }
                }
            }
            function invokePassiveEffectUnmountInDEV(fiber) {
                {
                    // We don't need to re-check StrictEffectsMode here.
                    // This function is only called if that check has already passed.
                    switch(fiber.tag){
                        case FunctionComponent:
                        case ForwardRef:
                        case SimpleMemoComponent:
                            {
                                try {
                                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                                } catch (error) {
                                    captureCommitPhaseError(fiber, fiber.return, error);
                                }
                            }
                    }
                }
            }
            var COMPONENT_TYPE = 0;
            var HAS_PSEUDO_CLASS_TYPE = 1;
            var ROLE_TYPE = 2;
            var TEST_NAME_TYPE = 3;
            var TEXT_TYPE = 4;
            if (typeof Symbol === 'function' && Symbol.for) {
                var symbolFor = Symbol.for;
                COMPONENT_TYPE = symbolFor('selector.component');
                HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');
                ROLE_TYPE = symbolFor('selector.role');
                TEST_NAME_TYPE = symbolFor('selector.test_id');
                TEXT_TYPE = symbolFor('selector.text');
            }
            function createComponentSelector(component) {
                return {
                    $$typeof: COMPONENT_TYPE,
                    value: component
                };
            }
            function createHasPseudoClassSelector(selectors) {
                return {
                    $$typeof: HAS_PSEUDO_CLASS_TYPE,
                    value: selectors
                };
            }
            function createRoleSelector(role) {
                return {
                    $$typeof: ROLE_TYPE,
                    value: role
                };
            }
            function createTextSelector(text) {
                return {
                    $$typeof: TEXT_TYPE,
                    value: text
                };
            }
            function createTestNameSelector(id) {
                return {
                    $$typeof: TEST_NAME_TYPE,
                    value: id
                };
            }
            function findFiberRootForHostRoot(hostRoot) {
                var maybeFiber = getInstanceFromNode(hostRoot);
                if (maybeFiber != null) {
                    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {
                        throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');
                    }
                    return maybeFiber;
                } else {
                    var fiberRoot = findFiberRoot(hostRoot);
                    if (fiberRoot === null) {
                        throw new Error('Could not find React container within specified host subtree.');
                    } // The Flow type for FiberRoot is a little funky.
                    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.
                    return fiberRoot.stateNode.current;
                }
            }
            function matchSelector(fiber, selector) {
                switch(selector.$$typeof){
                    case COMPONENT_TYPE:
                        if (fiber.type === selector.value) {
                            return true;
                        }
                        break;
                    case HAS_PSEUDO_CLASS_TYPE:
                        return hasMatchingPaths(fiber, selector.value);
                    case ROLE_TYPE:
                        if (fiber.tag === HostComponent) {
                            var node = fiber.stateNode;
                            if (matchAccessibilityRole(node, selector.value)) {
                                return true;
                            }
                        }
                        break;
                    case TEXT_TYPE:
                        if (fiber.tag === HostComponent || fiber.tag === HostText) {
                            var textContent = getTextContent(fiber);
                            if (textContent !== null && textContent.indexOf(selector.value) >= 0) {
                                return true;
                            }
                        }
                        break;
                    case TEST_NAME_TYPE:
                        if (fiber.tag === HostComponent) {
                            var dataTestID = fiber.memoizedProps['data-testname'];
                            if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {
                                return true;
                            }
                        }
                        break;
                    default:
                        throw new Error('Invalid selector type specified.');
                }
                return false;
            }
            function selectorToString(selector) {
                switch(selector.$$typeof){
                    case COMPONENT_TYPE:
                        var displayName = getComponentNameFromType(selector.value) || 'Unknown';
                        return "<" + displayName + ">";
                    case HAS_PSEUDO_CLASS_TYPE:
                        return ":has(" + (selectorToString(selector) || '') + ")";
                    case ROLE_TYPE:
                        return "[role=\"" + selector.value + "\"]";
                    case TEXT_TYPE:
                        return "\"" + selector.value + "\"";
                    case TEST_NAME_TYPE:
                        return "[data-testname=\"" + selector.value + "\"]";
                    default:
                        throw new Error('Invalid selector type specified.');
                }
            }
            function findPaths(root, selectors) {
                var matchingFibers = [];
                var stack = [
                    root,
                    0
                ];
                var index = 0;
                while(index < stack.length){
                    var fiber = stack[index++];
                    var selectorIndex = stack[index++];
                    var selector = selectors[selectorIndex];
                    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {
                        continue;
                    } else {
                        while(selector != null && matchSelector(fiber, selector)){
                            selectorIndex++;
                            selector = selectors[selectorIndex];
                        }
                    }
                    if (selectorIndex === selectors.length) {
                        matchingFibers.push(fiber);
                    } else {
                        var child = fiber.child;
                        while(child !== null){
                            stack.push(child, selectorIndex);
                            child = child.sibling;
                        }
                    }
                }
                return matchingFibers;
            } // Same as findPaths but with eager bailout on first match
            function hasMatchingPaths(root, selectors) {
                var stack = [
                    root,
                    0
                ];
                var index = 0;
                while(index < stack.length){
                    var fiber = stack[index++];
                    var selectorIndex = stack[index++];
                    var selector = selectors[selectorIndex];
                    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {
                        continue;
                    } else {
                        while(selector != null && matchSelector(fiber, selector)){
                            selectorIndex++;
                            selector = selectors[selectorIndex];
                        }
                    }
                    if (selectorIndex === selectors.length) {
                        return true;
                    } else {
                        var child = fiber.child;
                        while(child !== null){
                            stack.push(child, selectorIndex);
                            child = child.sibling;
                        }
                    }
                }
                return false;
            }
            function findAllNodes(hostRoot, selectors) {
                if (!supportsTestSelectors) {
                    throw new Error('Test selector API is not supported by this renderer.');
                }
                var root = findFiberRootForHostRoot(hostRoot);
                var matchingFibers = findPaths(root, selectors);
                var instanceRoots = [];
                var stack = Array.from(matchingFibers);
                var index = 0;
                while(index < stack.length){
                    var node = stack[index++];
                    if (node.tag === HostComponent) {
                        if (isHiddenSubtree(node)) {
                            continue;
                        }
                        instanceRoots.push(node.stateNode);
                    } else {
                        var child = node.child;
                        while(child !== null){
                            stack.push(child);
                            child = child.sibling;
                        }
                    }
                }
                return instanceRoots;
            }
            function getFindAllNodesFailureDescription(hostRoot, selectors) {
                if (!supportsTestSelectors) {
                    throw new Error('Test selector API is not supported by this renderer.');
                }
                var root = findFiberRootForHostRoot(hostRoot);
                var maxSelectorIndex = 0;
                var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()
                var stack = [
                    root,
                    0
                ];
                var index = 0;
                while(index < stack.length){
                    var fiber = stack[index++];
                    var selectorIndex = stack[index++];
                    var selector = selectors[selectorIndex];
                    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {
                        continue;
                    } else if (matchSelector(fiber, selector)) {
                        matchedNames.push(selectorToString(selector));
                        selectorIndex++;
                        if (selectorIndex > maxSelectorIndex) {
                            maxSelectorIndex = selectorIndex;
                        }
                    }
                    if (selectorIndex < selectors.length) {
                        var child = fiber.child;
                        while(child !== null){
                            stack.push(child, selectorIndex);
                            child = child.sibling;
                        }
                    }
                }
                if (maxSelectorIndex < selectors.length) {
                    var unmatchedNames = [];
                    for(var i = maxSelectorIndex; i < selectors.length; i++){
                        unmatchedNames.push(selectorToString(selectors[i]));
                    }
                    return 'findAllNodes was able to match part of the selector:\n' + ("  " + matchedNames.join(' > ') + "\n\n") + 'No matching component was found for:\n' + ("  " + unmatchedNames.join(' > '));
                }
                return null;
            }
            function findBoundingRects(hostRoot, selectors) {
                if (!supportsTestSelectors) {
                    throw new Error('Test selector API is not supported by this renderer.');
                }
                var instanceRoots = findAllNodes(hostRoot, selectors);
                var boundingRects = [];
                for(var i = 0; i < instanceRoots.length; i++){
                    boundingRects.push(getBoundingRect(instanceRoots[i]));
                }
                for(var _i = boundingRects.length - 1; _i > 0; _i--){
                    var targetRect = boundingRects[_i];
                    var targetLeft = targetRect.x;
                    var targetRight = targetLeft + targetRect.width;
                    var targetTop = targetRect.y;
                    var targetBottom = targetTop + targetRect.height;
                    for(var j = _i - 1; j >= 0; j--){
                        if (_i !== j) {
                            var otherRect = boundingRects[j];
                            var otherLeft = otherRect.x;
                            var otherRight = otherLeft + otherRect.width;
                            var otherTop = otherRect.y;
                            var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,
                            // but we can handle the most common cases:
                            // 1. completely overlapping rects
                            // 2. adjacent rects that are the same width or height (e.g. items in a list)
                            //
                            // Even given the above constraints,
                            // we still won't end up with the fewest possible rects without doing multiple passes,
                            // but it's good enough for this purpose.
                            if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
                                // Complete overlapping rects; remove the inner one.
                                boundingRects.splice(_i, 1);
                                break;
                            } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {
                                // Adjacent vertical rects; merge them.
                                if (otherTop > targetTop) {
                                    otherRect.height += otherTop - targetTop;
                                    otherRect.y = targetTop;
                                }
                                if (otherBottom < targetBottom) {
                                    otherRect.height = targetBottom - otherTop;
                                }
                                boundingRects.splice(_i, 1);
                                break;
                            } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {
                                // Adjacent horizontal rects; merge them.
                                if (otherLeft > targetLeft) {
                                    otherRect.width += otherLeft - targetLeft;
                                    otherRect.x = targetLeft;
                                }
                                if (otherRight < targetRight) {
                                    otherRect.width = targetRight - otherLeft;
                                }
                                boundingRects.splice(_i, 1);
                                break;
                            }
                        }
                    }
                }
                return boundingRects;
            }
            function focusWithin(hostRoot, selectors) {
                if (!supportsTestSelectors) {
                    throw new Error('Test selector API is not supported by this renderer.');
                }
                var root = findFiberRootForHostRoot(hostRoot);
                var matchingFibers = findPaths(root, selectors);
                var stack = Array.from(matchingFibers);
                var index = 0;
                while(index < stack.length){
                    var fiber = stack[index++];
                    if (isHiddenSubtree(fiber)) {
                        continue;
                    }
                    if (fiber.tag === HostComponent) {
                        var node = fiber.stateNode;
                        if (setFocusIfFocusable(node)) {
                            return true;
                        }
                    }
                    var child = fiber.child;
                    while(child !== null){
                        stack.push(child);
                        child = child.sibling;
                    }
                }
                return false;
            }
            var commitHooks = [];
            function onCommitRoot$1() {
                if (supportsTestSelectors) {
                    commitHooks.forEach(function(commitHook) {
                        return commitHook();
                    });
                }
            }
            function observeVisibleRects(hostRoot, selectors, callback, options) {
                if (!supportsTestSelectors) {
                    throw new Error('Test selector API is not supported by this renderer.');
                }
                var instanceRoots = findAllNodes(hostRoot, selectors);
                var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.
                var commitHook = function commitHook() {
                    var nextInstanceRoots = findAllNodes(hostRoot, selectors);
                    instanceRoots.forEach(function(target) {
                        if (nextInstanceRoots.indexOf(target) < 0) {
                            unobserve(target);
                        }
                    });
                    nextInstanceRoots.forEach(function(target) {
                        if (instanceRoots.indexOf(target) < 0) {
                            observe(target);
                        }
                    });
                };
                commitHooks.push(commitHook);
                return {
                    disconnect: function disconnect1() {
                        // Stop listening for React mutations:
                        var index = commitHooks.indexOf(commitHook);
                        if (index >= 0) {
                            commitHooks.splice(index, 1);
                        } // Disconnect the host observer:
                        disconnect();
                    }
                };
            }
            var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
            function isLegacyActEnvironment(fiber) {
                {
                    // Legacy mode. We preserve the behavior of React 17's act. It assumes an
                    // act environment whenever `jest` is defined, but you can still turn off
                    // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly
                    // to false.
                    var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest
                    var jestIsDefined = typeof jest !== 'undefined';
                    return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;
                }
            }
            function isConcurrentActEnvironment() {
                {
                    var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;
                    if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                        // TODO: Include link to relevant documentation page.
                        error('The current testing environment is not configured to support ' + 'act(...)');
                    }
                    return isReactActEnvironmentGlobal;
                }
            }
            var ceil = Math.ceil;
            var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
            var NoContext = /*             */ 0;
            var BatchedContext = /*               */ 1;
            var RenderContext = /*                */ 2;
            var CommitContext = /*                */ 4;
            var RootInProgress = 0;
            var RootFatalErrored = 1;
            var RootErrored = 2;
            var RootSuspended = 3;
            var RootSuspendedWithDelay = 4;
            var RootCompleted = 5;
            var RootDidNotComplete = 6; // Describes where we are in the React execution stack
            var executionContext = NoContext; // The root we're working on
            var workInProgressRoot = null; // The fiber we're working on
            var workInProgress = null; // The lanes we're rendering
            var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
            // This is a superset of the lanes we started working on at the root. The only
            // case where it's different from `workInProgressRootRenderLanes` is when we
            // enter a subtree that is hidden and needs to be unhidden: Suspense and
            // Offscreen component.
            //
            // Most things in the work loop should deal with workInProgressRootRenderLanes.
            // Most things in begin/complete phases should deal with subtreeRenderLanes.
            var subtreeRenderLanes = NoLanes;
            var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.
            var workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown
            var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
            // includes unprocessed updates, not work in bailed out children.
            var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.
            var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).
            var workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.
            var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.
            // We will log them once the tree commits.
            var workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train
            // model where we don't commit new loading states in too quick succession.
            var globalMostRecentFallbackTime = 0;
            var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
            // more and prefer CPU suspense heuristics instead.
            var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
            // suspense heuristics and opt out of rendering more content.
            var RENDER_TIMEOUT_MS = 500;
            var workInProgressTransitions = null;
            function resetRenderTimer() {
                workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
            }
            function getRenderTargetTime() {
                return workInProgressRootRenderTargetTime;
            }
            var hasUncaughtError = false;
            var firstUncaughtError = null;
            var legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;
            var rootDoesHavePassiveEffects = false;
            var rootWithPendingPassiveEffects = null;
            var pendingPassiveEffectsLanes = NoLanes;
            var pendingPassiveProfilerEffects = [];
            var pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates
            var NESTED_UPDATE_LIMIT = 50;
            var nestedUpdateCount = 0;
            var rootWithNestedUpdates = null;
            var isFlushingPassiveEffects = false;
            var didScheduleUpdateDuringPassiveEffects = false;
            var NESTED_PASSIVE_UPDATE_LIMIT = 50;
            var nestedPassiveUpdateCount = 0;
            var rootWithPassiveNestedUpdates = null; // If two updates are scheduled within the same event, we should treat their
            // event times as simultaneous, even if the actual clock time has advanced
            // between the first and second call.
            var currentEventTime = NoTimestamp;
            var currentEventTransitionLane = NoLanes;
            var isRunningInsertionEffect = false;
            function getWorkInProgressRoot() {
                return workInProgressRoot;
            }
            function requestEventTime() {
                if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                    // We're inside React, so it's fine to read the actual time.
                    return now();
                } // We're not inside React, so we may be in the middle of a browser event.
                if (currentEventTime !== NoTimestamp) {
                    // Use the same start time for all updates until we enter React again.
                    return currentEventTime;
                } // This is the first update since React yielded. Compute a new start time.
                currentEventTime = now();
                return currentEventTime;
            }
            function requestUpdateLane(fiber) {
                // Special cases
                var mode = fiber.mode;
                if ((mode & ConcurrentMode) === NoMode) {
                    return SyncLane;
                } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
                    // This is a render phase update. These are not officially supported. The
                    // old behavior is to give this the same "thread" (lanes) as
                    // whatever is currently rendering. So if you call `setState` on a component
                    // that happens later in the same render, it will flush. Ideally, we want to
                    // remove the special case and treat them as if they came from an
                    // interleaved event. Regardless, this pattern is not officially supported.
                    // This behavior is only a fallback. The flag only exists until we can roll
                    // out the setState warning, since existing code might accidentally rely on
                    // the current behavior.
                    return pickArbitraryLane(workInProgressRootRenderLanes);
                }
                var isTransition = requestCurrentTransition() !== NoTransition;
                if (isTransition) {
                    if (ReactCurrentBatchConfig$2.transition !== null) {
                        var transition = ReactCurrentBatchConfig$2.transition;
                        if (!transition._updatedFibers) {
                            transition._updatedFibers = new Set();
                        }
                        transition._updatedFibers.add(fiber);
                    } // The algorithm for assigning an update to a lane should be stable for all
                    // updates at the same priority within the same event. To do this, the
                    // inputs to the algorithm must be the same.
                    //
                    // The trick we use is to cache the first of each of these inputs within an
                    // event. Then reset the cached values once we can be sure the event is
                    // over. Our heuristic for that is whenever we enter a concurrent work loop.
                    if (currentEventTransitionLane === NoLane) {
                        // All transitions within the same event are assigned the same lane.
                        currentEventTransitionLane = claimNextTransitionLane();
                    }
                    return currentEventTransitionLane;
                } // Updates originating inside certain React methods, like flushSync, have
                // their priority set by tracking it with a context variable.
                //
                // The opaque type returned by the host config is internally a lane, so we can
                // use that directly.
                // TODO: Move this type conversion to the event priority module.
                var updateLane = getCurrentUpdatePriority();
                if (updateLane !== NoLane) {
                    return updateLane;
                } // This update originated outside React. Ask the host environment for an
                // appropriate priority, based on the type of event.
                //
                // The opaque type returned by the host config is internally a lane, so we can
                // use that directly.
                // TODO: Move this type conversion to the event priority module.
                var eventLane = getCurrentEventPriority();
                return eventLane;
            }
            function requestRetryLane(fiber) {
                // This is a fork of `requestUpdateLane` designed specifically for Suspense
                // "retries" — a special update that attempts to flip a Suspense boundary
                // from its placeholder state to its primary/resolved state.
                // Special cases
                var mode = fiber.mode;
                if ((mode & ConcurrentMode) === NoMode) {
                    return SyncLane;
                }
                return claimNextRetryLane();
            }
            function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
                checkForNestedUpdates();
                {
                    if (isRunningInsertionEffect) {
                        error('useInsertionEffect must not schedule updates.');
                    }
                }
                {
                    if (isFlushingPassiveEffects) {
                        didScheduleUpdateDuringPassiveEffects = true;
                    }
                }
                markRootUpdated(root, lane, eventTime);
                if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {
                    // This update was dispatched during the render phase. This is a mistake
                    // if the update originates from user space (with the exception of local
                    // hook updates, which are handled differently and don't reach this
                    // function), but there are some internal React features that use this as
                    // an implementation detail, like selective hydration.
                    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase
                } else {
                    // This is a normal update, scheduled from outside the render phase. For
                    // example, during an input event.
                    {
                        if (isDevToolsPresent) {
                            addFiberToLanesMap(root, fiber, lane);
                        }
                    }
                    warnIfUpdatesNotWrappedWithActDEV(fiber);
                    if (root === workInProgressRoot) {
                        // Received an update to a tree that's in the middle of rendering. Mark
                        // that there was an interleaved update work on this root. Unless the
                        // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
                        // phase update. In that case, we don't treat render phase updates as if
                        // they were interleaved, for backwards compat reasons.
                        if ((executionContext & RenderContext) === NoContext) {
                            workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                        }
                        if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                            // The root already suspended with a delay, which means this render
                            // definitely won't finish. Since we have a new update, let's mark it as
                            // suspended now, right before marking the incoming update. This has the
                            // effect of interrupting the current render and switching to the update.
                            // TODO: Make sure this doesn't override pings that happen while we've
                            // already started rendering.
                            markRootSuspended$1(root, workInProgressRootRenderLanes);
                        }
                    }
                    ensureRootIsScheduled(root, eventTime);
                    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
                    !ReactCurrentActQueue$1.isBatchingLegacy) {
                        // Flush the synchronous work now, unless we're already working or inside
                        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
                        // scheduleCallbackForFiber to preserve the ability to schedule a callback
                        // without immediately flushing it. We only do this for user-initiated
                        // updates, to preserve historical behavior of legacy mode.
                        resetRenderTimer();
                        flushSyncCallbacksOnlyInLegacyMode();
                    }
                }
            }
            function scheduleInitialHydrationOnRoot(root, lane, eventTime) {
                // This is a special fork of scheduleUpdateOnFiber that is only used to
                // schedule the initial hydration of a root that has just been created. Most
                // of the stuff in scheduleUpdateOnFiber can be skipped.
                //
                // The main reason for this separate path, though, is to distinguish the
                // initial children from subsequent updates. In fully client-rendered roots
                // (createRoot instead of hydrateRoot), all top-level renders are modeled as
                // updates, but hydration roots are special because the initial render must
                // match what was rendered on the server.
                var current = root.current;
                current.lanes = lane;
                markRootUpdated(root, lane, eventTime);
                ensureRootIsScheduled(root, eventTime);
            }
            function isUnsafeClassRenderPhaseUpdate(fiber) {
                // Check if this is a render phase update. Only called by class components,
                // which special (deprecated) behavior for UNSAFE_componentWillReceive props.
                return(// decided not to enable it.
                (executionContext & RenderContext) !== NoContext);
            } // Use this function to schedule a task for a root. There's only one task per
            // root; if a task was already scheduled, we'll check to make sure the priority
            // of the existing task is the same as the priority of the next level that the
            // root has work on. This function is called on every update, and right before
            // exiting a task.
            function ensureRootIsScheduled(root, currentTime) {
                var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
                // expired so we know to work on those next.
                markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.
                var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
                if (nextLanes === NoLanes) {
                    // Special case: There's nothing to work on.
                    if (existingCallbackNode !== null) {
                        cancelCallback$1(existingCallbackNode);
                    }
                    root.callbackNode = null;
                    root.callbackPriority = NoLane;
                    return;
                } // We use the highest priority lane to represent the priority of the callback.
                var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.
                var existingCallbackPriority = root.callbackPriority;
                if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
                // Scheduler task, rather than an `act` task, cancel it and re-scheduled
                // on the `act` queue.
                !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
                    {
                        // If we're going to re-use an existing task, it needs to exist.
                        // Assume that discrete update microtasks are non-cancellable and null.
                        // TODO: Temporary until we confirm this warning is not fired.
                        if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                            error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');
                        }
                    }
                    return;
                }
                if (existingCallbackNode != null) {
                    // Cancel the existing callback. We'll schedule a new one below.
                    cancelCallback$1(existingCallbackNode);
                } // Schedule a new callback.
                var newCallbackNode;
                if (newCallbackPriority === SyncLane) {
                    // Special case: Sync React callbacks are scheduled on a special
                    // internal queue
                    if (root.tag === LegacyRoot) {
                        if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                            ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                        }
                        scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
                    } else {
                        scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
                    }
                    if (supportsMicrotasks) {
                        // Flush the queue in a microtask.
                        if (ReactCurrentActQueue$1.current !== null) {
                            // Inside `act`, use our internal `act` queue so that these get flushed
                            // at the end of the current scope even when using the sync version
                            // of `act`.
                            ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                        } else {
                            scheduleMicrotask(function() {
                                // In Safari, appending an iframe forces microtasks to run.
                                // https://github.com/facebook/react/issues/22459
                                // We don't support running callbacks in the middle of render
                                // or commit so we need to check against that.
                                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                                    // Note that this would still prematurely flush the callbacks
                                    // if this happens outside render or commit phase (e.g. in an event).
                                    flushSyncCallbacks();
                                }
                            });
                        }
                    } else {
                        // Flush the queue in an Immediate task.
                        scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);
                    }
                    newCallbackNode = null;
                } else {
                    var schedulerPriorityLevel;
                    switch(lanesToEventPriority(nextLanes)){
                        case DiscreteEventPriority:
                            schedulerPriorityLevel = ImmediatePriority;
                            break;
                        case ContinuousEventPriority:
                            schedulerPriorityLevel = UserBlockingPriority;
                            break;
                        case DefaultEventPriority:
                            schedulerPriorityLevel = NormalPriority;
                            break;
                        case IdleEventPriority:
                            schedulerPriorityLevel = IdlePriority;
                            break;
                        default:
                            schedulerPriorityLevel = NormalPriority;
                            break;
                    }
                    newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
                }
                root.callbackPriority = newCallbackPriority;
                root.callbackNode = newCallbackNode;
            } // This is the entry point for every concurrent task, i.e. anything that
            // goes through Scheduler.
            function performConcurrentWorkOnRoot(root, didTimeout) {
                {
                    resetNestedUpdateFlag();
                }
                // event time. The next update will compute a new event time.
                currentEventTime = NoTimestamp;
                currentEventTransitionLane = NoLanes;
                if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                    throw new Error('Should not already be working.');
                } // Flush any pending passive effects before deciding which lanes to work on,
                // in case they schedule additional work.
                var originalCallbackNode = root.callbackNode;
                var didFlushPassiveEffects = flushPassiveEffects();
                if (didFlushPassiveEffects) {
                    // Something in the passive effect phase may have canceled the current task.
                    // Check if the task node for this root was changed.
                    if (root.callbackNode !== originalCallbackNode) {
                        // The current task was canceled. Exit. We don't need to call
                        // `ensureRootIsScheduled` because the check above implies either that
                        // there's a new task, or that there's no remaining work on this root.
                        return null;
                    }
                } // Determine the next lanes to work on, using the fields stored
                // on the root.
                var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
                if (lanes === NoLanes) {
                    // Defensive coding. This is never expected to happen.
                    return null;
                } // We disable time-slicing in some cases: if the work has been CPU-bound
                // for too long ("expired" work, to prevent starvation), or we're in
                // sync-updates-by-default mode.
                // TODO: We only check `didTimeout` defensively, to account for a Scheduler
                // bug we're still investigating. Once the bug in Scheduler is fixed,
                // we can remove this, since we track expiration ourselves.
                var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;
                var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
                if (exitStatus !== RootInProgress) {
                    if (exitStatus === RootErrored) {
                        // If something threw an error, try rendering one more time. We'll
                        // render synchronously to block concurrent data mutations, and we'll
                        // includes all pending updates are included. If it still fails after
                        // the second attempt, we'll give up and commit the resulting tree.
                        var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                        if (errorRetryLanes !== NoLanes) {
                            lanes = errorRetryLanes;
                            exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
                        }
                    }
                    if (exitStatus === RootFatalErrored) {
                        var fatalError = workInProgressRootFatalError;
                        prepareFreshStack(root, NoLanes);
                        markRootSuspended$1(root, lanes);
                        ensureRootIsScheduled(root, now());
                        throw fatalError;
                    }
                    if (exitStatus === RootDidNotComplete) {
                        // The render unwound without completing the tree. This happens in special
                        // cases where need to exit the current render without producing a
                        // consistent tree or committing.
                        //
                        // This should only happen during a concurrent render, not a discrete or
                        // synchronous update. We should have already checked for this when we
                        // unwound the stack.
                        markRootSuspended$1(root, lanes);
                    } else {
                        // The render completed.
                        // Check if this render may have yielded to a concurrent event, and if so,
                        // confirm that any newly rendered stores are consistent.
                        // TODO: It's possible that even a concurrent render may never have yielded
                        // to the main thread, if it was fast enough, or if it expired. We could
                        // skip the consistency check in that case, too.
                        var renderWasConcurrent = !includesBlockingLane(root, lanes);
                        var finishedWork = root.current.alternate;
                        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                            // A store was mutated in an interleaved event. Render again,
                            // synchronously, to block further mutations.
                            exitStatus = renderRootSync(root, lanes); // We need to check again if something threw
                            if (exitStatus === RootErrored) {
                                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                                if (_errorRetryLanes !== NoLanes) {
                                    lanes = _errorRetryLanes;
                                    exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any
                                // concurrent events.
                                }
                            }
                            if (exitStatus === RootFatalErrored) {
                                var _fatalError = workInProgressRootFatalError;
                                prepareFreshStack(root, NoLanes);
                                markRootSuspended$1(root, lanes);
                                ensureRootIsScheduled(root, now());
                                throw _fatalError;
                            }
                        } // We now have a consistent tree. The next step is either to commit it,
                        // or, if something suspended, wait to commit it after a timeout.
                        root.finishedWork = finishedWork;
                        root.finishedLanes = lanes;
                        finishConcurrentRender(root, exitStatus, lanes);
                    }
                }
                ensureRootIsScheduled(root, now());
                if (root.callbackNode === originalCallbackNode) {
                    // The task node scheduled for this root is the same one that's
                    // currently executed. Need to return a continuation.
                    return performConcurrentWorkOnRoot.bind(null, root);
                }
                return null;
            }
            function recoverFromConcurrentError(root, errorRetryLanes) {
                // If an error occurred during hydration, discard server response and fall
                // back to client side render.
                // Before rendering again, save the errors from the previous attempt.
                var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
                if (isRootDehydrated(root)) {
                    // The shell failed to hydrate. Set a flag to force a client rendering
                    // during the next attempt. To do this, we call prepareFreshStack now
                    // to create the root work-in-progress fiber. This is a bit weird in terms
                    // of factoring, because it relies on renderRootSync not calling
                    // prepareFreshStack again in the call below, which happens because the
                    // root and lanes haven't changed.
                    //
                    // TODO: I think what we should do is set ForceClientRender inside
                    // throwException, like we do for nested Suspense boundaries. The reason
                    // it's here instead is so we can switch to the synchronous work loop, too.
                    // Something to consider for a future refactor.
                    var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);
                    rootWorkInProgress.flags |= ForceClientRender;
                    {
                        errorHydratingContainer(root.containerInfo);
                    }
                }
                var exitStatus = renderRootSync(root, errorRetryLanes);
                if (exitStatus !== RootErrored) {
                    // Successfully finished rendering on retry
                    // The errors from the failed first attempt have been recovered. Add
                    // them to the collection of recoverable errors. We'll log them in the
                    // commit phase.
                    var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors
                    // from the first attempt, to preserve the causal sequence.
                    if (errorsFromSecondAttempt !== null) {
                        queueRecoverableErrors(errorsFromSecondAttempt);
                    }
                }
                return exitStatus;
            }
            function queueRecoverableErrors(errors) {
                if (workInProgressRootRecoverableErrors === null) {
                    workInProgressRootRecoverableErrors = errors;
                } else {
                    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
                }
            }
            function finishConcurrentRender(root, exitStatus, lanes) {
                switch(exitStatus){
                    case RootInProgress:
                    case RootFatalErrored:
                        {
                            throw new Error('Root did not complete. This is a bug in React.');
                        }
                    // Flow knows about invariant, so it complains if I add a break
                    // statement, but eslint doesn't know about invariant, so it complains
                    // if I do. eslint-disable-next-line no-fallthrough
                    case RootErrored:
                        {
                            // We should have already attempted to retry this tree. If we reached
                            // this point, it errored again. Commit it.
                            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                            break;
                        }
                    case RootSuspended:
                        {
                            markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
                            // should immediately commit it or wait a bit.
                            if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                            !shouldForceFlushFallbacksInDEV()) {
                                // This render only included retries, no updates. Throttle committing
                                // retries so that we don't show too many loading states too quickly.
                                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
                                if (msUntilTimeout > 10) {
                                    var nextLanes = getNextLanes(root, NoLanes);
                                    if (nextLanes !== NoLanes) {
                                        break;
                                    }
                                    var suspendedLanes = root.suspendedLanes;
                                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                                        // We should prefer to render the fallback of at the last
                                        // suspended level. Ping the last suspended level to try
                                        // rendering it again.
                                        // FIXME: What if the suspended lanes are Idle? Should not restart.
                                        requestEventTime();
                                        markRootPinged(root, suspendedLanes);
                                        break;
                                    } // The render is suspended, it hasn't timed out, and there's no
                                    // lower priority work to do. Instead of committing the fallback
                                    // immediately, wait for more data to arrive.
                                    root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                                    break;
                                }
                            } // The work expired. Commit immediately.
                            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                            break;
                        }
                    case RootSuspendedWithDelay:
                        {
                            markRootSuspended$1(root, lanes);
                            if (includesOnlyTransitions(lanes)) {
                                break;
                            }
                            if (!shouldForceFlushFallbacksInDEV()) {
                                // This is not a transition, but we did trigger an avoided state.
                                // Schedule a placeholder to display after a short delay, using the Just
                                // Noticeable Difference.
                                // TODO: Is the JND optimization worth the added complexity? If this is
                                // the only reason we track the event time, then probably not.
                                // Consider removing.
                                var mostRecentEventTime = getMostRecentEventTime(root, lanes);
                                var eventTimeMs = mostRecentEventTime;
                                var timeElapsedMs = now() - eventTimeMs;
                                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.
                                if (_msUntilTimeout > 10) {
                                    // Instead of committing the fallback immediately, wait for more data
                                    // to arrive.
                                    root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                                    break;
                                }
                            } // Commit the placeholder.
                            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                            break;
                        }
                    case RootCompleted:
                        {
                            // The work completed. Ready to commit.
                            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
                            break;
                        }
                    default:
                        {
                            throw new Error('Unknown root exit status.');
                        }
                }
            }
            function isRenderConsistentWithExternalStores(finishedWork) {
                // Search the rendered tree for external store reads, and check whether the
                // stores were mutated in a concurrent event. Intentionally using an iterative
                // loop instead of recursion so we can exit early.
                var node = finishedWork;
                while(true){
                    if (node.flags & StoreConsistency) {
                        var updateQueue = node.updateQueue;
                        if (updateQueue !== null) {
                            var checks = updateQueue.stores;
                            if (checks !== null) {
                                for(var i = 0; i < checks.length; i++){
                                    var check = checks[i];
                                    var getSnapshot = check.getSnapshot;
                                    var renderedValue = check.value;
                                    try {
                                        if (!objectIs(getSnapshot(), renderedValue)) {
                                            // Found an inconsistent store.
                                            return false;
                                        }
                                    } catch (error) {
                                        // If `getSnapshot` throws, return `false`. This will schedule
                                        // a re-render, and the error will be rethrown during render.
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                    var child = node.child;
                    if (node.subtreeFlags & StoreConsistency && child !== null) {
                        child.return = node;
                        node = child;
                        continue;
                    }
                    if (node === finishedWork) {
                        return true;
                    }
                    while(node.sibling === null){
                        if (node.return === null || node.return === finishedWork) {
                            return true;
                        }
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                } // Flow doesn't know this is unreachable, but eslint does
                // eslint-disable-next-line no-unreachable
                return true;
            }
            function markRootSuspended$1(root, suspendedLanes) {
                // When suspending, we should always exclude lanes that were pinged or (more
                // rarely, since we try to avoid it) updated during the render phase.
                // TODO: Lol maybe there's a better way to factor this besides this
                // obnoxiously named function :)
                suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
                suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
                markRootSuspended(root, suspendedLanes);
            } // This is the entry point for synchronous tasks that don't go
            // through Scheduler
            function performSyncWorkOnRoot(root) {
                {
                    syncNestedUpdateFlag();
                }
                if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                    throw new Error('Should not already be working.');
                }
                flushPassiveEffects();
                var lanes = getNextLanes(root, NoLanes);
                if (!includesSomeLane(lanes, SyncLane)) {
                    // There's no remaining sync work left.
                    ensureRootIsScheduled(root, now());
                    return null;
                }
                var exitStatus = renderRootSync(root, lanes);
                if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
                    // If something threw an error, try rendering one more time. We'll render
                    // synchronously to block concurrent data mutations, and we'll includes
                    // all pending updates are included. If it still fails after the second
                    // attempt, we'll give up and commit the resulting tree.
                    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                    if (errorRetryLanes !== NoLanes) {
                        lanes = errorRetryLanes;
                        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
                    }
                }
                if (exitStatus === RootFatalErrored) {
                    var fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root, NoLanes);
                    markRootSuspended$1(root, lanes);
                    ensureRootIsScheduled(root, now());
                    throw fatalError;
                }
                if (exitStatus === RootDidNotComplete) {
                    throw new Error('Root did not complete. This is a bug in React.');
                } // We now have a consistent tree. Because this is a sync render, we
                // will commit it even if something suspended.
                var finishedWork = root.current.alternate;
                root.finishedWork = finishedWork;
                root.finishedLanes = lanes;
                commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); // Before exiting, make sure there's a callback scheduled for the next
                // pending level.
                ensureRootIsScheduled(root, now());
                return null;
            }
            function flushRoot(root, lanes) {
                if (lanes !== NoLanes) {
                    markRootEntangled(root, mergeLanes(lanes, SyncLane));
                    ensureRootIsScheduled(root, now());
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                        resetRenderTimer();
                        flushSyncCallbacks();
                    }
                }
            }
            function deferredUpdates(fn) {
                var previousPriority = getCurrentUpdatePriority();
                var prevTransition = ReactCurrentBatchConfig$2.transition;
                try {
                    ReactCurrentBatchConfig$2.transition = null;
                    setCurrentUpdatePriority(DefaultEventPriority);
                    return fn();
                } finally{
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$2.transition = prevTransition;
                }
            }
            function batchedUpdates(fn, a) {
                var prevExecutionContext = executionContext;
                executionContext |= BatchedContext;
                try {
                    return fn(a);
                } finally{
                    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer
                    // most batchedUpdates-like method.
                    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
                    !ReactCurrentActQueue$1.isBatchingLegacy) {
                        resetRenderTimer();
                        flushSyncCallbacksOnlyInLegacyMode();
                    }
                }
            }
            function discreteUpdates(fn, a, b, c, d) {
                var previousPriority = getCurrentUpdatePriority();
                var prevTransition = ReactCurrentBatchConfig$2.transition;
                try {
                    ReactCurrentBatchConfig$2.transition = null;
                    setCurrentUpdatePriority(DiscreteEventPriority);
                    return fn(a, b, c, d);
                } finally{
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$2.transition = prevTransition;
                    if (executionContext === NoContext) {
                        resetRenderTimer();
                    }
                }
            } // Overload the definition to the two valid signatures.
            // Warning, this opts-out of checking the function body.
            // eslint-disable-next-line no-redeclare
            function flushSync(fn) {
                // In legacy mode, we flush pending passive effects at the beginning of the
                // next event, not at the end of the previous one.
                if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushPassiveEffects();
                }
                var prevExecutionContext = executionContext;
                executionContext |= BatchedContext;
                var prevTransition = ReactCurrentBatchConfig$2.transition;
                var previousPriority = getCurrentUpdatePriority();
                try {
                    ReactCurrentBatchConfig$2.transition = null;
                    setCurrentUpdatePriority(DiscreteEventPriority);
                    if (fn) {
                        return fn();
                    } else {
                        return undefined;
                    }
                } finally{
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$2.transition = prevTransition;
                    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
                    // Note that this will happen even if batchedUpdates is higher up
                    // the stack.
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                        flushSyncCallbacks();
                    }
                }
            }
            function isAlreadyRendering() {
                // Used by the renderer to print a warning if certain APIs are called from
                // the wrong context.
                return (executionContext & (RenderContext | CommitContext)) !== NoContext;
            }
            function flushControlled(fn) {
                var prevExecutionContext = executionContext;
                executionContext |= BatchedContext;
                var prevTransition = ReactCurrentBatchConfig$2.transition;
                var previousPriority = getCurrentUpdatePriority();
                try {
                    ReactCurrentBatchConfig$2.transition = null;
                    setCurrentUpdatePriority(DiscreteEventPriority);
                    fn();
                } finally{
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$2.transition = prevTransition;
                    executionContext = prevExecutionContext;
                    if (executionContext === NoContext) {
                        // Flush the immediate callbacks that were scheduled during this batch
                        resetRenderTimer();
                        flushSyncCallbacks();
                    }
                }
            }
            function pushRenderLanes(fiber, lanes) {
                push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
                subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            }
            function popRenderLanes(fiber) {
                subtreeRenderLanes = subtreeRenderLanesCursor.current;
                pop(subtreeRenderLanesCursor, fiber);
            }
            function prepareFreshStack(root, lanes) {
                root.finishedWork = null;
                root.finishedLanes = NoLanes;
                var timeoutHandle = root.timeoutHandle;
                if (timeoutHandle !== noTimeout) {
                    // The root previous suspended and scheduled a timeout to commit a fallback
                    // state. Now that we have additional work, cancel the timeout.
                    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
                    cancelTimeout(timeoutHandle);
                }
                if (workInProgress !== null) {
                    var interruptedWork = workInProgress.return;
                    while(interruptedWork !== null){
                        var current = interruptedWork.alternate;
                        unwindInterruptedWork(current, interruptedWork);
                        interruptedWork = interruptedWork.return;
                    }
                }
                workInProgressRoot = root;
                var rootWorkInProgress = createWorkInProgress(root.current, null);
                workInProgress = rootWorkInProgress;
                workInProgressRootRenderLanes = subtreeRenderLanes = lanes;
                workInProgressRootExitStatus = RootInProgress;
                workInProgressRootFatalError = null;
                workInProgressRootSkippedLanes = NoLanes;
                workInProgressRootInterleavedUpdatedLanes = NoLanes;
                workInProgressRootPingedLanes = NoLanes;
                workInProgressRootConcurrentErrors = null;
                workInProgressRootRecoverableErrors = null;
                finishQueueingConcurrentUpdates();
                {
                    ReactStrictModeWarnings.discardPendingWarnings();
                }
                return rootWorkInProgress;
            }
            function handleError(root, thrownValue) {
                do {
                    var erroredWork = workInProgress;
                    try {
                        // Reset module-level state that was set during the render phase.
                        resetContextDependencies();
                        resetHooksAfterThrow();
                        resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
                        // separate issue. Write a regression test using string refs.
                        ReactCurrentOwner$2.current = null;
                        if (erroredWork === null || erroredWork.return === null) {
                            // Expected to be working on a non-root fiber. This is a fatal error
                            // because there's no ancestor that can handle it; the root is
                            // supposed to capture all errors that weren't caught by an error
                            // boundary.
                            workInProgressRootExitStatus = RootFatalErrored;
                            workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
                            // sibling, or the parent if there are no siblings. But since the root
                            // has no siblings nor a parent, we set it to null. Usually this is
                            // handled by `completeUnitOfWork` or `unwindWork`, but since we're
                            // intentionally not calling those, we need set it here.
                            // TODO: Consider calling `unwindWork` to pop the contexts.
                            workInProgress = null;
                            return;
                        }
                        if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                            // Record the time spent rendering before an error was thrown. This
                            // avoids inaccurate Profiler durations in the case of a
                            // suspended render.
                            stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                        }
                        if (enableSchedulingProfiler) {
                            markComponentRenderStopped();
                            if (thrownValue !== null && (typeof thrownValue === "undefined" ? "undefined" : _type_of(thrownValue)) === 'object' && typeof thrownValue.then === 'function') {
                                var wakeable = thrownValue;
                                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                            } else {
                                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                            }
                        }
                        throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                        completeUnitOfWork(erroredWork);
                    } catch (yetAnotherThrownValue) {
                        // Something in the return path also threw.
                        thrownValue = yetAnotherThrownValue;
                        if (workInProgress === erroredWork && erroredWork !== null) {
                            // If this boundary has already errored, then we had trouble processing
                            // the error. Bubble it to the next boundary.
                            erroredWork = erroredWork.return;
                            workInProgress = erroredWork;
                        } else {
                            erroredWork = workInProgress;
                        }
                        continue;
                    } // Return to the normal work loop.
                    return;
                }while (true);
            }
            function pushDispatcher() {
                var prevDispatcher = ReactCurrentDispatcher$2.current;
                ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
                if (prevDispatcher === null) {
                    // The React isomorphic package does not include a default dispatcher.
                    // Instead the first renderer will lazily attach one, in order to give
                    // nicer error messages.
                    return ContextOnlyDispatcher;
                } else {
                    return prevDispatcher;
                }
            }
            function popDispatcher(prevDispatcher) {
                ReactCurrentDispatcher$2.current = prevDispatcher;
            }
            function markCommitTimeOfFallback() {
                globalMostRecentFallbackTime = now();
            }
            function markSkippedUpdateLanes(lane) {
                workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
            }
            function renderDidSuspend() {
                if (workInProgressRootExitStatus === RootInProgress) {
                    workInProgressRootExitStatus = RootSuspended;
                }
            }
            function renderDidSuspendDelayIfPossible() {
                if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
                    workInProgressRootExitStatus = RootSuspendedWithDelay;
                } // Check if there are updates that we skipped tree that might have unblocked
                // this render.
                if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
                    // Mark the current render as suspended so that we switch to working on
                    // the updates that were skipped. Usually we only suspend at the end of
                    // the render phase.
                    // TODO: We should probably always mark the root as suspended immediately
                    // (inside this function), since by suspending at the end of the render
                    // phase introduces a potential mistake where we suspend lanes that were
                    // pinged or updated while we were rendering.
                    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
                }
            }
            function renderDidError(error) {
                if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
                    workInProgressRootExitStatus = RootErrored;
                }
                if (workInProgressRootConcurrentErrors === null) {
                    workInProgressRootConcurrentErrors = [
                        error
                    ];
                } else {
                    workInProgressRootConcurrentErrors.push(error);
                }
            } // Called during render to determine if anything has suspended.
            // Returns false if we're not sure.
            function renderHasNotSuspendedYet() {
                // If something errored or completed, we can't really be sure,
                // so those are false.
                return workInProgressRootExitStatus === RootInProgress;
            }
            function renderRootSync(root, lanes) {
                var prevExecutionContext = executionContext;
                executionContext |= RenderContext;
                var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
                // and prepare a fresh one. Otherwise we'll continue where we left off.
                if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
                    {
                        if (isDevToolsPresent) {
                            var memoizedUpdaters = root.memoizedUpdaters;
                            if (memoizedUpdaters.size > 0) {
                                restorePendingUpdaters(root, workInProgressRootRenderLanes);
                                memoizedUpdaters.clear();
                            } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
                            // If we bailout on this work, we'll move them back (like above).
                            // It's important to move them now in case the work spawns more work at the same priority with different updaters.
                            // That way we can keep the current update and future updates separate.
                            movePendingFibersToMemoized(root, lanes);
                        }
                    }
                    workInProgressTransitions = getTransitionsForLanes();
                    prepareFreshStack(root, lanes);
                }
                {
                    markRenderStarted(lanes);
                }
                do {
                    try {
                        workLoopSync();
                        break;
                    } catch (thrownValue) {
                        handleError(root, thrownValue);
                    }
                }while (true);
                resetContextDependencies();
                executionContext = prevExecutionContext;
                popDispatcher(prevDispatcher);
                if (workInProgress !== null) {
                    // This is a sync render, so we should have finished the whole tree.
                    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');
                }
                {
                    markRenderStopped();
                }
                workInProgressRoot = null;
                workInProgressRootRenderLanes = NoLanes;
                return workInProgressRootExitStatus;
            } // The work loop is an extremely hot path. Tell Closure not to inline it.
            /** @noinline */ function workLoopSync() {
                // Already timed out, so perform work without checking if we need to yield.
                while(workInProgress !== null){
                    performUnitOfWork(workInProgress);
                }
            }
            function renderRootConcurrent(root, lanes) {
                var prevExecutionContext = executionContext;
                executionContext |= RenderContext;
                var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
                // and prepare a fresh one. Otherwise we'll continue where we left off.
                if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
                    {
                        if (isDevToolsPresent) {
                            var memoizedUpdaters = root.memoizedUpdaters;
                            if (memoizedUpdaters.size > 0) {
                                restorePendingUpdaters(root, workInProgressRootRenderLanes);
                                memoizedUpdaters.clear();
                            } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
                            // If we bailout on this work, we'll move them back (like above).
                            // It's important to move them now in case the work spawns more work at the same priority with different updaters.
                            // That way we can keep the current update and future updates separate.
                            movePendingFibersToMemoized(root, lanes);
                        }
                    }
                    workInProgressTransitions = getTransitionsForLanes();
                    resetRenderTimer();
                    prepareFreshStack(root, lanes);
                }
                {
                    markRenderStarted(lanes);
                }
                do {
                    try {
                        workLoopConcurrent();
                        break;
                    } catch (thrownValue) {
                        handleError(root, thrownValue);
                    }
                }while (true);
                resetContextDependencies();
                popDispatcher(prevDispatcher);
                executionContext = prevExecutionContext;
                if (workInProgress !== null) {
                    // Still work remaining.
                    {
                        markRenderYielded();
                    }
                    return RootInProgress;
                } else {
                    // Completed the tree.
                    {
                        markRenderStopped();
                    }
                    workInProgressRoot = null;
                    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.
                    return workInProgressRootExitStatus;
                }
            }
            /** @noinline */ function workLoopConcurrent() {
                // Perform work until Scheduler asks us to yield
                while(workInProgress !== null && !shouldYield()){
                    performUnitOfWork(workInProgress);
                }
            }
            function performUnitOfWork(unitOfWork) {
                // The current, flushed, state of this fiber is the alternate. Ideally
                // nothing should rely on this, but relying on it here means that we don't
                // need an additional field on the work in progress.
                var current = unitOfWork.alternate;
                setCurrentFiber(unitOfWork);
                var next;
                if ((unitOfWork.mode & ProfileMode) !== NoMode) {
                    startProfilerTimer(unitOfWork);
                    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
                    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
                } else {
                    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
                }
                resetCurrentFiber();
                unitOfWork.memoizedProps = unitOfWork.pendingProps;
                if (next === null) {
                    // If this doesn't spawn new work, complete the current work.
                    completeUnitOfWork(unitOfWork);
                } else {
                    workInProgress = next;
                }
                ReactCurrentOwner$2.current = null;
            }
            function completeUnitOfWork(unitOfWork) {
                // Attempt to complete the current unit of work, then move to the next
                // sibling. If there are no more siblings, return to the parent fiber.
                var completedWork = unitOfWork;
                do {
                    // The current, flushed, state of this fiber is the alternate. Ideally
                    // nothing should rely on this, but relying on it here means that we don't
                    // need an additional field on the work in progress.
                    var current = completedWork.alternate;
                    var returnFiber = completedWork.return; // Check if the work completed or if something threw.
                    if ((completedWork.flags & Incomplete) === NoFlags) {
                        setCurrentFiber(completedWork);
                        var next = void 0;
                        if ((completedWork.mode & ProfileMode) === NoMode) {
                            next = completeWork(current, completedWork, subtreeRenderLanes);
                        } else {
                            startProfilerTimer(completedWork);
                            next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.
                            stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                        }
                        resetCurrentFiber();
                        if (next !== null) {
                            // Completing this fiber spawned new work. Work on that next.
                            workInProgress = next;
                            return;
                        }
                    } else {
                        // This fiber did not complete because something threw. Pop values off
                        // the stack without entering the complete phase. If this is a boundary,
                        // capture values if possible.
                        var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.
                        if (_next !== null) {
                            // If completing this work spawned new work, do that next. We'll come
                            // back here again.
                            // Since we're restarting, remove anything that is not a host effect
                            // from the effect tag.
                            _next.flags &= HostEffectMask;
                            workInProgress = _next;
                            return;
                        }
                        if ((completedWork.mode & ProfileMode) !== NoMode) {
                            // Record the render duration for the fiber that errored.
                            stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.
                            var actualDuration = completedWork.actualDuration;
                            var child = completedWork.child;
                            while(child !== null){
                                actualDuration += child.actualDuration;
                                child = child.sibling;
                            }
                            completedWork.actualDuration = actualDuration;
                        }
                        if (returnFiber !== null) {
                            // Mark the parent fiber as incomplete and clear its subtree flags.
                            returnFiber.flags |= Incomplete;
                            returnFiber.subtreeFlags = NoFlags;
                            returnFiber.deletions = null;
                        } else {
                            // We've unwound all the way to the root.
                            workInProgressRootExitStatus = RootDidNotComplete;
                            workInProgress = null;
                            return;
                        }
                    }
                    var siblingFiber = completedWork.sibling;
                    if (siblingFiber !== null) {
                        // If there is more work to do in this returnFiber, do that next.
                        workInProgress = siblingFiber;
                        return;
                    } // Otherwise, return to the parent
                    completedWork = returnFiber; // Update the next thing we're working on in case something throws.
                    workInProgress = completedWork;
                }while (completedWork !== null); // We've reached the root.
                if (workInProgressRootExitStatus === RootInProgress) {
                    workInProgressRootExitStatus = RootCompleted;
                }
            }
            function commitRoot(root, recoverableErrors, transitions) {
                // TODO: This no longer makes any sense. We already wrap the mutation and
                // layout phases. Should be able to remove.
                var previousUpdateLanePriority = getCurrentUpdatePriority();
                var prevTransition = ReactCurrentBatchConfig$2.transition;
                try {
                    ReactCurrentBatchConfig$2.transition = null;
                    setCurrentUpdatePriority(DiscreteEventPriority);
                    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);
                } finally{
                    ReactCurrentBatchConfig$2.transition = prevTransition;
                    setCurrentUpdatePriority(previousUpdateLanePriority);
                }
                return null;
            }
            function commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {
                do {
                    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
                    // means `flushPassiveEffects` will sometimes result in additional
                    // passive effects. So we need to keep flushing in a loop until there are
                    // no more pending effects.
                    // TODO: Might be better if `flushPassiveEffects` did not automatically
                    // flush synchronous work at the end, to avoid factoring hazards like this.
                    flushPassiveEffects();
                }while (rootWithPendingPassiveEffects !== null);
                flushRenderPhaseStrictModeWarningsInDEV();
                if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                    throw new Error('Should not already be working.');
                }
                var finishedWork = root.finishedWork;
                var lanes = root.finishedLanes;
                {
                    markCommitStarted(lanes);
                }
                if (finishedWork === null) {
                    {
                        markCommitStopped();
                    }
                    return null;
                } else {
                    {
                        if (lanes === NoLanes) {
                            error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');
                        }
                    }
                }
                root.finishedWork = null;
                root.finishedLanes = NoLanes;
                if (finishedWork === root.current) {
                    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');
                } // commitRoot never returns a continuation; it always finishes synchronously.
                // So we can clear these now to allow a new callback to be scheduled.
                root.callbackNode = null;
                root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first
                // pending time is whatever is left on the root fiber.
                var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
                markRootFinished(root, remainingLanes);
                if (root === workInProgressRoot) {
                    // We can reset these now that they are finished.
                    workInProgressRoot = null;
                    workInProgress = null;
                    workInProgressRootRenderLanes = NoLanes;
                } // If there are pending passive effects, schedule a callback to process them.
                // Do this as early as possible, so it is queued before anything else that
                // might get scheduled in the commit phase. (See #16714.)
                // TODO: Delete all other places that schedule the passive effect callback
                // They're redundant.
                if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
                    if (!rootDoesHavePassiveEffects) {
                        rootDoesHavePassiveEffects = true;
                        // to store it in pendingPassiveTransitions until they get processed
                        // We need to pass this through as an argument to commitRoot
                        // because workInProgressTransitions might have changed between
                        // the previous render and commit if we throttle the commit
                        // with setTimeout
                        pendingPassiveTransitions = transitions;
                        scheduleCallback$1(NormalPriority, function() {
                            flushPassiveEffects(); // This render triggered passive effects: release the root cache pool
                            // *after* passive effects fire to avoid freeing a cache pool that may
                            // be referenced by a node in the tree (HostRoot, Cache boundary etc)
                            return null;
                        });
                    }
                } // Check if there are any effects in the whole tree.
                // TODO: This is left over from the effect list implementation, where we had
                // to check for the existence of `firstEffect` to satisfy Flow. I think the
                // only other reason this optimization exists is because it affects profiling.
                // Reconsider whether this is necessary.
                var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
                var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
                if (subtreeHasEffects || rootHasEffect) {
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    ReactCurrentBatchConfig$2.transition = null;
                    var previousPriority = getCurrentUpdatePriority();
                    setCurrentUpdatePriority(DiscreteEventPriority);
                    var prevExecutionContext = executionContext;
                    executionContext |= CommitContext; // Reset this to null before calling lifecycles
                    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
                    // of the effect list for each phase: all mutation effects come before all
                    // layout effects, and so on.
                    // The first phase a "before mutation" phase. We use this phase to read the
                    // state of the host tree right before we mutate it. This is where
                    // getSnapshotBeforeUpdate is called.
                    commitBeforeMutationEffects(root, finishedWork);
                    {
                        // Mark the current commit time to be shared by all Profilers in this
                        // batch. This enables them to be grouped later.
                        recordCommitTime();
                    }
                    commitMutationEffects(root, finishedWork, lanes);
                    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
                    // the mutation phase, so that the previous tree is still current during
                    // componentWillUnmount, but before the layout phase, so that the finished
                    // work is current during componentDidMount/Update.
                    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
                    {
                        markLayoutEffectsStarted(lanes);
                    }
                    commitLayoutEffects(finishedWork, root, lanes);
                    {
                        markLayoutEffectsStopped();
                    }
                    // opportunity to paint.
                    requestPaint();
                    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.
                    setCurrentUpdatePriority(previousPriority);
                    ReactCurrentBatchConfig$2.transition = prevTransition;
                } else {
                    // No effects.
                    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
                    // no effects.
                    // TODO: Maybe there's a better way to report this.
                    {
                        recordCommitTime();
                    }
                }
                var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
                if (rootDoesHavePassiveEffects) {
                    // This commit has passive effects. Stash a reference to them. But don't
                    // schedule a callback until after flushing layout work.
                    rootDoesHavePassiveEffects = false;
                    rootWithPendingPassiveEffects = root;
                    pendingPassiveEffectsLanes = lanes;
                } else {
                    {
                        nestedPassiveUpdateCount = 0;
                        rootWithPassiveNestedUpdates = null;
                    }
                } // Read this again, since an effect might have updated it
                remainingLanes = root.pendingLanes; // Check if there's remaining work on this root
                // TODO: This is part of the `componentDidCatch` implementation. Its purpose
                // is to detect whether something might have called setState inside
                // `componentDidCatch`. The mechanism is known to be flawed because `setState`
                // inside `componentDidCatch` is itself flawed — that's why we recommend
                // `getDerivedStateFromError` instead. However, it could be improved by
                // checking if remainingLanes includes Sync work, instead of whether there's
                // any work remaining at all (which would also include stuff like Suspense
                // retries or transitions). It's been like this for a while, though, so fixing
                // it probably isn't that urgent.
                if (remainingLanes === NoLanes) {
                    // If there's no remaining work, we can clear the set of already failed
                    // error boundaries.
                    legacyErrorBoundariesThatAlreadyFailed = null;
                }
                {
                    if (!rootDidHavePassiveEffects) {
                        commitDoubleInvokeEffectsInDEV(root.current, false);
                    }
                }
                onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
                {
                    if (isDevToolsPresent) {
                        root.memoizedUpdaters.clear();
                    }
                }
                {
                    onCommitRoot$1();
                }
                // additional work on this root is scheduled.
                ensureRootIsScheduled(root, now());
                if (recoverableErrors !== null) {
                    // There were errors during this render, but recovered from them without
                    // needing to surface it to the UI. We log them here.
                    var onRecoverableError = root.onRecoverableError;
                    for(var i = 0; i < recoverableErrors.length; i++){
                        var recoverableError = recoverableErrors[i];
                        var componentStack = recoverableError.stack;
                        var digest = recoverableError.digest;
                        onRecoverableError(recoverableError.value, {
                            componentStack: componentStack,
                            digest: digest
                        });
                    }
                }
                if (hasUncaughtError) {
                    hasUncaughtError = false;
                    var error$1 = firstUncaughtError;
                    firstUncaughtError = null;
                    throw error$1;
                } // If the passive effects are the result of a discrete render, flush them
                // synchronously at the end of the current task so that the result is
                // immediately observable. Otherwise, we assume that they are not
                // order-dependent and do not need to be observed by external systems, so we
                // can wait until after paint.
                // TODO: We can optimize this by not scheduling the callback earlier. Since we
                // currently schedule the callback in multiple places, will wait until those
                // are consolidated.
                if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {
                    flushPassiveEffects();
                } // Read this again, since a passive effect might have updated it
                remainingLanes = root.pendingLanes;
                if (includesSomeLane(remainingLanes, SyncLane)) {
                    {
                        markNestedUpdateScheduled();
                    }
                    // finishing. If there are too many, it indicates an infinite update loop.
                    if (root === rootWithNestedUpdates) {
                        nestedUpdateCount++;
                    } else {
                        nestedUpdateCount = 0;
                        rootWithNestedUpdates = root;
                    }
                } else {
                    nestedUpdateCount = 0;
                } // If layout work was scheduled, flush it now.
                flushSyncCallbacks();
                {
                    markCommitStopped();
                }
                return null;
            }
            function flushPassiveEffects() {
                // Returns whether passive effects were flushed.
                // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should
                // probably just combine the two functions. I believe they were only separate
                // in the first place because we used to wrap it with
                // `Scheduler.runWithPriority`, which accepts a function. But now we track the
                // priority within React itself, so we can mutate the variable directly.
                if (rootWithPendingPassiveEffects !== null) {
                    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
                    var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
                    var prevTransition = ReactCurrentBatchConfig$2.transition;
                    var previousPriority = getCurrentUpdatePriority();
                    try {
                        ReactCurrentBatchConfig$2.transition = null;
                        setCurrentUpdatePriority(priority);
                        return flushPassiveEffectsImpl();
                    } finally{
                        setCurrentUpdatePriority(previousPriority);
                        ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a
                    }
                }
                return false;
            }
            function enqueuePendingPassiveProfilerEffect(fiber) {
                {
                    pendingPassiveProfilerEffects.push(fiber);
                    if (!rootDoesHavePassiveEffects) {
                        rootDoesHavePassiveEffects = true;
                        scheduleCallback$1(NormalPriority, function() {
                            flushPassiveEffects();
                            return null;
                        });
                    }
                }
            }
            function flushPassiveEffectsImpl() {
                if (rootWithPendingPassiveEffects === null) {
                    return false;
                } // Cache and clear the transitions flag
                var transitions = pendingPassiveTransitions;
                pendingPassiveTransitions = null;
                var root = rootWithPendingPassiveEffects;
                var lanes = pendingPassiveEffectsLanes;
                rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.
                // Figure out why and fix it. It's not causing any known issues (probably
                // because it's only used for profiling), but it's a refactor hazard.
                pendingPassiveEffectsLanes = NoLanes;
                if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                    throw new Error('Cannot flush passive effects while already rendering.');
                }
                {
                    isFlushingPassiveEffects = true;
                    didScheduleUpdateDuringPassiveEffects = false;
                }
                {
                    markPassiveEffectsStarted(lanes);
                }
                var prevExecutionContext = executionContext;
                executionContext |= CommitContext;
                commitPassiveUnmountEffects(root.current);
                commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects
                {
                    var profilerEffects = pendingPassiveProfilerEffects;
                    pendingPassiveProfilerEffects = [];
                    for(var i = 0; i < profilerEffects.length; i++){
                        var _fiber = profilerEffects[i];
                        commitPassiveEffectDurations(root, _fiber);
                    }
                }
                {
                    markPassiveEffectsStopped();
                }
                {
                    commitDoubleInvokeEffectsInDEV(root.current, true);
                }
                executionContext = prevExecutionContext;
                flushSyncCallbacks();
                {
                    // If additional passive effects were scheduled, increment a counter. If this
                    // exceeds the limit, we'll fire a warning.
                    if (didScheduleUpdateDuringPassiveEffects) {
                        if (root === rootWithPassiveNestedUpdates) {
                            nestedPassiveUpdateCount++;
                        } else {
                            nestedPassiveUpdateCount = 0;
                            rootWithPassiveNestedUpdates = root;
                        }
                    } else {
                        nestedPassiveUpdateCount = 0;
                    }
                    isFlushingPassiveEffects = false;
                    didScheduleUpdateDuringPassiveEffects = false;
                }
                onPostCommitRoot(root);
                {
                    var stateNode = root.current.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                }
                return true;
            }
            function isAlreadyFailedLegacyErrorBoundary(instance) {
                return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
            }
            function markLegacyErrorBoundaryAsFailed(instance) {
                if (legacyErrorBoundariesThatAlreadyFailed === null) {
                    legacyErrorBoundariesThatAlreadyFailed = new Set([
                        instance
                    ]);
                } else {
                    legacyErrorBoundariesThatAlreadyFailed.add(instance);
                }
            }
            function prepareToThrowUncaughtError(error) {
                if (!hasUncaughtError) {
                    hasUncaughtError = true;
                    firstUncaughtError = error;
                }
            }
            var onUncaughtError = prepareToThrowUncaughtError;
            function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
                var errorInfo = createCapturedValueAtFiber(error, sourceFiber);
                var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
                var root = enqueueUpdate(rootFiber, update, SyncLane);
                var eventTime = requestEventTime();
                if (root !== null) {
                    markRootUpdated(root, SyncLane, eventTime);
                    ensureRootIsScheduled(root, eventTime);
                }
            }
            function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
                {
                    reportUncaughtErrorInDEV(error$1);
                    setIsRunningInsertionEffect(false);
                }
                if (sourceFiber.tag === HostRoot) {
                    // Error was thrown at the root. There is no parent, so the root
                    // itself should capture it.
                    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
                    return;
                }
                var fiber = null;
                {
                    fiber = nearestMountedAncestor;
                }
                while(fiber !== null){
                    if (fiber.tag === HostRoot) {
                        captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                        return;
                    } else if (fiber.tag === ClassComponent) {
                        var ctor = fiber.type;
                        var instance = fiber.stateNode;
                        if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                            var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                            var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                            var root = enqueueUpdate(fiber, update, SyncLane);
                            var eventTime = requestEventTime();
                            if (root !== null) {
                                markRootUpdated(root, SyncLane, eventTime);
                                ensureRootIsScheduled(root, eventTime);
                            }
                            return;
                        }
                    }
                    fiber = fiber.return;
                }
                {
                    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning
                    // will fire for errors that are thrown by destroy functions inside deleted
                    // trees. What it should instead do is propagate the error to the parent of
                    // the deleted tree. In the meantime, do not add this warning to the
                    // allowlist; this is only for our internal use.
                    error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\n\n' + 'Error message:\n\n%s', error$1);
                }
            }
            function pingSuspendedRoot(root, wakeable, pingedLanes) {
                var pingCache = root.pingCache;
                if (pingCache !== null) {
                    // The wakeable resolved, so we no longer need to memoize, because it will
                    // never be thrown again.
                    pingCache.delete(wakeable);
                }
                var eventTime = requestEventTime();
                markRootPinged(root, pingedLanes);
                warnIfSuspenseResolutionNotWrappedWithActDEV(root);
                if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
                    // Received a ping at the same priority level at which we're currently
                    // rendering. We might want to restart this render. This should mirror
                    // the logic of whether or not a root suspends once it completes.
                    // TODO: If we're rendering sync either due to Sync, Batched or expired,
                    // we should probably never restart.
                    // If we're suspended with delay, or if it's a retry, we'll always suspend
                    // so we can always restart.
                    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                        // Restart from the root.
                        prepareFreshStack(root, NoLanes);
                    } else {
                        // Even though we can't restart right now, we might get an
                        // opportunity later. So we mark this render as having a ping.
                        workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
                    }
                }
                ensureRootIsScheduled(root, eventTime);
            }
            function retryTimedOutBoundary(boundaryFiber, retryLane) {
                // The boundary fiber (a Suspense component or SuspenseList component)
                // previously was rendered in its fallback state. One of the promises that
                // suspended it has resolved, which means at least part of the tree was
                // likely unblocked. Try rendering again, at a new lanes.
                if (retryLane === NoLane) {
                    // TODO: Assign this to `suspenseState.retryLane`? to avoid
                    // unnecessary entanglement?
                    retryLane = requestRetryLane(boundaryFiber);
                } // TODO: Special case idle priority?
                var eventTime = requestEventTime();
                var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
                if (root !== null) {
                    markRootUpdated(root, retryLane, eventTime);
                    ensureRootIsScheduled(root, eventTime);
                }
            }
            function retryDehydratedSuspenseBoundary(boundaryFiber) {
                var suspenseState = boundaryFiber.memoizedState;
                var retryLane = NoLane;
                if (suspenseState !== null) {
                    retryLane = suspenseState.retryLane;
                }
                retryTimedOutBoundary(boundaryFiber, retryLane);
            }
            function resolveRetryWakeable(boundaryFiber, wakeable) {
                var retryLane = NoLane; // Default
                var retryCache;
                switch(boundaryFiber.tag){
                    case SuspenseComponent:
                        retryCache = boundaryFiber.stateNode;
                        var suspenseState = boundaryFiber.memoizedState;
                        if (suspenseState !== null) {
                            retryLane = suspenseState.retryLane;
                        }
                        break;
                    case SuspenseListComponent:
                        retryCache = boundaryFiber.stateNode;
                        break;
                    default:
                        throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');
                }
                if (retryCache !== null) {
                    // The wakeable resolved, so we no longer need to memoize, because it will
                    // never be thrown again.
                    retryCache.delete(wakeable);
                }
                retryTimedOutBoundary(boundaryFiber, retryLane);
            } // Computes the next Just Noticeable Difference (JND) boundary.
            // The theory is that a person can't tell the difference between small differences in time.
            // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
            // difference in the experience. However, waiting for longer might mean that we can avoid
            // showing an intermediate loading state. The longer we have already waited, the harder it
            // is to tell small differences in time. Therefore, the longer we've already waited,
            // the longer we can wait additionally. At some point we have to give up though.
            // We pick a train model where the next boundary commits at a consistent schedule.
            // These particular numbers are vague estimates. We expect to adjust them based on research.
            function jnd(timeElapsed) {
                return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
            }
            function checkForNestedUpdates() {
                if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
                    nestedUpdateCount = 0;
                    rootWithNestedUpdates = null;
                    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');
                }
                {
                    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                        nestedPassiveUpdateCount = 0;
                        rootWithPassiveNestedUpdates = null;
                        error('Maximum update depth exceeded. This can happen when a component ' + "calls setState inside useEffect, but useEffect either doesn't " + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');
                    }
                }
            }
            function flushRenderPhaseStrictModeWarningsInDEV() {
                {
                    ReactStrictModeWarnings.flushLegacyContextWarning();
                    {
                        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
                    }
                }
            }
            function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
                {
                    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects
                    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.
                    // Maybe not a big deal since this is DEV only behavior.
                    setCurrentFiber(fiber);
                    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
                    if (hasPassiveEffects) {
                        invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
                    }
                    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
                    if (hasPassiveEffects) {
                        invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
                    }
                    resetCurrentFiber();
                }
            }
            function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
                {
                    // We don't need to re-check StrictEffectsMode here.
                    // This function is only called if that check has already passed.
                    var current = firstChild;
                    var subtreeRoot = null;
                    while(current !== null){
                        var primarySubtreeFlag = current.subtreeFlags & fiberFlags;
                        if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {
                            current = current.child;
                        } else {
                            if ((current.flags & fiberFlags) !== NoFlags) {
                                invokeEffectFn(current);
                            }
                            if (current.sibling !== null) {
                                current = current.sibling;
                            } else {
                                current = subtreeRoot = current.return;
                            }
                        }
                    }
                }
            }
            var didWarnStateUpdateForNotYetMountedComponent = null;
            function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
                {
                    if ((executionContext & RenderContext) !== NoContext) {
                        // We let the other warning about render phase updates deal with this one.
                        return;
                    }
                    if (!(fiber.mode & ConcurrentMode)) {
                        return;
                    }
                    var tag = fiber.tag;
                    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                        // Only warn for user-defined components, not internal ones like Suspense.
                        return;
                    } // We show the whole stack but dedupe on the top component's name because
                    // the problematic code almost always lies inside that component.
                    var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';
                    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                        if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                            return;
                        }
                        didWarnStateUpdateForNotYetMountedComponent.add(componentName);
                    } else {
                        didWarnStateUpdateForNotYetMountedComponent = new Set([
                            componentName
                        ]);
                    }
                    var previousFiber = current;
                    try {
                        setCurrentFiber(fiber);
                        error("Can't perform a React state update on a component that hasn't mounted yet. " + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');
                    } finally{
                        if (previousFiber) {
                            setCurrentFiber(fiber);
                        } else {
                            resetCurrentFiber();
                        }
                    }
                }
            }
            var beginWork$1;
            {
                var dummyFiber = null;
                beginWork$1 = function beginWork$1(current, unitOfWork, lanes) {
                    // If a component throws an error, we replay it again in a synchronously
                    // dispatched event, so that the debugger will treat it as an uncaught
                    // error See ReactErrorUtils for more information.
                    // Before entering the begin phase, copy the work-in-progress onto a dummy
                    // fiber. If beginWork throws, we'll use this to reset the state.
                    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
                    try {
                        return beginWork(current, unitOfWork, lanes);
                    } catch (originalError) {
                        if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && (typeof originalError === "undefined" ? "undefined" : _type_of(originalError)) === 'object' && typeof originalError.then === 'function') {
                            // Don't replay promises.
                            // Don't replay errors if we are hydrating and have already suspended or handled an error
                            throw originalError;
                        } // Keep this code in sync with handleError; any changes here must have
                        // corresponding changes there.
                        resetContextDependencies();
                        resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
                        // same fiber again.
                        // Unwind the failed stack frame
                        unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.
                        assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                        if (unitOfWork.mode & ProfileMode) {
                            // Reset the profiler timer.
                            startProfilerTimer(unitOfWork);
                        } // Run beginWork again.
                        invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);
                        if (hasCaughtError()) {
                            var replayError = clearCaughtError();
                            if ((typeof replayError === "undefined" ? "undefined" : _type_of(replayError)) === 'object' && replayError !== null && replayError._suppressLogging && (typeof originalError === "undefined" ? "undefined" : _type_of(originalError)) === 'object' && originalError !== null && !originalError._suppressLogging) {
                                // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.
                                originalError._suppressLogging = true;
                            }
                        } // We always throw the original error in case the second render pass is not idempotent.
                        // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.
                        throw originalError;
                    }
                };
            }
            var didWarnAboutUpdateInRender = false;
            var didWarnAboutUpdateInRenderForAnotherComponent;
            {
                didWarnAboutUpdateInRenderForAnotherComponent = new Set();
            }
            function warnAboutRenderPhaseUpdatesInDEV(fiber) {
                {
                    if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                        switch(fiber.tag){
                            case FunctionComponent:
                            case ForwardRef:
                            case SimpleMemoComponent:
                                {
                                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.
                                    var dedupeKey = renderingComponentName;
                                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                                        didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                                        var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';
                                        error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);
                                    }
                                    break;
                                }
                            case ClassComponent:
                                {
                                    if (!didWarnAboutUpdateInRender) {
                                        error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');
                                        didWarnAboutUpdateInRender = true;
                                    }
                                    break;
                                }
                        }
                    }
                }
            }
            function restorePendingUpdaters(root, lanes) {
                {
                    if (isDevToolsPresent) {
                        var memoizedUpdaters = root.memoizedUpdaters;
                        memoizedUpdaters.forEach(function(schedulingFiber) {
                            addFiberToLanesMap(root, schedulingFiber, lanes);
                        }); // This function intentionally does not clear memoized updaters.
                    // Those may still be relevant to the current commit
                    // and a future one (e.g. Suspense).
                    }
                }
            }
            var fakeActCallbackNode = {};
            function scheduleCallback$1(priorityLevel, callback) {
                {
                    // If we're currently inside an `act` scope, bypass Scheduler and push to
                    // the `act` queue instead.
                    var actQueue = ReactCurrentActQueue$1.current;
                    if (actQueue !== null) {
                        actQueue.push(callback);
                        return fakeActCallbackNode;
                    } else {
                        return scheduleCallback(priorityLevel, callback);
                    }
                }
            }
            function cancelCallback$1(callbackNode) {
                if (callbackNode === fakeActCallbackNode) {
                    return;
                } // In production, always call Scheduler. This function will be stripped out.
                return cancelCallback(callbackNode);
            }
            function shouldForceFlushFallbacksInDEV() {
                // Never force flush in production. This function should get stripped out.
                return ReactCurrentActQueue$1.current !== null;
            }
            function warnIfUpdatesNotWrappedWithActDEV(fiber) {
                {
                    if (fiber.mode & ConcurrentMode) {
                        if (!isConcurrentActEnvironment()) {
                            // Not in an act environment. No need to warn.
                            return;
                        }
                    } else {
                        // Legacy mode has additional cases where we suppress a warning.
                        if (!isLegacyActEnvironment()) {
                            // Not in an act environment. No need to warn.
                            return;
                        }
                        if (executionContext !== NoContext) {
                            // Legacy mode doesn't warn if the update is batched, i.e.
                            // batchedUpdates or flushSync.
                            return;
                        }
                        if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                            // For backwards compatibility with pre-hooks code, legacy mode only
                            // warns for updates that originate from a hook.
                            return;
                        }
                    }
                    if (ReactCurrentActQueue$1.current === null) {
                        var previousFiber = current;
                        try {
                            setCurrentFiber(fiber);
                            error('An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));
                        } finally{
                            if (previousFiber) {
                                setCurrentFiber(fiber);
                            } else {
                                resetCurrentFiber();
                            }
                        }
                    }
                }
            }
            function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {
                {
                    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                        error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\n\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\n\n' + 'act(() => {\n' + '  /* finish loading suspended data */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');
                    }
                }
            }
            function setIsRunningInsertionEffect(isRunning) {
                {
                    isRunningInsertionEffect = isRunning;
                }
            }
            /* eslint-disable react-internal/prod-error-codes */ var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
            var failedBoundaries = null;
            var setRefreshHandler = function setRefreshHandler(handler) {
                {
                    resolveFamily = handler;
                }
            };
            function resolveFunctionForHotReloading(type) {
                {
                    if (resolveFamily === null) {
                        // Hot reloading is disabled.
                        return type;
                    }
                    var family = resolveFamily(type);
                    if (family === undefined) {
                        return type;
                    } // Use the latest known implementation.
                    return family.current;
                }
            }
            function resolveClassForHotReloading(type) {
                // No implementation differences.
                return resolveFunctionForHotReloading(type);
            }
            function resolveForwardRefForHotReloading(type) {
                {
                    if (resolveFamily === null) {
                        // Hot reloading is disabled.
                        return type;
                    }
                    var family = resolveFamily(type);
                    if (family === undefined) {
                        // Check if we're dealing with a real forwardRef. Don't want to crash early.
                        if (type !== null && type !== undefined && typeof type.render === 'function') {
                            // ForwardRef is special because its resolved .type is an object,
                            // but it's possible that we only have its inner render function in the map.
                            // If that inner render function is different, we'll build a new forwardRef type.
                            var currentRender = resolveFunctionForHotReloading(type.render);
                            if (type.render !== currentRender) {
                                var syntheticType = {
                                    $$typeof: REACT_FORWARD_REF_TYPE,
                                    render: currentRender
                                };
                                if (type.displayName !== undefined) {
                                    syntheticType.displayName = type.displayName;
                                }
                                return syntheticType;
                            }
                        }
                        return type;
                    } // Use the latest known implementation.
                    return family.current;
                }
            }
            function isCompatibleFamilyForHotReloading(fiber, element) {
                {
                    if (resolveFamily === null) {
                        // Hot reloading is disabled.
                        return false;
                    }
                    var prevType = fiber.elementType;
                    var nextType = element.type; // If we got here, we know types aren't === equal.
                    var needsCompareFamilies = false;
                    var $$typeofNextType = (typeof nextType === "undefined" ? "undefined" : _type_of(nextType)) === 'object' && nextType !== null ? nextType.$$typeof : null;
                    switch(fiber.tag){
                        case ClassComponent:
                            {
                                if (typeof nextType === 'function') {
                                    needsCompareFamilies = true;
                                }
                                break;
                            }
                        case FunctionComponent:
                            {
                                if (typeof nextType === 'function') {
                                    needsCompareFamilies = true;
                                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                    // We don't know the inner type yet.
                                    // We're going to assume that the lazy inner type is stable,
                                    // and so it is sufficient to avoid reconciling it away.
                                    // We're not going to unwrap or actually use the new lazy type.
                                    needsCompareFamilies = true;
                                }
                                break;
                            }
                        case ForwardRef:
                            {
                                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                                    needsCompareFamilies = true;
                                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                    needsCompareFamilies = true;
                                }
                                break;
                            }
                        case MemoComponent:
                        case SimpleMemoComponent:
                            {
                                if ($$typeofNextType === REACT_MEMO_TYPE) {
                                    // TODO: if it was but can no longer be simple,
                                    // we shouldn't set this.
                                    needsCompareFamilies = true;
                                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                                    needsCompareFamilies = true;
                                }
                                break;
                            }
                        default:
                            return false;
                    } // Check if both types have a family and it's the same one.
                    if (needsCompareFamilies) {
                        // Note: memo() and forwardRef() we'll compare outer rather than inner type.
                        // This means both of them need to be registered to preserve state.
                        // If we unwrapped and compared the inner types for wrappers instead,
                        // then we would risk falsely saying two separate memo(Foo)
                        // calls are equivalent because they wrap the same Foo function.
                        var prevFamily = resolveFamily(prevType);
                        if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            function markFailedErrorBoundaryForHotReloading(fiber) {
                {
                    if (resolveFamily === null) {
                        // Hot reloading is disabled.
                        return;
                    }
                    if (typeof WeakSet !== 'function') {
                        return;
                    }
                    if (failedBoundaries === null) {
                        failedBoundaries = new WeakSet();
                    }
                    failedBoundaries.add(fiber);
                }
            }
            var scheduleRefresh = function scheduleRefresh(root, update) {
                {
                    if (resolveFamily === null) {
                        // Hot reloading is disabled.
                        return;
                    }
                    var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
                    flushPassiveEffects();
                    flushSync(function() {
                        scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
                    });
                }
            };
            var scheduleRoot = function scheduleRoot(root, element) {
                {
                    if (root.context !== emptyContextObject) {
                        // Super edge case: root has a legacy _renderSubtree context
                        // but we don't know the parentComponent so we can't pass it.
                        // Just ignore. We'll delete this with _renderSubtree code path later.
                        return;
                    }
                    flushPassiveEffects();
                    flushSync(function() {
                        updateContainer(element, root, null, null);
                    });
                }
            };
            function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
                {
                    var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
                    var candidateType = null;
                    switch(tag){
                        case FunctionComponent:
                        case SimpleMemoComponent:
                        case ClassComponent:
                            candidateType = type;
                            break;
                        case ForwardRef:
                            candidateType = type.render;
                            break;
                    }
                    if (resolveFamily === null) {
                        throw new Error('Expected resolveFamily to be set during hot reload.');
                    }
                    var needsRender = false;
                    var needsRemount = false;
                    if (candidateType !== null) {
                        var family = resolveFamily(candidateType);
                        if (family !== undefined) {
                            if (staleFamilies.has(family)) {
                                needsRemount = true;
                            } else if (updatedFamilies.has(family)) {
                                if (tag === ClassComponent) {
                                    needsRemount = true;
                                } else {
                                    needsRender = true;
                                }
                            }
                        }
                    }
                    if (failedBoundaries !== null) {
                        if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                            needsRemount = true;
                        }
                    }
                    if (needsRemount) {
                        fiber._debugNeedsRemount = true;
                    }
                    if (needsRemount || needsRender) {
                        var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                        if (_root !== null) {
                            scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                        }
                    }
                    if (child !== null && !needsRemount) {
                        scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
                    }
                    if (sibling !== null) {
                        scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
                    }
                }
            }
            var findHostInstancesForRefresh = function findHostInstancesForRefresh(root, families) {
                {
                    var hostInstances = new Set();
                    var types = new Set(families.map(function(family) {
                        return family.current;
                    }));
                    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
                    return hostInstances;
                }
            };
            function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
                {
                    var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
                    var candidateType = null;
                    switch(tag){
                        case FunctionComponent:
                        case SimpleMemoComponent:
                        case ClassComponent:
                            candidateType = type;
                            break;
                        case ForwardRef:
                            candidateType = type.render;
                            break;
                    }
                    var didMatch = false;
                    if (candidateType !== null) {
                        if (types.has(candidateType)) {
                            didMatch = true;
                        }
                    }
                    if (didMatch) {
                        // We have a match. This only drills down to the closest host components.
                        // There's no need to search deeper because for the purpose of giving
                        // visual feedback, "flashing" outermost parent rectangles is sufficient.
                        findHostInstancesForFiberShallowly(fiber, hostInstances);
                    } else {
                        // If there's no match, maybe there will be one further down in the child tree.
                        if (child !== null) {
                            findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                        }
                    }
                    if (sibling !== null) {
                        findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
                    }
                }
            }
            function findHostInstancesForFiberShallowly(fiber, hostInstances) {
                {
                    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
                    if (foundHostInstances) {
                        return;
                    } // If we didn't find any host children, fallback to closest host parent.
                    var node = fiber;
                    while(true){
                        switch(node.tag){
                            case HostComponent:
                                hostInstances.add(node.stateNode);
                                return;
                            case HostPortal:
                                hostInstances.add(node.stateNode.containerInfo);
                                return;
                            case HostRoot:
                                hostInstances.add(node.stateNode.containerInfo);
                                return;
                        }
                        if (node.return === null) {
                            throw new Error('Expected to reach root first.');
                        }
                        node = node.return;
                    }
                }
            }
            function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
                {
                    var node = fiber;
                    var foundHostInstances = false;
                    while(true){
                        if (node.tag === HostComponent) {
                            // We got a match.
                            foundHostInstances = true;
                            hostInstances.add(node.stateNode); // There may still be more, so keep searching.
                        } else if (node.child !== null) {
                            node.child.return = node;
                            node = node.child;
                            continue;
                        }
                        if (node === fiber) {
                            return foundHostInstances;
                        }
                        while(node.sibling === null){
                            if (node.return === null || node.return === fiber) {
                                return foundHostInstances;
                            }
                            node = node.return;
                        }
                        node.sibling.return = node.return;
                        node = node.sibling;
                    }
                }
                return false;
            }
            var hasBadMapPolyfill;
            {
                hasBadMapPolyfill = false;
                try {
                    var nonExtensibleObject = Object.preventExtensions({});
                    /* eslint-disable no-new */ new Map([
                        [
                            nonExtensibleObject,
                            null
                        ]
                    ]);
                    new Set([
                        nonExtensibleObject
                    ]);
                /* eslint-enable no-new */ } catch (e) {
                    // TODO: Consider warning about bad polyfills
                    hasBadMapPolyfill = true;
                }
            }
            function FiberNode(tag, pendingProps, key, mode) {
                // Instance
                this.tag = tag;
                this.key = key;
                this.elementType = null;
                this.type = null;
                this.stateNode = null; // Fiber
                this.return = null;
                this.child = null;
                this.sibling = null;
                this.index = 0;
                this.ref = null;
                this.pendingProps = pendingProps;
                this.memoizedProps = null;
                this.updateQueue = null;
                this.memoizedState = null;
                this.dependencies = null;
                this.mode = mode; // Effects
                this.flags = NoFlags;
                this.subtreeFlags = NoFlags;
                this.deletions = null;
                this.lanes = NoLanes;
                this.childLanes = NoLanes;
                this.alternate = null;
                {
                    // Note: The following is done to avoid a v8 performance cliff.
                    //
                    // Initializing the fields below to smis and later updating them with
                    // double values will cause Fibers to end up having separate shapes.
                    // This behavior/bug has something to do with Object.preventExtension().
                    // Fortunately this only impacts DEV builds.
                    // Unfortunately it makes React unusably slow for some applications.
                    // To work around this, initialize the fields below with doubles.
                    //
                    // Learn more about this here:
                    // https://github.com/facebook/react/issues/14365
                    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
                    this.actualDuration = Number.NaN;
                    this.actualStartTime = Number.NaN;
                    this.selfBaseDuration = Number.NaN;
                    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
                    // This won't trigger the performance cliff mentioned above,
                    // and it simplifies other profiler code (including DevTools).
                    this.actualDuration = 0;
                    this.actualStartTime = -1;
                    this.selfBaseDuration = 0;
                    this.treeBaseDuration = 0;
                }
                {
                    // This isn't directly used but is handy for debugging internals:
                    this._debugSource = null;
                    this._debugOwner = null;
                    this._debugNeedsRemount = false;
                    this._debugHookTypes = null;
                    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
                        Object.preventExtensions(this);
                    }
                }
            } // This is a constructor function, rather than a POJO constructor, still
            // please ensure we do the following:
            // 1) Nobody should add any instance methods on this. Instance methods can be
            //    more difficult to predict when they get optimized and they are almost
            //    never inlined properly in static compilers.
            // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
            //    always know when it is a fiber.
            // 3) We might want to experiment with using numeric keys since they are easier
            //    to optimize in a non-JIT environment.
            // 4) We can easily go from a constructor to a createFiber object literal if that
            //    is faster.
            // 5) It should be easy to port this to a C struct and keep a C implementation
            //    compatible.
            var createFiber = function createFiber(tag, pendingProps, key, mode) {
                // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
                return new FiberNode(tag, pendingProps, key, mode);
            };
            function shouldConstruct$1(Component) {
                var prototype = Component.prototype;
                return !!(prototype && prototype.isReactComponent);
            }
            function isSimpleFunctionComponent(type) {
                return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
            }
            function resolveLazyComponentTag(Component) {
                if (typeof Component === 'function') {
                    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
                } else if (Component !== undefined && Component !== null) {
                    var $$typeof = Component.$$typeof;
                    if ($$typeof === REACT_FORWARD_REF_TYPE) {
                        return ForwardRef;
                    }
                    if ($$typeof === REACT_MEMO_TYPE) {
                        return MemoComponent;
                    }
                }
                return IndeterminateComponent;
            } // This is used to create an alternate fiber to do work on.
            function createWorkInProgress(current, pendingProps) {
                var workInProgress = current.alternate;
                if (workInProgress === null) {
                    // We use a double buffering pooling technique because we know that we'll
                    // only ever need at most two versions of a tree. We pool the "other" unused
                    // node that we're free to reuse. This is lazily created to avoid allocating
                    // extra objects for things that are never updated. It also allow us to
                    // reclaim the extra memory if needed.
                    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
                    workInProgress.elementType = current.elementType;
                    workInProgress.type = current.type;
                    workInProgress.stateNode = current.stateNode;
                    {
                        // DEV-only fields
                        workInProgress._debugSource = current._debugSource;
                        workInProgress._debugOwner = current._debugOwner;
                        workInProgress._debugHookTypes = current._debugHookTypes;
                    }
                    workInProgress.alternate = current;
                    current.alternate = workInProgress;
                } else {
                    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.
                    workInProgress.type = current.type; // We already have an alternate.
                    // Reset the effect tag.
                    workInProgress.flags = NoFlags; // The effects are no longer valid.
                    workInProgress.subtreeFlags = NoFlags;
                    workInProgress.deletions = null;
                    {
                        // We intentionally reset, rather than copy, actualDuration & actualStartTime.
                        // This prevents time from endlessly accumulating in new commits.
                        // This has the downside of resetting values for different priority renders,
                        // But works for yielding (the common case) and should support resuming.
                        workInProgress.actualDuration = 0;
                        workInProgress.actualStartTime = -1;
                    }
                } // Reset all effects except static ones.
                // Static effects are not specific to a render.
                workInProgress.flags = current.flags & StaticMask;
                workInProgress.childLanes = current.childLanes;
                workInProgress.lanes = current.lanes;
                workInProgress.child = current.child;
                workInProgress.memoizedProps = current.memoizedProps;
                workInProgress.memoizedState = current.memoizedState;
                workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
                // it cannot be shared with the current fiber.
                var currentDependencies = current.dependencies;
                workInProgress.dependencies = currentDependencies === null ? null : {
                    lanes: currentDependencies.lanes,
                    firstContext: currentDependencies.firstContext
                }; // These will be overridden during the parent's reconciliation
                workInProgress.sibling = current.sibling;
                workInProgress.index = current.index;
                workInProgress.ref = current.ref;
                {
                    workInProgress.selfBaseDuration = current.selfBaseDuration;
                    workInProgress.treeBaseDuration = current.treeBaseDuration;
                }
                {
                    workInProgress._debugNeedsRemount = current._debugNeedsRemount;
                    switch(workInProgress.tag){
                        case IndeterminateComponent:
                        case FunctionComponent:
                        case SimpleMemoComponent:
                            workInProgress.type = resolveFunctionForHotReloading(current.type);
                            break;
                        case ClassComponent:
                            workInProgress.type = resolveClassForHotReloading(current.type);
                            break;
                        case ForwardRef:
                            workInProgress.type = resolveForwardRefForHotReloading(current.type);
                            break;
                    }
                }
                return workInProgress;
            } // Used to reuse a Fiber for a second pass.
            function resetWorkInProgress(workInProgress, renderLanes) {
                // This resets the Fiber to what createFiber or createWorkInProgress would
                // have set the values to before during the first pass. Ideally this wouldn't
                // be necessary but unfortunately many code paths reads from the workInProgress
                // when they should be reading from current and writing to workInProgress.
                // We assume pendingProps, index, key, ref, return are still untouched to
                // avoid doing another reconciliation.
                // Reset the effect flags but keep any Placement tags, since that's something
                // that child fiber is setting, not the reconciliation.
                workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.
                var current = workInProgress.alternate;
                if (current === null) {
                    // Reset to createFiber's initial values.
                    workInProgress.childLanes = NoLanes;
                    workInProgress.lanes = renderLanes;
                    workInProgress.child = null;
                    workInProgress.subtreeFlags = NoFlags;
                    workInProgress.memoizedProps = null;
                    workInProgress.memoizedState = null;
                    workInProgress.updateQueue = null;
                    workInProgress.dependencies = null;
                    workInProgress.stateNode = null;
                    {
                        // Note: We don't reset the actualTime counts. It's useful to accumulate
                        // actual time across multiple render passes.
                        workInProgress.selfBaseDuration = 0;
                        workInProgress.treeBaseDuration = 0;
                    }
                } else {
                    // Reset to the cloned values that createWorkInProgress would've.
                    workInProgress.childLanes = current.childLanes;
                    workInProgress.lanes = current.lanes;
                    workInProgress.child = current.child;
                    workInProgress.subtreeFlags = NoFlags;
                    workInProgress.deletions = null;
                    workInProgress.memoizedProps = current.memoizedProps;
                    workInProgress.memoizedState = current.memoizedState;
                    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.
                    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
                    // it cannot be shared with the current fiber.
                    var currentDependencies = current.dependencies;
                    workInProgress.dependencies = currentDependencies === null ? null : {
                        lanes: currentDependencies.lanes,
                        firstContext: currentDependencies.firstContext
                    };
                    {
                        // Note: We don't reset the actualTime counts. It's useful to accumulate
                        // actual time across multiple render passes.
                        workInProgress.selfBaseDuration = current.selfBaseDuration;
                        workInProgress.treeBaseDuration = current.treeBaseDuration;
                    }
                }
                return workInProgress;
            }
            function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
                var mode;
                if (tag === ConcurrentRoot) {
                    mode = ConcurrentMode;
                    if (isStrictMode === true) {
                        mode |= StrictLegacyMode;
                        {
                            mode |= StrictEffectsMode;
                        }
                    }
                } else {
                    mode = NoMode;
                }
                if (isDevToolsPresent) {
                    // Always collect profile timings when DevTools are present.
                    // This enables DevTools to start capturing timing at any point–
                    // Without some nodes in the tree having empty base times.
                    mode |= ProfileMode;
                }
                return createFiber(HostRoot, null, null, mode);
            }
            function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
                var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
                var resolvedType = type;
                if (typeof type === 'function') {
                    if (shouldConstruct$1(type)) {
                        fiberTag = ClassComponent;
                        {
                            resolvedType = resolveClassForHotReloading(resolvedType);
                        }
                    } else {
                        {
                            resolvedType = resolveFunctionForHotReloading(resolvedType);
                        }
                    }
                } else if (typeof type === 'string') {
                    fiberTag = HostComponent;
                } else {
                    getTag: switch(type){
                        case REACT_FRAGMENT_TYPE:
                            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                        case REACT_STRICT_MODE_TYPE:
                            fiberTag = Mode;
                            mode |= StrictLegacyMode;
                            if ((mode & ConcurrentMode) !== NoMode) {
                                // Strict effects should never run on legacy roots
                                mode |= StrictEffectsMode;
                            }
                            break;
                        case REACT_PROFILER_TYPE:
                            return createFiberFromProfiler(pendingProps, mode, lanes, key);
                        case REACT_SUSPENSE_TYPE:
                            return createFiberFromSuspense(pendingProps, mode, lanes, key);
                        case REACT_SUSPENSE_LIST_TYPE:
                            return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                        case REACT_OFFSCREEN_TYPE:
                            return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                        case REACT_LEGACY_HIDDEN_TYPE:
                        // eslint-disable-next-line no-fallthrough
                        case REACT_SCOPE_TYPE:
                        // eslint-disable-next-line no-fallthrough
                        case REACT_CACHE_TYPE:
                        // eslint-disable-next-line no-fallthrough
                        case REACT_TRACING_MARKER_TYPE:
                        // eslint-disable-next-line no-fallthrough
                        case REACT_DEBUG_TRACING_MODE_TYPE:
                        // eslint-disable-next-line no-fallthrough
                        default:
                            {
                                if ((typeof type === "undefined" ? "undefined" : _type_of(type)) === 'object' && type !== null) {
                                    switch(type.$$typeof){
                                        case REACT_PROVIDER_TYPE:
                                            fiberTag = ContextProvider;
                                            break getTag;
                                        case REACT_CONTEXT_TYPE:
                                            // This is a consumer
                                            fiberTag = ContextConsumer;
                                            break getTag;
                                        case REACT_FORWARD_REF_TYPE:
                                            fiberTag = ForwardRef;
                                            {
                                                resolvedType = resolveForwardRefForHotReloading(resolvedType);
                                            }
                                            break getTag;
                                        case REACT_MEMO_TYPE:
                                            fiberTag = MemoComponent;
                                            break getTag;
                                        case REACT_LAZY_TYPE:
                                            fiberTag = LazyComponent;
                                            resolvedType = null;
                                            break getTag;
                                    }
                                }
                                var info = '';
                                {
                                    if (type === undefined || (typeof type === "undefined" ? "undefined" : _type_of(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
                                        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
                                    }
                                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                                    if (ownerName) {
                                        info += '\n\nCheck the render method of `' + ownerName + '`.';
                                    }
                                }
                                throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + ("but got: " + (type == null ? type : typeof type === "undefined" ? "undefined" : _type_of(type)) + "." + info));
                            }
                    }
                }
                var fiber = createFiber(fiberTag, pendingProps, key, mode);
                fiber.elementType = type;
                fiber.type = resolvedType;
                fiber.lanes = lanes;
                {
                    fiber._debugOwner = owner;
                }
                return fiber;
            }
            function createFiberFromElement(element, mode, lanes) {
                var owner = null;
                {
                    owner = element._owner;
                }
                var type = element.type;
                var key = element.key;
                var pendingProps = element.props;
                var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
                {
                    fiber._debugSource = element._source;
                    fiber._debugOwner = element._owner;
                }
                return fiber;
            }
            function createFiberFromFragment(elements, mode, lanes, key) {
                var fiber = createFiber(Fragment, elements, key, mode);
                fiber.lanes = lanes;
                return fiber;
            }
            function createFiberFromProfiler(pendingProps, mode, lanes, key) {
                {
                    if (typeof pendingProps.id !== 'string') {
                        error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', _type_of(pendingProps.id));
                    }
                }
                var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
                fiber.elementType = REACT_PROFILER_TYPE;
                fiber.lanes = lanes;
                {
                    fiber.stateNode = {
                        effectDuration: 0,
                        passiveEffectDuration: 0
                    };
                }
                return fiber;
            }
            function createFiberFromSuspense(pendingProps, mode, lanes, key) {
                var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
                fiber.elementType = REACT_SUSPENSE_TYPE;
                fiber.lanes = lanes;
                return fiber;
            }
            function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
                var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
                fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
                fiber.lanes = lanes;
                return fiber;
            }
            function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
                var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
                fiber.elementType = REACT_OFFSCREEN_TYPE;
                fiber.lanes = lanes;
                var primaryChildInstance = {
                    isHidden: false
                };
                fiber.stateNode = primaryChildInstance;
                return fiber;
            }
            function createFiberFromText(content, mode, lanes) {
                var fiber = createFiber(HostText, content, null, mode);
                fiber.lanes = lanes;
                return fiber;
            }
            function createFiberFromHostInstanceForDeletion() {
                var fiber = createFiber(HostComponent, null, null, NoMode);
                fiber.elementType = 'DELETED';
                return fiber;
            }
            function createFiberFromDehydratedFragment(dehydratedNode) {
                var fiber = createFiber(DehydratedFragment, null, null, NoMode);
                fiber.stateNode = dehydratedNode;
                return fiber;
            }
            function createFiberFromPortal(portal, mode, lanes) {
                var pendingProps = portal.children !== null ? portal.children : [];
                var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
                fiber.lanes = lanes;
                fiber.stateNode = {
                    containerInfo: portal.containerInfo,
                    pendingChildren: null,
                    // Used by persistent updates
                    implementation: portal.implementation
                };
                return fiber;
            } // Used for stashing WIP properties to replay failed work in DEV.
            function assignFiberPropertiesInDEV(target, source) {
                if (target === null) {
                    // This Fiber's initial properties will always be overwritten.
                    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
                    target = createFiber(IndeterminateComponent, null, null, NoMode);
                } // This is intentionally written as a list of all properties.
                // We tried to use Object.assign() instead but this is called in
                // the hottest path, and Object.assign() was too slow:
                // https://github.com/facebook/react/issues/12502
                // This code is DEV-only so size is not a concern.
                target.tag = source.tag;
                target.key = source.key;
                target.elementType = source.elementType;
                target.type = source.type;
                target.stateNode = source.stateNode;
                target.return = source.return;
                target.child = source.child;
                target.sibling = source.sibling;
                target.index = source.index;
                target.ref = source.ref;
                target.pendingProps = source.pendingProps;
                target.memoizedProps = source.memoizedProps;
                target.updateQueue = source.updateQueue;
                target.memoizedState = source.memoizedState;
                target.dependencies = source.dependencies;
                target.mode = source.mode;
                target.flags = source.flags;
                target.subtreeFlags = source.subtreeFlags;
                target.deletions = source.deletions;
                target.lanes = source.lanes;
                target.childLanes = source.childLanes;
                target.alternate = source.alternate;
                {
                    target.actualDuration = source.actualDuration;
                    target.actualStartTime = source.actualStartTime;
                    target.selfBaseDuration = source.selfBaseDuration;
                    target.treeBaseDuration = source.treeBaseDuration;
                }
                target._debugSource = source._debugSource;
                target._debugOwner = source._debugOwner;
                target._debugNeedsRemount = source._debugNeedsRemount;
                target._debugHookTypes = source._debugHookTypes;
                return target;
            }
            function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {
                this.tag = tag;
                this.containerInfo = containerInfo;
                this.pendingChildren = null;
                this.current = null;
                this.pingCache = null;
                this.finishedWork = null;
                this.timeoutHandle = noTimeout;
                this.context = null;
                this.pendingContext = null;
                this.callbackNode = null;
                this.callbackPriority = NoLane;
                this.eventTimes = createLaneMap(NoLanes);
                this.expirationTimes = createLaneMap(NoTimestamp);
                this.pendingLanes = NoLanes;
                this.suspendedLanes = NoLanes;
                this.pingedLanes = NoLanes;
                this.expiredLanes = NoLanes;
                this.mutableReadLanes = NoLanes;
                this.finishedLanes = NoLanes;
                this.entangledLanes = NoLanes;
                this.entanglements = createLaneMap(NoLanes);
                this.identifierPrefix = identifierPrefix;
                this.onRecoverableError = onRecoverableError;
                if (supportsHydration) {
                    this.mutableSourceEagerHydrationData = null;
                }
                {
                    this.effectDuration = 0;
                    this.passiveEffectDuration = 0;
                }
                {
                    this.memoizedUpdaters = new Set();
                    var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
                    for(var _i = 0; _i < TotalLanes; _i++){
                        pendingUpdatersLaneMap.push(new Set());
                    }
                }
                {
                    switch(tag){
                        case ConcurrentRoot:
                            this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';
                            break;
                        case LegacyRoot:
                            this._debugRootType = hydrate ? 'hydrate()' : 'render()';
                            break;
                    }
                }
            }
            function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread
            // them through the root constructor. Perhaps we should put them all into a
            // single type, like a DynamicHostConfig that is defined by the renderer.
            identifierPrefix, onRecoverableError, transitionCallbacks) {
                var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);
                // stateNode is any.
                var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
                root.current = uninitializedFiber;
                uninitializedFiber.stateNode = root;
                {
                    var _initialState = {
                        element: initialChildren,
                        isDehydrated: hydrate,
                        cache: null,
                        // not enabled yet
                        transitions: null,
                        pendingSuspenseBoundaries: null
                    };
                    uninitializedFiber.memoizedState = _initialState;
                }
                initializeUpdateQueue(uninitializedFiber);
                return root;
            }
            var ReactVersion = '18.3.1';
            function createPortal(children, containerInfo, implementation) {
                var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                {
                    checkKeyStringCoercion(key);
                }
                return {
                    // This tag allow us to uniquely identify this as a React Portal
                    $$typeof: REACT_PORTAL_TYPE,
                    key: key == null ? null : '' + key,
                    children: children,
                    containerInfo: containerInfo,
                    implementation: implementation
                };
            }
            var didWarnAboutNestedUpdates;
            var didWarnAboutFindNodeInStrictMode;
            {
                didWarnAboutNestedUpdates = false;
                didWarnAboutFindNodeInStrictMode = {};
            }
            function getContextForSubtree(parentComponent) {
                if (!parentComponent) {
                    return emptyContextObject;
                }
                var fiber = get(parentComponent);
                var parentContext = findCurrentUnmaskedContext(fiber);
                if (fiber.tag === ClassComponent) {
                    var Component = fiber.type;
                    if (isContextProvider(Component)) {
                        return processChildContext(fiber, Component, parentContext);
                    }
                }
                return parentContext;
            }
            function findHostInstance(component) {
                var fiber = get(component);
                if (fiber === undefined) {
                    if (typeof component.render === 'function') {
                        throw new Error('Unable to find node on an unmounted component.');
                    } else {
                        var keys = Object.keys(component).join(',');
                        throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                    }
                }
                var hostFiber = findCurrentHostFiber(fiber);
                if (hostFiber === null) {
                    return null;
                }
                return hostFiber.stateNode;
            }
            function findHostInstanceWithWarning(component, methodName) {
                {
                    var fiber = get(component);
                    if (fiber === undefined) {
                        if (typeof component.render === 'function') {
                            throw new Error('Unable to find node on an unmounted component.');
                        } else {
                            var keys = Object.keys(component).join(',');
                            throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                        }
                    }
                    var hostFiber = findCurrentHostFiber(fiber);
                    if (hostFiber === null) {
                        return null;
                    }
                    if (hostFiber.mode & StrictLegacyMode) {
                        var componentName = getComponentNameFromFiber(fiber) || 'Component';
                        if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                            didWarnAboutFindNodeInStrictMode[componentName] = true;
                            var previousFiber = current;
                            try {
                                setCurrentFiber(hostFiber);
                                if (fiber.mode & StrictLegacyMode) {
                                    error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
                                } else {
                                    error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
                                }
                            } finally{
                                // Ideally this should reset to previous but this shouldn't be called in
                                // render and there's another warning for that anyway.
                                if (previousFiber) {
                                    setCurrentFiber(previousFiber);
                                } else {
                                    resetCurrentFiber();
                                }
                            }
                        }
                    }
                    return hostFiber.stateNode;
                }
            }
            function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
                var hydrate = false;
                var initialChildren = null;
                return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            }
            function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
                var hydrate = true;
                var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor
                root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from
                // a regular update because the initial render must match was was rendered
                // on the server.
                // NOTE: This update intentionally doesn't have a payload. We're only using
                // the update to schedule work on the root fiber (and, for legacy roots, to
                // enqueue the callback if one is provided).
                var current = root.current;
                var eventTime = requestEventTime();
                var lane = requestUpdateLane(current);
                var update = createUpdate(eventTime, lane);
                update.callback = callback !== undefined && callback !== null ? callback : null;
                enqueueUpdate(current, update, lane);
                scheduleInitialHydrationOnRoot(root, lane, eventTime);
                return root;
            }
            function updateContainer(element, container, parentComponent, callback) {
                {
                    onScheduleRoot(container, element);
                }
                var current$1 = container.current;
                var eventTime = requestEventTime();
                var lane = requestUpdateLane(current$1);
                {
                    markRenderScheduled(lane);
                }
                var context = getContextForSubtree(parentComponent);
                if (container.context === null) {
                    container.context = context;
                } else {
                    container.pendingContext = context;
                }
                {
                    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                        didWarnAboutNestedUpdates = true;
                        error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');
                    }
                }
                var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
                // being called "element".
                update.payload = {
                    element: element
                };
                callback = callback === undefined ? null : callback;
                if (callback !== null) {
                    {
                        if (typeof callback !== 'function') {
                            error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
                        }
                    }
                    update.callback = callback;
                }
                var root = enqueueUpdate(current$1, update, lane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, current$1, lane, eventTime);
                    entangleTransitions(root, current$1, lane);
                }
                return lane;
            }
            function getPublicRootInstance(container) {
                var containerFiber = container.current;
                if (!containerFiber.child) {
                    return null;
                }
                switch(containerFiber.child.tag){
                    case HostComponent:
                        return getPublicInstance(containerFiber.child.stateNode);
                    default:
                        return containerFiber.child.stateNode;
                }
            }
            function attemptSynchronousHydration(fiber) {
                switch(fiber.tag){
                    case HostRoot:
                        {
                            var root = fiber.stateNode;
                            if (isRootDehydrated(root)) {
                                // Flush the first scheduled "update".
                                var lanes = getHighestPriorityPendingLanes(root);
                                flushRoot(root, lanes);
                            }
                            break;
                        }
                    case SuspenseComponent:
                        {
                            flushSync(function() {
                                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                                if (root !== null) {
                                    var eventTime = requestEventTime();
                                    scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);
                                }
                            }); // If we're still blocked after this, we need to increase
                            // the priority of any promises resolving within this
                            // boundary so that they next attempt also has higher pri.
                            var retryLane = SyncLane;
                            markRetryLaneIfNotHydrated(fiber, retryLane);
                            break;
                        }
                }
            }
            function markRetryLaneImpl(fiber, retryLane) {
                var suspenseState = fiber.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
                }
            } // Increases the priority of thenables when they resolve within this boundary.
            function markRetryLaneIfNotHydrated(fiber, retryLane) {
                markRetryLaneImpl(fiber, retryLane);
                var alternate = fiber.alternate;
                if (alternate) {
                    markRetryLaneImpl(alternate, retryLane);
                }
            }
            function attemptDiscreteHydration(fiber) {
                if (fiber.tag !== SuspenseComponent) {
                    // We ignore HostRoots here because we can't increase
                    // their priority and they should not suspend on I/O,
                    // since you have to wrap anything that might suspend in
                    // Suspense.
                    return;
                }
                var lane = SyncLane;
                var root = enqueueConcurrentRenderForLane(fiber, lane);
                if (root !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                }
                markRetryLaneIfNotHydrated(fiber, lane);
            }
            function attemptContinuousHydration(fiber) {
                if (fiber.tag !== SuspenseComponent) {
                    // We ignore HostRoots here because we can't increase
                    // their priority and they should not suspend on I/O,
                    // since you have to wrap anything that might suspend in
                    // Suspense.
                    return;
                }
                var lane = SelectiveHydrationLane;
                var root = enqueueConcurrentRenderForLane(fiber, lane);
                if (root !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                }
                markRetryLaneIfNotHydrated(fiber, lane);
            }
            function attemptHydrationAtCurrentPriority(fiber) {
                if (fiber.tag !== SuspenseComponent) {
                    // We ignore HostRoots here because we can't increase
                    // their priority other than synchronously flush it.
                    return;
                }
                var lane = requestUpdateLane(fiber);
                var root = enqueueConcurrentRenderForLane(fiber, lane);
                if (root !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root, fiber, lane, eventTime);
                }
                markRetryLaneIfNotHydrated(fiber, lane);
            }
            function findHostInstanceWithNoPortals(fiber) {
                var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
                if (hostFiber === null) {
                    return null;
                }
                return hostFiber.stateNode;
            }
            var shouldErrorImpl = function shouldErrorImpl(fiber) {
                return null;
            };
            function shouldError(fiber) {
                return shouldErrorImpl(fiber);
            }
            var shouldSuspendImpl = function shouldSuspendImpl(fiber) {
                return false;
            };
            function shouldSuspend(fiber) {
                return shouldSuspendImpl(fiber);
            }
            var overrideHookState = null;
            var overrideHookStateDeletePath = null;
            var overrideHookStateRenamePath = null;
            var overrideProps = null;
            var overridePropsDeletePath = null;
            var overridePropsRenamePath = null;
            var scheduleUpdate = null;
            var setErrorHandler = null;
            var setSuspenseHandler = null;
            {
                var copyWithDeleteImpl = function copyWithDeleteImpl1(obj, path, index) {
                    var key = path[index];
                    var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                    if (index + 1 === path.length) {
                        if (isArray(updated)) {
                            updated.splice(key, 1);
                        } else {
                            delete updated[key];
                        }
                        return updated;
                    } // $FlowFixMe number or string is fine here
                    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
                    return updated;
                };
                var copyWithDelete = function copyWithDelete(obj, path) {
                    return copyWithDeleteImpl(obj, path, 0);
                };
                var copyWithRenameImpl = function copyWithRenameImpl1(obj, oldPath, newPath, index) {
                    var oldKey = oldPath[index];
                    var updated = isArray(obj) ? obj.slice() : assign({}, obj);
                    if (index + 1 === oldPath.length) {
                        var newKey = newPath[index]; // $FlowFixMe number or string is fine here
                        updated[newKey] = updated[oldKey];
                        if (isArray(updated)) {
                            updated.splice(oldKey, 1);
                        } else {
                            delete updated[oldKey];
                        }
                    } else {
                        // $FlowFixMe number or string is fine here
                        updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
                    }
                    return updated;
                };
                var copyWithRename = function copyWithRename(obj, oldPath, newPath) {
                    if (oldPath.length !== newPath.length) {
                        warn('copyWithRename() expects paths of the same length');
                        return;
                    } else {
                        for(var i = 0; i < newPath.length - 1; i++){
                            if (oldPath[i] !== newPath[i]) {
                                warn('copyWithRename() expects paths to be the same except for the deepest key');
                                return;
                            }
                        }
                    }
                    return copyWithRenameImpl(obj, oldPath, newPath, 0);
                };
                var copyWithSetImpl = function copyWithSetImpl1(obj, path, index, value) {
                    if (index >= path.length) {
                        return value;
                    }
                    var key = path[index];
                    var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here
                    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
                    return updated;
                };
                var copyWithSet = function copyWithSet(obj, path, value) {
                    return copyWithSetImpl(obj, path, 0, value);
                };
                var findHook = function findHook(fiber, id) {
                    // For now, the "id" of stateful hooks is just the stateful hook index.
                    // This may change in the future with e.g. nested hooks.
                    var currentHook = fiber.memoizedState;
                    while(currentHook !== null && id > 0){
                        currentHook = currentHook.next;
                        id--;
                    }
                    return currentHook;
                }; // Support DevTools editable values for useState and useReducer.
                overrideHookState = function overrideHookState(fiber, id, path, value) {
                    var hook = findHook(fiber, id);
                    if (hook !== null) {
                        var newState = copyWithSet(hook.memoizedState, path, value);
                        hook.memoizedState = newState;
                        hook.baseState = newState; // We aren't actually adding an update to the queue,
                        // because there is no update we can add for useReducer hooks that won't trigger an error.
                        // (There's no appropriate action type for DevTools overrides.)
                        // As a result though, React will see the scheduled update as a noop and bailout.
                        // Shallow cloning props works as a workaround for now to bypass the bailout check.
                        fiber.memoizedProps = assign({}, fiber.memoizedProps);
                        var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                        if (root !== null) {
                            scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                        }
                    }
                };
                overrideHookStateDeletePath = function overrideHookStateDeletePath(fiber, id, path) {
                    var hook = findHook(fiber, id);
                    if (hook !== null) {
                        var newState = copyWithDelete(hook.memoizedState, path);
                        hook.memoizedState = newState;
                        hook.baseState = newState; // We aren't actually adding an update to the queue,
                        // because there is no update we can add for useReducer hooks that won't trigger an error.
                        // (There's no appropriate action type for DevTools overrides.)
                        // As a result though, React will see the scheduled update as a noop and bailout.
                        // Shallow cloning props works as a workaround for now to bypass the bailout check.
                        fiber.memoizedProps = assign({}, fiber.memoizedProps);
                        var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                        if (root !== null) {
                            scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                        }
                    }
                };
                overrideHookStateRenamePath = function overrideHookStateRenamePath(fiber, id, oldPath, newPath) {
                    var hook = findHook(fiber, id);
                    if (hook !== null) {
                        var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                        hook.memoizedState = newState;
                        hook.baseState = newState; // We aren't actually adding an update to the queue,
                        // because there is no update we can add for useReducer hooks that won't trigger an error.
                        // (There's no appropriate action type for DevTools overrides.)
                        // As a result though, React will see the scheduled update as a noop and bailout.
                        // Shallow cloning props works as a workaround for now to bypass the bailout check.
                        fiber.memoizedProps = assign({}, fiber.memoizedProps);
                        var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                        if (root !== null) {
                            scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                        }
                    }
                }; // Support DevTools props for function components, forwardRef, memo, host components, etc.
                overrideProps = function overrideProps(fiber, path, value) {
                    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
                    if (fiber.alternate) {
                        fiber.alternate.pendingProps = fiber.pendingProps;
                    }
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                };
                overridePropsDeletePath = function overridePropsDeletePath(fiber, path) {
                    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
                    if (fiber.alternate) {
                        fiber.alternate.pendingProps = fiber.pendingProps;
                    }
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                };
                overridePropsRenamePath = function overridePropsRenamePath(fiber, oldPath, newPath) {
                    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
                    if (fiber.alternate) {
                        fiber.alternate.pendingProps = fiber.pendingProps;
                    }
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                };
                scheduleUpdate = function scheduleUpdate(fiber) {
                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                    if (root !== null) {
                        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
                    }
                };
                setErrorHandler = function setErrorHandler(newShouldErrorImpl) {
                    shouldErrorImpl = newShouldErrorImpl;
                };
                setSuspenseHandler = function setSuspenseHandler(newShouldSuspendImpl) {
                    shouldSuspendImpl = newShouldSuspendImpl;
                };
            }
            function findHostInstanceByFiber(fiber) {
                var hostFiber = findCurrentHostFiber(fiber);
                if (hostFiber === null) {
                    return null;
                }
                return hostFiber.stateNode;
            }
            function emptyFindFiberByHostInstance(instance) {
                return null;
            }
            function getCurrentFiberForDevTools() {
                return current;
            }
            function injectIntoDevTools(devToolsConfig) {
                var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
                var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
                return injectInternals({
                    bundleType: devToolsConfig.bundleType,
                    version: devToolsConfig.version,
                    rendererPackageName: devToolsConfig.rendererPackageName,
                    rendererConfig: devToolsConfig.rendererConfig,
                    overrideHookState: overrideHookState,
                    overrideHookStateDeletePath: overrideHookStateDeletePath,
                    overrideHookStateRenamePath: overrideHookStateRenamePath,
                    overrideProps: overrideProps,
                    overridePropsDeletePath: overridePropsDeletePath,
                    overridePropsRenamePath: overridePropsRenamePath,
                    setErrorHandler: setErrorHandler,
                    setSuspenseHandler: setSuspenseHandler,
                    scheduleUpdate: scheduleUpdate,
                    currentDispatcherRef: ReactCurrentDispatcher,
                    findHostInstanceByFiber: findHostInstanceByFiber,
                    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
                    // React Refresh
                    findHostInstancesForRefresh: findHostInstancesForRefresh,
                    scheduleRefresh: scheduleRefresh,
                    scheduleRoot: scheduleRoot,
                    setRefreshHandler: setRefreshHandler,
                    // Enables DevTools to append owner stacks to error messages in DEV mode.
                    getCurrentFiber: getCurrentFiberForDevTools,
                    // Enables DevTools to detect reconciler version rather than renderer version
                    // which may not match for third party renderers.
                    reconcilerVersion: ReactVersion
                });
            }
            exports1.attemptContinuousHydration = attemptContinuousHydration;
            exports1.attemptDiscreteHydration = attemptDiscreteHydration;
            exports1.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;
            exports1.attemptSynchronousHydration = attemptSynchronousHydration;
            exports1.batchedUpdates = batchedUpdates;
            exports1.createComponentSelector = createComponentSelector;
            exports1.createContainer = createContainer;
            exports1.createHasPseudoClassSelector = createHasPseudoClassSelector;
            exports1.createHydrationContainer = createHydrationContainer;
            exports1.createPortal = createPortal;
            exports1.createRoleSelector = createRoleSelector;
            exports1.createTestNameSelector = createTestNameSelector;
            exports1.createTextSelector = createTextSelector;
            exports1.deferredUpdates = deferredUpdates;
            exports1.discreteUpdates = discreteUpdates;
            exports1.findAllNodes = findAllNodes;
            exports1.findBoundingRects = findBoundingRects;
            exports1.findHostInstance = findHostInstance;
            exports1.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;
            exports1.findHostInstanceWithWarning = findHostInstanceWithWarning;
            exports1.flushControlled = flushControlled;
            exports1.flushPassiveEffects = flushPassiveEffects;
            exports1.flushSync = flushSync;
            exports1.focusWithin = focusWithin;
            exports1.getCurrentUpdatePriority = getCurrentUpdatePriority;
            exports1.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;
            exports1.getPublicRootInstance = getPublicRootInstance;
            exports1.injectIntoDevTools = injectIntoDevTools;
            exports1.isAlreadyRendering = isAlreadyRendering;
            exports1.observeVisibleRects = observeVisibleRects;
            exports1.registerMutableSourceForHydration = registerMutableSourceForHydration;
            exports1.runWithPriority = runWithPriority;
            exports1.shouldError = shouldError;
            exports1.shouldSuspend = shouldSuspend;
            exports1.updateContainer = updateContainer;
            return exports1;
        };
    }
    return reactReconciler_development.exports;
}
var hasRequiredReactReconciler;
function requireReactReconciler() {
    if (hasRequiredReactReconciler) return reactReconciler.exports;
    hasRequiredReactReconciler = 1;
    if (process.env.NODE_ENV === 'production') {
        reactReconciler.exports = requireReactReconciler_production_min();
    } else {
        reactReconciler.exports = requireReactReconciler_development();
    }
    return reactReconciler.exports;
}
var reactReconcilerExports = requireReactReconciler();
var createReconciler = /*@__PURE__*/ getDefaultExportFromCjs(reactReconcilerExports);
var constants = {
    exports: {}
};
var reactReconcilerConstants_production_min = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactReconcilerConstants_production_min;
function requireReactReconcilerConstants_production_min() {
    if (hasRequiredReactReconcilerConstants_production_min) return reactReconcilerConstants_production_min;
    hasRequiredReactReconcilerConstants_production_min = 1;
    reactReconcilerConstants_production_min.ConcurrentRoot = 1;
    reactReconcilerConstants_production_min.ContinuousEventPriority = 4;
    reactReconcilerConstants_production_min.DefaultEventPriority = 16;
    reactReconcilerConstants_production_min.DiscreteEventPriority = 1;
    reactReconcilerConstants_production_min.IdleEventPriority = 536870912;
    reactReconcilerConstants_production_min.LegacyRoot = 0;
    return reactReconcilerConstants_production_min;
}
var reactReconcilerConstants_development = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactReconcilerConstants_development;
function requireReactReconcilerConstants_development() {
    if (hasRequiredReactReconcilerConstants_development) return reactReconcilerConstants_development;
    hasRequiredReactReconcilerConstants_development = 1;
    if (process.env.NODE_ENV !== "production") {
        (function() {
            var SyncLane = /*                        */ 1;
            var InputContinuousLane = /*             */ 4;
            var DefaultLane = /*                     */ 16;
            var IdleLane = /*                        */ 536870912;
            var DiscreteEventPriority = SyncLane;
            var ContinuousEventPriority = InputContinuousLane;
            var DefaultEventPriority = DefaultLane;
            var IdleEventPriority = IdleLane;
            var LegacyRoot = 0;
            var ConcurrentRoot = 1;
            reactReconcilerConstants_development.ConcurrentRoot = ConcurrentRoot;
            reactReconcilerConstants_development.ContinuousEventPriority = ContinuousEventPriority;
            reactReconcilerConstants_development.DefaultEventPriority = DefaultEventPriority;
            reactReconcilerConstants_development.DiscreteEventPriority = DiscreteEventPriority;
            reactReconcilerConstants_development.IdleEventPriority = IdleEventPriority;
            reactReconcilerConstants_development.LegacyRoot = LegacyRoot;
        })();
    }
    return reactReconcilerConstants_development;
}
var hasRequiredConstants;
function requireConstants() {
    if (hasRequiredConstants) return constants.exports;
    hasRequiredConstants = 1;
    if (process.env.NODE_ENV === 'production') {
        constants.exports = requireReactReconcilerConstants_production_min();
    } else {
        constants.exports = requireReactReconcilerConstants_development();
    }
    return constants.exports;
}
var constantsExports = requireConstants();
function ansiRegex$1() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref_onlyFirst = _ref.onlyFirst, onlyFirst = _ref_onlyFirst === void 0 ? false : _ref_onlyFirst;
    // Valid string terminator sequences are BEL, ESC\, and 0x9c
    var ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
    var pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?".concat(ST, ")"),
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
var regex = ansiRegex$1();
function stripAnsi(string) {
    if (typeof string !== 'string') {
        throw new TypeError("Expected a `string`, got `".concat(typeof string === "undefined" ? "undefined" : _type_of(string), "`"));
    }
    // Even though the regex is global, we don't need to reset the `.lastIndex`
    // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
    // and doing it manually has a performance penalty.
    return string.replace(regex, '');
}
// Generated code.
function isAmbiguous(x) {
    return x === 0xA1 || x === 0xA4 || x === 0xA7 || x === 0xA8 || x === 0xAA || x === 0xAD || x === 0xAE || x >= 0xB0 && x <= 0xB4 || x >= 0xB6 && x <= 0xBA || x >= 0xBC && x <= 0xBF || x === 0xC6 || x === 0xD0 || x === 0xD7 || x === 0xD8 || x >= 0xDE && x <= 0xE1 || x === 0xE6 || x >= 0xE8 && x <= 0xEA || x === 0xEC || x === 0xED || x === 0xF0 || x === 0xF2 || x === 0xF3 || x >= 0xF7 && x <= 0xFA || x === 0xFC || x === 0xFE || x === 0x101 || x === 0x111 || x === 0x113 || x === 0x11B || x === 0x126 || x === 0x127 || x === 0x12B || x >= 0x131 && x <= 0x133 || x === 0x138 || x >= 0x13F && x <= 0x142 || x === 0x144 || x >= 0x148 && x <= 0x14B || x === 0x14D || x === 0x152 || x === 0x153 || x === 0x166 || x === 0x167 || x === 0x16B || x === 0x1CE || x === 0x1D0 || x === 0x1D2 || x === 0x1D4 || x === 0x1D6 || x === 0x1D8 || x === 0x1DA || x === 0x1DC || x === 0x251 || x === 0x261 || x === 0x2C4 || x === 0x2C7 || x >= 0x2C9 && x <= 0x2CB || x === 0x2CD || x === 0x2D0 || x >= 0x2D8 && x <= 0x2DB || x === 0x2DD || x === 0x2DF || x >= 0x300 && x <= 0x36F || x >= 0x391 && x <= 0x3A1 || x >= 0x3A3 && x <= 0x3A9 || x >= 0x3B1 && x <= 0x3C1 || x >= 0x3C3 && x <= 0x3C9 || x === 0x401 || x >= 0x410 && x <= 0x44F || x === 0x451 || x === 0x2010 || x >= 0x2013 && x <= 0x2016 || x === 0x2018 || x === 0x2019 || x === 0x201C || x === 0x201D || x >= 0x2020 && x <= 0x2022 || x >= 0x2024 && x <= 0x2027 || x === 0x2030 || x === 0x2032 || x === 0x2033 || x === 0x2035 || x === 0x203B || x === 0x203E || x === 0x2074 || x === 0x207F || x >= 0x2081 && x <= 0x2084 || x === 0x20AC || x === 0x2103 || x === 0x2105 || x === 0x2109 || x === 0x2113 || x === 0x2116 || x === 0x2121 || x === 0x2122 || x === 0x2126 || x === 0x212B || x === 0x2153 || x === 0x2154 || x >= 0x215B && x <= 0x215E || x >= 0x2160 && x <= 0x216B || x >= 0x2170 && x <= 0x2179 || x === 0x2189 || x >= 0x2190 && x <= 0x2199 || x === 0x21B8 || x === 0x21B9 || x === 0x21D2 || x === 0x21D4 || x === 0x21E7 || x === 0x2200 || x === 0x2202 || x === 0x2203 || x === 0x2207 || x === 0x2208 || x === 0x220B || x === 0x220F || x === 0x2211 || x === 0x2215 || x === 0x221A || x >= 0x221D && x <= 0x2220 || x === 0x2223 || x === 0x2225 || x >= 0x2227 && x <= 0x222C || x === 0x222E || x >= 0x2234 && x <= 0x2237 || x === 0x223C || x === 0x223D || x === 0x2248 || x === 0x224C || x === 0x2252 || x === 0x2260 || x === 0x2261 || x >= 0x2264 && x <= 0x2267 || x === 0x226A || x === 0x226B || x === 0x226E || x === 0x226F || x === 0x2282 || x === 0x2283 || x === 0x2286 || x === 0x2287 || x === 0x2295 || x === 0x2299 || x === 0x22A5 || x === 0x22BF || x === 0x2312 || x >= 0x2460 && x <= 0x24E9 || x >= 0x24EB && x <= 0x254B || x >= 0x2550 && x <= 0x2573 || x >= 0x2580 && x <= 0x258F || x >= 0x2592 && x <= 0x2595 || x === 0x25A0 || x === 0x25A1 || x >= 0x25A3 && x <= 0x25A9 || x === 0x25B2 || x === 0x25B3 || x === 0x25B6 || x === 0x25B7 || x === 0x25BC || x === 0x25BD || x === 0x25C0 || x === 0x25C1 || x >= 0x25C6 && x <= 0x25C8 || x === 0x25CB || x >= 0x25CE && x <= 0x25D1 || x >= 0x25E2 && x <= 0x25E5 || x === 0x25EF || x === 0x2605 || x === 0x2606 || x === 0x2609 || x === 0x260E || x === 0x260F || x === 0x261C || x === 0x261E || x === 0x2640 || x === 0x2642 || x === 0x2660 || x === 0x2661 || x >= 0x2663 && x <= 0x2665 || x >= 0x2667 && x <= 0x266A || x === 0x266C || x === 0x266D || x === 0x266F || x === 0x269E || x === 0x269F || x === 0x26BF || x >= 0x26C6 && x <= 0x26CD || x >= 0x26CF && x <= 0x26D3 || x >= 0x26D5 && x <= 0x26E1 || x === 0x26E3 || x === 0x26E8 || x === 0x26E9 || x >= 0x26EB && x <= 0x26F1 || x === 0x26F4 || x >= 0x26F6 && x <= 0x26F9 || x === 0x26FB || x === 0x26FC || x === 0x26FE || x === 0x26FF || x === 0x273D || x >= 0x2776 && x <= 0x277F || x >= 0x2B56 && x <= 0x2B59 || x >= 0x3248 && x <= 0x324F || x >= 0xE000 && x <= 0xF8FF || x >= 0xFE00 && x <= 0xFE0F || x === 0xFFFD || x >= 0x1F100 && x <= 0x1F10A || x >= 0x1F110 && x <= 0x1F12D || x >= 0x1F130 && x <= 0x1F169 || x >= 0x1F170 && x <= 0x1F18D || x === 0x1F18F || x === 0x1F190 || x >= 0x1F19B && x <= 0x1F1AC || x >= 0xE0100 && x <= 0xE01EF || x >= 0xF0000 && x <= 0xFFFFD || x >= 0x100000 && x <= 0x10FFFD;
}
function isFullWidth(x) {
    return x === 0x3000 || x >= 0xFF01 && x <= 0xFF60 || x >= 0xFFE0 && x <= 0xFFE6;
}
function isWide(x) {
    return x >= 0x1100 && x <= 0x115F || x === 0x231A || x === 0x231B || x === 0x2329 || x === 0x232A || x >= 0x23E9 && x <= 0x23EC || x === 0x23F0 || x === 0x23F3 || x === 0x25FD || x === 0x25FE || x === 0x2614 || x === 0x2615 || x >= 0x2630 && x <= 0x2637 || x >= 0x2648 && x <= 0x2653 || x === 0x267F || x >= 0x268A && x <= 0x268F || x === 0x2693 || x === 0x26A1 || x === 0x26AA || x === 0x26AB || x === 0x26BD || x === 0x26BE || x === 0x26C4 || x === 0x26C5 || x === 0x26CE || x === 0x26D4 || x === 0x26EA || x === 0x26F2 || x === 0x26F3 || x === 0x26F5 || x === 0x26FA || x === 0x26FD || x === 0x2705 || x === 0x270A || x === 0x270B || x === 0x2728 || x === 0x274C || x === 0x274E || x >= 0x2753 && x <= 0x2755 || x === 0x2757 || x >= 0x2795 && x <= 0x2797 || x === 0x27B0 || x === 0x27BF || x === 0x2B1B || x === 0x2B1C || x === 0x2B50 || x === 0x2B55 || x >= 0x2E80 && x <= 0x2E99 || x >= 0x2E9B && x <= 0x2EF3 || x >= 0x2F00 && x <= 0x2FD5 || x >= 0x2FF0 && x <= 0x2FFF || x >= 0x3001 && x <= 0x303E || x >= 0x3041 && x <= 0x3096 || x >= 0x3099 && x <= 0x30FF || x >= 0x3105 && x <= 0x312F || x >= 0x3131 && x <= 0x318E || x >= 0x3190 && x <= 0x31E5 || x >= 0x31EF && x <= 0x321E || x >= 0x3220 && x <= 0x3247 || x >= 0x3250 && x <= 0xA48C || x >= 0xA490 && x <= 0xA4C6 || x >= 0xA960 && x <= 0xA97C || x >= 0xAC00 && x <= 0xD7A3 || x >= 0xF900 && x <= 0xFAFF || x >= 0xFE10 && x <= 0xFE19 || x >= 0xFE30 && x <= 0xFE52 || x >= 0xFE54 && x <= 0xFE66 || x >= 0xFE68 && x <= 0xFE6B || x >= 0x16FE0 && x <= 0x16FE4 || x === 0x16FF0 || x === 0x16FF1 || x >= 0x17000 && x <= 0x187F7 || x >= 0x18800 && x <= 0x18CD5 || x >= 0x18CFF && x <= 0x18D08 || x >= 0x1AFF0 && x <= 0x1AFF3 || x >= 0x1AFF5 && x <= 0x1AFFB || x === 0x1AFFD || x === 0x1AFFE || x >= 0x1B000 && x <= 0x1B122 || x === 0x1B132 || x >= 0x1B150 && x <= 0x1B152 || x === 0x1B155 || x >= 0x1B164 && x <= 0x1B167 || x >= 0x1B170 && x <= 0x1B2FB || x >= 0x1D300 && x <= 0x1D356 || x >= 0x1D360 && x <= 0x1D376 || x === 0x1F004 || x === 0x1F0CF || x === 0x1F18E || x >= 0x1F191 && x <= 0x1F19A || x >= 0x1F200 && x <= 0x1F202 || x >= 0x1F210 && x <= 0x1F23B || x >= 0x1F240 && x <= 0x1F248 || x === 0x1F250 || x === 0x1F251 || x >= 0x1F260 && x <= 0x1F265 || x >= 0x1F300 && x <= 0x1F320 || x >= 0x1F32D && x <= 0x1F335 || x >= 0x1F337 && x <= 0x1F37C || x >= 0x1F37E && x <= 0x1F393 || x >= 0x1F3A0 && x <= 0x1F3CA || x >= 0x1F3CF && x <= 0x1F3D3 || x >= 0x1F3E0 && x <= 0x1F3F0 || x === 0x1F3F4 || x >= 0x1F3F8 && x <= 0x1F43E || x === 0x1F440 || x >= 0x1F442 && x <= 0x1F4FC || x >= 0x1F4FF && x <= 0x1F53D || x >= 0x1F54B && x <= 0x1F54E || x >= 0x1F550 && x <= 0x1F567 || x === 0x1F57A || x === 0x1F595 || x === 0x1F596 || x === 0x1F5A4 || x >= 0x1F5FB && x <= 0x1F64F || x >= 0x1F680 && x <= 0x1F6C5 || x === 0x1F6CC || x >= 0x1F6D0 && x <= 0x1F6D2 || x >= 0x1F6D5 && x <= 0x1F6D7 || x >= 0x1F6DC && x <= 0x1F6DF || x === 0x1F6EB || x === 0x1F6EC || x >= 0x1F6F4 && x <= 0x1F6FC || x >= 0x1F7E0 && x <= 0x1F7EB || x === 0x1F7F0 || x >= 0x1F90C && x <= 0x1F93A || x >= 0x1F93C && x <= 0x1F945 || x >= 0x1F947 && x <= 0x1F9FF || x >= 0x1FA70 && x <= 0x1FA7C || x >= 0x1FA80 && x <= 0x1FA89 || x >= 0x1FA8F && x <= 0x1FAC6 || x >= 0x1FACE && x <= 0x1FADC || x >= 0x1FADF && x <= 0x1FAE9 || x >= 0x1FAF0 && x <= 0x1FAF8 || x >= 0x20000 && x <= 0x2FFFD || x >= 0x30000 && x <= 0x3FFFD;
}
function validate(codePoint) {
    if (!Number.isSafeInteger(codePoint)) {
        throw new TypeError("Expected a code point, got `".concat(typeof codePoint === "undefined" ? "undefined" : _type_of(codePoint), "`."));
    }
}
function eastAsianWidth(codePoint) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_ambiguousAsWide = _ref.ambiguousAsWide, ambiguousAsWide = _ref_ambiguousAsWide === void 0 ? false : _ref_ambiguousAsWide;
    validate(codePoint);
    if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
        return 2;
    }
    return 1;
}
var emojiRegex = function() {
    // https://mths.be/emoji
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
var segmenter = new IntlSegmenter();
var dicpregex; try { dicpregex = RegExp("^\p{Default_Ignorable_Code_Point}$", "u"); } catch(_) { dicpregex = RegExp("^\p{Default_Ignorable_Code_Point}$", "g"); }
function stringWidth(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof string !== 'string' || string.length === 0) {
        return 0;
    }
    var _options_ambiguousIsNarrow = options.ambiguousIsNarrow, ambiguousIsNarrow = _options_ambiguousIsNarrow === void 0 ? true : _options_ambiguousIsNarrow, _options_countAnsiEscapeCodes = options.countAnsiEscapeCodes, countAnsiEscapeCodes = _options_countAnsiEscapeCodes === void 0 ? false : _options_countAnsiEscapeCodes;
    if (!countAnsiEscapeCodes) {
        string = stripAnsi(string);
    }
    if (string.length === 0) {
        return 0;
    }
    var width = 0;
    var eastAsianWidthOptions = {
        ambiguousAsWide: !ambiguousIsNarrow
    };
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = segmenter.segment(string)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _step.value, character = _step_value.segment;
            var codePoint = character.codePointAt(0);
            // Ignore control characters
            if (codePoint <= 0x1F || codePoint >= 0x7F && codePoint <= 0x9F) {
                continue;
            }
            // Ignore zero-width characters
            if (codePoint >= 0x200B && codePoint <= 0x200F // Zero-width space, non-joiner, joiner, left-to-right mark, right-to-left mark
             || codePoint === 0xFEFF // Zero-width no-break space
            ) {
                continue;
            }
            // Ignore combining characters
            if (codePoint >= 0x300 && codePoint <= 0x36F // Combining diacritical marks
             || codePoint >= 0x1AB0 && codePoint <= 0x1AFF // Combining diacritical marks extended
             || codePoint >= 0x1DC0 && codePoint <= 0x1DFF // Combining diacritical marks supplement
             || codePoint >= 0x20D0 && codePoint <= 0x20FF // Combining diacritical marks for symbols
             || codePoint >= 0xFE20 && codePoint <= 0xFE2F // Combining half marks
            ) {
                continue;
            }
            // Ignore surrogate pairs
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                continue;
            }
            // Ignore variation selectors
            if (codePoint >= 0xFE00 && codePoint <= 0xFE0F) {
                continue;
            }
            // This covers some of the above cases, but we still keep them for performance reasons.
            if (dicpregex.test(character)) {
                continue;
            }
            // TODO: Use `/\p{RGI_Emoji}/v` when targeting Node.js 20.
            if (emojiRegex().test(character)) {
                width += 2;
                continue;
            }
            width += eastAsianWidth(codePoint, eastAsianWidthOptions);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return width;
}
function widestLine(string) {
    var lineWidth = 0;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = string.split('\n')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var line = _step.value;
            lineWidth = Math.max(lineWidth, stringWidth(line));
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return lineWidth;
}
var cache$1 = {};
var measureText = function(text) {
    if (text.length === 0) {
        return {
            width: 0,
            height: 0
        };
    }
    var cachedDimensions = cache$1[text];
    if (cachedDimensions) {
        return cachedDimensions;
    }
    var width = widestLine(text);
    var height = text.split('\n').length;
    cache$1[text] = {
        width: width,
        height: height
    };
    return {
        width: width,
        height: height
    };
};
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = function() {
    var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return function(code) {
        return "\x1b[".concat(code + offset, "m");
    };
};
var wrapAnsi256 = function() {
    var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return function(code) {
        return "\x1b[".concat(38 + offset, ";5;").concat(code, "m");
    };
};
var wrapAnsi16m = function() {
    var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return function(red, green, blue) {
        return "\x1b[".concat(38 + offset, ";2;").concat(red, ";").concat(green, ";").concat(blue, "m");
    };
};
var styles$1 = {
    modifier: {
        reset: [
            0,
            0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
            1,
            22
        ],
        dim: [
            2,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        overline: [
            53,
            55
        ],
        inverse: [
            7,
            27
        ],
        hidden: [
            8,
            28
        ],
        strikethrough: [
            9,
            29
        ]
    },
    color: {
        black: [
            30,
            39
        ],
        red: [
            31,
            39
        ],
        green: [
            32,
            39
        ],
        yellow: [
            33,
            39
        ],
        blue: [
            34,
            39
        ],
        magenta: [
            35,
            39
        ],
        cyan: [
            36,
            39
        ],
        white: [
            37,
            39
        ],
        // Bright color
        blackBright: [
            90,
            39
        ],
        gray: [
            90,
            39
        ],
        grey: [
            90,
            39
        ],
        redBright: [
            91,
            39
        ],
        greenBright: [
            92,
            39
        ],
        yellowBright: [
            93,
            39
        ],
        blueBright: [
            94,
            39
        ],
        magentaBright: [
            95,
            39
        ],
        cyanBright: [
            96,
            39
        ],
        whiteBright: [
            97,
            39
        ]
    },
    bgColor: {
        bgBlack: [
            40,
            49
        ],
        bgRed: [
            41,
            49
        ],
        bgGreen: [
            42,
            49
        ],
        bgYellow: [
            43,
            49
        ],
        bgBlue: [
            44,
            49
        ],
        bgMagenta: [
            45,
            49
        ],
        bgCyan: [
            46,
            49
        ],
        bgWhite: [
            47,
            49
        ],
        // Bright color
        bgBlackBright: [
            100,
            49
        ],
        bgGray: [
            100,
            49
        ],
        bgGrey: [
            100,
            49
        ],
        bgRedBright: [
            101,
            49
        ],
        bgGreenBright: [
            102,
            49
        ],
        bgYellowBright: [
            103,
            49
        ],
        bgBlueBright: [
            104,
            49
        ],
        bgMagentaBright: [
            105,
            49
        ],
        bgCyanBright: [
            106,
            49
        ],
        bgWhiteBright: [
            107,
            49
        ]
    }
};
Object.keys(styles$1.modifier);
var foregroundColorNames = Object.keys(styles$1.color);
var backgroundColorNames = Object.keys(styles$1.bgColor);
_to_consumable_array(foregroundColorNames).concat(_to_consumable_array(backgroundColorNames));
function assembleStyles() {
    var _styles$1;
    var codes = new Map();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.entries(styles$1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), groupName = _step_value[0], group = _step_value[1];
            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
            try {
                for(var _iterator1 = Object.entries(group)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                    var _step_value1 = _sliced_to_array(_step1.value, 2), styleName = _step_value1[0], style = _step_value1[1];
                    styles$1[styleName] = {
                        open: "\x1b[".concat(style[0], "m"),
                        close: "\x1b[".concat(style[1], "m")
                    };
                    group[styleName] = styles$1[styleName];
                    codes.set(style[0], style[1]);
                }
            } catch (err) {
                _didIteratorError1 = true;
                _iteratorError1 = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                } finally{
                    if (_didIteratorError1) {
                        throw _iteratorError1;
                    }
                }
            }
            Object.defineProperty(styles$1, groupName, {
                value: group,
                enumerable: false
            });
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    Object.defineProperty(styles$1, 'codes', {
        value: codes,
        enumerable: false
    });
    styles$1.color.close = '\u001B[39m';
    styles$1.bgColor.close = '\u001B[49m';
    styles$1.color.ansi = wrapAnsi16();
    styles$1.color.ansi256 = wrapAnsi256();
    styles$1.color.ansi16m = wrapAnsi16m();
    styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles$1, {
        rgbToAnsi256: {
            value: function(red, green, blue) {
                // We use the extended greyscale palette here, with the exception of
                // black and white. normal palette only has 4 greyscale shades.
                if (red === green && green === blue) {
                    if (red < 8) {
                        return 16;
                    }
                    if (red > 248) {
                        return 231;
                    }
                    return Math.round((red - 8) / 247 * 24) + 232;
                }
                return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
            },
            enumerable: false
        },
        hexToRgb: {
            value: function(hex) {
                var matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                var _matches = _sliced_to_array(matches, 1), colorString = _matches[0];
                if (colorString.length === 3) {
                    colorString = _to_consumable_array(colorString).map(function(character) {
                        return character + character;
                    }).join('');
                }
                var integer = Number.parseInt(colorString, 16);
                return [
                    /* eslint-disable no-bitwise */ integer >> 16 & 0xFF,
                    integer >> 8 & 0xFF,
                    integer & 0xFF
                ];
            },
            enumerable: false
        },
        hexToAnsi256: {
            value: function(hex) {
                return (_styles$1 = styles$1).rgbToAnsi256.apply(_styles$1, _to_consumable_array(styles$1.hexToRgb(hex)));
            },
            enumerable: false
        },
        ansi256ToAnsi: {
            value: function(code) {
                if (code < 8) {
                    return 30 + code;
                }
                if (code < 16) {
                    return 90 + (code - 8);
                }
                var red;
                var green;
                var blue;
                if (code >= 232) {
                    red = ((code - 232) * 10 + 8) / 255;
                    green = red;
                    blue = red;
                } else {
                    code -= 16;
                    var remainder = code % 36;
                    red = Math.floor(code / 36) / 5;
                    green = Math.floor(remainder / 6) / 5;
                    blue = remainder % 6 / 5;
                }
                var value = Math.max(red, green, blue) * 2;
                if (value === 0) {
                    return 30;
                }
                // eslint-disable-next-line no-bitwise
                var result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                if (value === 2) {
                    result += 60;
                }
                return result;
            },
            enumerable: false
        },
        rgbToAnsi: {
            value: function(red, green, blue) {
                return styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue));
            },
            enumerable: false
        },
        hexToAnsi: {
            value: function(hex) {
                return styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex));
            },
            enumerable: false
        }
    });
    return styles$1;
}
var ansiStyles = assembleStyles();
var ESCAPES$3 = new Set([
    '\u001B',
    '\u009B'
]);
var END_CODE = 39;
var ANSI_ESCAPE_BELL = '\u0007';
var ANSI_CSI = '[';
var ANSI_OSC = ']';
var ANSI_SGR_TERMINATOR = 'm';
var ANSI_ESCAPE_LINK = "".concat(ANSI_OSC, "8;;");
var wrapAnsiCode = function(code) {
    return "".concat(ESCAPES$3.values().next().value).concat(ANSI_CSI).concat(code).concat(ANSI_SGR_TERMINATOR);
};
var wrapAnsiHyperlink = function(url) {
    return "".concat(ESCAPES$3.values().next().value).concat(ANSI_ESCAPE_LINK).concat(url).concat(ANSI_ESCAPE_BELL);
};
// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
var wordLengths = function(string) {
    return string.split(' ').map(function(character) {
        return stringWidth(character);
    });
};
// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
var wrapWord = function(rows, word, columns) {
    var characters = _to_consumable_array(word);
    var isInsideEscape = false;
    var isInsideLinkEscape = false;
    var visible = stringWidth(stripAnsi(rows.at(-1)));
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = characters.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], character = _step_value[1];
            var characterLength = stringWidth(character);
            if (visible + characterLength <= columns) {
                rows[rows.length - 1] += character;
            } else {
                rows.push(character);
                visible = 0;
            }
            if (ESCAPES$3.has(character)) {
                isInsideEscape = true;
                var ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join('');
                isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
            }
            if (isInsideEscape) {
                if (isInsideLinkEscape) {
                    if (character === ANSI_ESCAPE_BELL) {
                        isInsideEscape = false;
                        isInsideLinkEscape = false;
                    }
                } else if (character === ANSI_SGR_TERMINATOR) {
                    isInsideEscape = false;
                }
                continue;
            }
            visible += characterLength;
            if (visible === columns && index < characters.length - 1) {
                rows.push('');
                visible = 0;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    // It's possible that the last row we copy over is only
    // ansi escape characters, handle this edge-case
    if (!visible && rows.at(-1).length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
    }
};
// Trims spaces from a string ignoring invisible sequences
var stringVisibleTrimSpacesRight = function(string) {
    var words = string.split(' ');
    var last = words.length;
    while(last > 0){
        if (stringWidth(words[last - 1]) > 0) {
            break;
        }
        last--;
    }
    if (last === words.length) {
        return string;
    }
    return words.slice(0, last).join(' ') + words.slice(last).join('');
};
// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode.
//
// 'hard' will never allow a string to take up more than columns characters.
//
// 'soft' allows long words to expand past the column length.
var exec = function(string, columns) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (options.trim !== false && string.trim() === '') {
        return '';
    }
    var returnValue = '';
    var escapeCode;
    var escapeUrl;
    var lengths = wordLengths(string);
    var rows = [
        ''
    ];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = string.split(' ').entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], word = _step_value[1];
            if (options.trim !== false) {
                rows[rows.length - 1] = rows.at(-1).trimStart();
            }
            var rowLength = stringWidth(rows.at(-1));
            if (index !== 0) {
                if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
                    // If we start with a new word but the current row length equals the length of the columns, add a new row
                    rows.push('');
                    rowLength = 0;
                }
                if (rowLength > 0 || options.trim === false) {
                    rows[rows.length - 1] += ' ';
                    rowLength++;
                }
            }
            // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
            if (options.hard && lengths[index] > columns) {
                var remainingColumns = columns - rowLength;
                var breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
                var breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
                if (breaksStartingNextLine < breaksStartingThisLine) {
                    rows.push('');
                }
                wrapWord(rows, word, columns);
                continue;
            }
            if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
                if (options.wordWrap === false && rowLength < columns) {
                    wrapWord(rows, word, columns);
                    continue;
                }
                rows.push('');
            }
            if (rowLength + lengths[index] > columns && options.wordWrap === false) {
                wrapWord(rows, word, columns);
                continue;
            }
            rows[rows.length - 1] += word;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (options.trim !== false) {
        rows = rows.map(function(row) {
            return stringVisibleTrimSpacesRight(row);
        });
    }
    var preString = rows.join('\n');
    var pre = _to_consumable_array(preString);
    // We need to keep a separate index as `String#slice()` works on Unicode code units, while `pre` is an array of codepoints.
    var preStringIndex = 0;
    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
    try {
        for(var _iterator1 = pre.entries()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
            var _step_value1 = _sliced_to_array(_step1.value, 2), index1 = _step_value1[0], character = _step_value1[1];
            returnValue += character;
            if (ESCAPES$3.has(character)) {
                var groups = (new RegExp("(?:\\".concat(ANSI_CSI, "(?<code>\\d+)m|\\").concat(ANSI_ESCAPE_LINK, "(?<uri>.*)").concat(ANSI_ESCAPE_BELL, ")")).exec(preString.slice(preStringIndex)) || {
                    groups: {}
                }).groups;
                if (groups.code !== undefined) {
                    var code = Number.parseFloat(groups.code);
                    escapeCode = code === END_CODE ? undefined : code;
                } else if (groups.uri !== undefined) {
                    escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
                }
            }
            var code1 = ansiStyles.codes.get(Number(escapeCode));
            if (pre[index1 + 1] === '\n') {
                if (escapeUrl) {
                    returnValue += wrapAnsiHyperlink('');
                }
                if (escapeCode && code1) {
                    returnValue += wrapAnsiCode(code1);
                }
            } else if (character === '\n') {
                if (escapeCode && code1) {
                    returnValue += wrapAnsiCode(escapeCode);
                }
                if (escapeUrl) {
                    returnValue += wrapAnsiHyperlink(escapeUrl);
                }
            }
            preStringIndex += character.length;
        }
    } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
            }
        } finally{
            if (_didIteratorError1) {
                throw _iteratorError1;
            }
        }
    }
    return returnValue;
};
// For each newline, invoke the method separately
function wrapAnsi$1(string, columns, options) {
    return String(string).normalize().replaceAll('\r\n', '\n').split('\n').map(function(line) {
        return exec(line, columns, options);
    }).join('\n');
}
/* eslint-disable yoda */ function isFullwidthCodePoint$1(codePoint) {
    if (!Number.isInteger(codePoint)) {
        return false;
    }
    // Code points are derived from:
    // https://unicode.org/Public/UNIDATA/EastAsianWidth.txt
    return codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
    // CJK Radicals Supplement .. Enclosed CJK Letters and Months
    0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
    0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
    0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
    0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
    0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
    0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
    0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
    0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
    0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
    0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    0x20000 <= codePoint && codePoint <= 0x3FFFD);
}
var astralRegex = /^[\uD800-\uDBFF][\uDC00-\uDFFF]$/;
var ESCAPES$2 = [
    '\u001B',
    '\u009B'
];
var wrapAnsi = function(code) {
    return "".concat(ESCAPES$2[0], "[").concat(code, "m");
};
var checkAnsi = function(ansiCodes, isEscapes, endAnsiCode) {
    var output = [];
    ansiCodes = _to_consumable_array(ansiCodes);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = ansiCodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var ansiCode = _step.value;
            var ansiCodeOrigin = ansiCode;
            if (ansiCode.includes(';')) {
                ansiCode = ansiCode.split(';')[0][0] + '0';
            }
            var item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));
            if (item) {
                var indexEscape = ansiCodes.indexOf(item.toString());
                if (indexEscape === -1) {
                    output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
                } else {
                    ansiCodes.splice(indexEscape, 1);
                }
            } else if (isEscapes) {
                output.push(wrapAnsi(0));
                break;
            } else {
                output.push(wrapAnsi(ansiCodeOrigin));
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (isEscapes) {
        output = output.filter(function(element, index) {
            return output.indexOf(element) === index;
        });
        if (endAnsiCode !== undefined) {
            var fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
            // TODO: Remove the use of `.reduce` here.
            // eslint-disable-next-line unicorn/no-array-reduce
            output = output.reduce(function(current, next) {
                return next === fistEscapeCode ? [
                    next
                ].concat(_to_consumable_array(current)) : _to_consumable_array(current).concat([
                    next
                ]);
            }, []);
        }
    }
    return output.join('');
};
function sliceAnsi$1(string, begin, end) {
    var characters = _to_consumable_array(string);
    var ansiCodes = [];
    var stringEnd = typeof end === 'number' ? end : characters.length;
    var isInsideEscape = false;
    var ansiCode;
    var visible = 0;
    var output = '';
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = characters.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], character = _step_value[1];
            var leftEscape = false;
            if (ESCAPES$2.includes(character)) {
                var code = /\d[^m]*/.exec(string.slice(index, index + 18));
                ansiCode = code && code.length > 0 ? code[0] : undefined;
                if (visible < stringEnd) {
                    isInsideEscape = true;
                    if (ansiCode !== undefined) {
                        ansiCodes.push(ansiCode);
                    }
                }
            } else if (isInsideEscape && character === 'm') {
                isInsideEscape = false;
                leftEscape = true;
            }
            if (!isInsideEscape && !leftEscape) {
                visible++;
            }
            if (!astralRegex.test(character) && isFullwidthCodePoint$1(character.codePointAt())) {
                visible++;
                if (typeof end !== 'number') {
                    stringEnd++;
                }
            }
            if (visible > begin && visible <= stringEnd) {
                output += character;
            } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {
                output = checkAnsi(ansiCodes);
            } else if (visible >= stringEnd) {
                output += checkAnsi(ansiCodes, true, ansiCode);
                break;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return output;
}
function getIndexOfNearestSpace(string, wantedIndex, shouldSearchRight) {
    if (string.charAt(wantedIndex) === ' ') {
        return wantedIndex;
    }
    var direction = shouldSearchRight ? 1 : -1;
    for(var index = 0; index <= 3; index++){
        var finalIndex = wantedIndex + index * direction;
        if (string.charAt(finalIndex) === ' ') {
            return finalIndex;
        }
    }
    return wantedIndex;
}
function cliTruncate(text, columns) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _options_position = options.position, position = _options_position === void 0 ? 'end' : _options_position, _options_space = options.space, space = _options_space === void 0 ? false : _options_space, _options_preferTruncationOnSpace = options.preferTruncationOnSpace, preferTruncationOnSpace = _options_preferTruncationOnSpace === void 0 ? false : _options_preferTruncationOnSpace;
    var _options_truncationCharacter = options.truncationCharacter, truncationCharacter = _options_truncationCharacter === void 0 ? '…' : _options_truncationCharacter;
    if (typeof text !== 'string') {
        throw new TypeError("Expected `input` to be a string, got ".concat(typeof text === "undefined" ? "undefined" : _type_of(text)));
    }
    if (typeof columns !== 'number') {
        throw new TypeError("Expected `columns` to be a number, got ".concat(typeof columns === "undefined" ? "undefined" : _type_of(columns)));
    }
    if (columns < 1) {
        return '';
    }
    if (columns === 1) {
        return truncationCharacter;
    }
    var length = stringWidth(text);
    if (length <= columns) {
        return text;
    }
    if (position === 'start') {
        if (preferTruncationOnSpace) {
            var nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
            return truncationCharacter + sliceAnsi$1(text, nearestSpace, length).trim();
        }
        if (space === true) {
            truncationCharacter += ' ';
        }
        return truncationCharacter + sliceAnsi$1(text, length - columns + stringWidth(truncationCharacter), length);
    }
    if (position === 'middle') {
        if (space === true) {
            truncationCharacter = " ".concat(truncationCharacter, " ");
        }
        var half = Math.floor(columns / 2);
        if (preferTruncationOnSpace) {
            var spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
            var spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
            return sliceAnsi$1(text, 0, spaceNearFirstBreakPoint) + truncationCharacter + sliceAnsi$1(text, spaceNearSecondBreakPoint, length).trim();
        }
        return sliceAnsi$1(text, 0, half) + truncationCharacter + sliceAnsi$1(text, length - (columns - half) + stringWidth(truncationCharacter), length);
    }
    if (position === 'end') {
        if (preferTruncationOnSpace) {
            var nearestSpace1 = getIndexOfNearestSpace(text, columns - 1);
            return sliceAnsi$1(text, 0, nearestSpace1) + truncationCharacter;
        }
        if (space === true) {
            truncationCharacter = " ".concat(truncationCharacter);
        }
        return sliceAnsi$1(text, 0, columns - stringWidth(truncationCharacter)) + truncationCharacter;
    }
    throw new Error("Expected `options.position` to be either `start`, `middle` or `end`, got ".concat(position));
}
var cache = {};
var wrapText = function(text, maxWidth, wrapType) {
    var cacheKey = text + String(maxWidth) + String(wrapType);
    var cachedText = cache[cacheKey];
    if (cachedText) {
        return cachedText;
    }
    var wrappedText = text;
    if (wrapType === 'wrap') {
        wrappedText = wrapAnsi$1(text, maxWidth, {
            trim: false,
            hard: true
        });
    }
    if (wrapType.startsWith('truncate')) {
        var position = 'end';
        if (wrapType === 'truncate-middle') {
            position = 'middle';
        }
        if (wrapType === 'truncate-start') {
            position = 'start';
        }
        wrappedText = cliTruncate(text, maxWidth, {
            position: position
        });
    }
    cache[cacheKey] = wrappedText;
    return wrappedText;
};
// Squashing text nodes allows to combine multiple text nodes into one and write
// to `Output` instance only once. For example, <Text>hello{' '}world</Text>
// is actually 3 text nodes, which would result 3 writes to `Output`.
//
// Also, this is necessary for libraries like ink-link (https://github.com/sindresorhus/ink-link),
// which need to wrap all children at once, instead of wrapping 3 text nodes separately.
var squashTextNodes = function(node) {
    var text = '';
    for(var index = 0; index < node.childNodes.length; index++){
        var childNode = node.childNodes[index];
        if (childNode === undefined) {
            continue;
        }
        var nodeText = '';
        if (childNode.nodeName === '#text') {
            nodeText = childNode.nodeValue;
        } else {
            if (childNode.nodeName === 'ink-text' || childNode.nodeName === 'ink-virtual-text') {
                nodeText = squashTextNodes(childNode);
            }
            // Since these text nodes are being concatenated, `Output` instance won't be able to
            // apply children transform, so we have to do it manually here for each text node
            if (nodeText.length > 0 && typeof childNode.internal_transform === 'function') {
                nodeText = childNode.internal_transform(nodeText, index);
            }
        }
        text += nodeText;
    }
    return text;
};
var createNode = function(nodeName) {
    var node = {
        nodeName: nodeName,
        style: {},
        attributes: {},
        childNodes: [],
        parentNode: undefined,
        yogaNode: nodeName === 'ink-virtual-text' ? undefined : Yoga$1.Node.create()
    };
    if (nodeName === 'ink-text') {
        var _node_yogaNode;
        (_node_yogaNode = node.yogaNode) === null || _node_yogaNode === void 0 ? void 0 : _node_yogaNode.setMeasureFunc(measureTextNode.bind(null, node));
    }
    return node;
};
var appendChildNode = function(node, childNode) {
    if (childNode.parentNode) {
        removeChildNode(childNode.parentNode, childNode);
    }
    childNode.parentNode = node;
    node.childNodes.push(childNode);
    if (childNode.yogaNode) {
        var _node_yogaNode;
        (_node_yogaNode = node.yogaNode) === null || _node_yogaNode === void 0 ? void 0 : _node_yogaNode.insertChild(childNode.yogaNode, node.yogaNode.getChildCount());
    }
    if (node.nodeName === 'ink-text' || node.nodeName === 'ink-virtual-text') {
        markNodeAsDirty(node);
    }
};
var insertBeforeNode = function(node, newChildNode, beforeChildNode) {
    if (newChildNode.parentNode) {
        removeChildNode(newChildNode.parentNode, newChildNode);
    }
    newChildNode.parentNode = node;
    var index = node.childNodes.indexOf(beforeChildNode);
    if (index >= 0) {
        node.childNodes.splice(index, 0, newChildNode);
        if (newChildNode.yogaNode) {
            var _node_yogaNode;
            (_node_yogaNode = node.yogaNode) === null || _node_yogaNode === void 0 ? void 0 : _node_yogaNode.insertChild(newChildNode.yogaNode, index);
        }
        return;
    }
    node.childNodes.push(newChildNode);
    if (newChildNode.yogaNode) {
        var _node_yogaNode1;
        (_node_yogaNode1 = node.yogaNode) === null || _node_yogaNode1 === void 0 ? void 0 : _node_yogaNode1.insertChild(newChildNode.yogaNode, node.yogaNode.getChildCount());
    }
    if (node.nodeName === 'ink-text' || node.nodeName === 'ink-virtual-text') {
        markNodeAsDirty(node);
    }
};
var removeChildNode = function(node, removeNode) {
    if (removeNode.yogaNode) {
        var _removeNode_parentNode_yogaNode, _removeNode_parentNode;
        (_removeNode_parentNode = removeNode.parentNode) === null || _removeNode_parentNode === void 0 ? void 0 : (_removeNode_parentNode_yogaNode = _removeNode_parentNode.yogaNode) === null || _removeNode_parentNode_yogaNode === void 0 ? void 0 : _removeNode_parentNode_yogaNode.removeChild(removeNode.yogaNode);
    }
    removeNode.parentNode = undefined;
    var index = node.childNodes.indexOf(removeNode);
    if (index >= 0) {
        node.childNodes.splice(index, 1);
    }
    if (node.nodeName === 'ink-text' || node.nodeName === 'ink-virtual-text') {
        markNodeAsDirty(node);
    }
};
var setAttribute = function(node, key, value) {
    node.attributes[key] = value;
};
var setStyle = function(node, style) {
    node.style = style;
};
var createTextNode = function(text) {
    var node = {
        nodeName: '#text',
        nodeValue: text,
        yogaNode: undefined,
        parentNode: undefined,
        style: {}
    };
    setTextNodeValue(node, text);
    return node;
};
var measureTextNode = function measureTextNode(node, width) {
    var _node_style;
    var text = node.nodeName === '#text' ? node.nodeValue : squashTextNodes(node);
    var dimensions = measureText(text);
    // Text fits into container, no need to wrap
    if (dimensions.width <= width) {
        return dimensions;
    }
    // This is happening when <Box> is shrinking child nodes and Yoga asks
    // if we can fit this text node in a <1px space, so we just tell Yoga "no"
    if (dimensions.width >= 1 && width > 0 && width < 1) {
        return dimensions;
    }
    var _node_style_textWrap;
    var textWrap = (_node_style_textWrap = (_node_style = node.style) === null || _node_style === void 0 ? void 0 : _node_style.textWrap) !== null && _node_style_textWrap !== void 0 ? _node_style_textWrap : 'wrap';
    var wrappedText = wrapText(text, width, textWrap);
    return measureText(wrappedText);
};
var findClosestYogaNode = function(node) {
    if (!(node === null || node === void 0 ? void 0 : node.parentNode)) {
        return undefined;
    }
    var _node_yogaNode;
    return (_node_yogaNode = node.yogaNode) !== null && _node_yogaNode !== void 0 ? _node_yogaNode : findClosestYogaNode(node.parentNode);
};
var markNodeAsDirty = function(node) {
    // Mark closest Yoga node as dirty to measure text dimensions again
    var yogaNode = findClosestYogaNode(node);
    yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.markDirty();
};
var setTextNodeValue = function(node, text) {
    if (typeof text !== 'string') {
        text = String(text);
    }
    node.nodeValue = text;
    markNodeAsDirty(node);
};
var applyPositionStyles = function(node, style) {
    if ('position' in style) {
        node.setPositionType(style.position === 'absolute' ? Yoga$1.POSITION_TYPE_ABSOLUTE : Yoga$1.POSITION_TYPE_RELATIVE);
    }
};
var applyMarginStyles = function(node, style) {
    if ('margin' in style) {
        var _style_margin;
        node.setMargin(Yoga$1.EDGE_ALL, (_style_margin = style.margin) !== null && _style_margin !== void 0 ? _style_margin : 0);
    }
    if ('marginX' in style) {
        var _style_marginX;
        node.setMargin(Yoga$1.EDGE_HORIZONTAL, (_style_marginX = style.marginX) !== null && _style_marginX !== void 0 ? _style_marginX : 0);
    }
    if ('marginY' in style) {
        var _style_marginY;
        node.setMargin(Yoga$1.EDGE_VERTICAL, (_style_marginY = style.marginY) !== null && _style_marginY !== void 0 ? _style_marginY : 0);
    }
    if ('marginLeft' in style) {
        node.setMargin(Yoga$1.EDGE_START, style.marginLeft || 0);
    }
    if ('marginRight' in style) {
        node.setMargin(Yoga$1.EDGE_END, style.marginRight || 0);
    }
    if ('marginTop' in style) {
        node.setMargin(Yoga$1.EDGE_TOP, style.marginTop || 0);
    }
    if ('marginBottom' in style) {
        node.setMargin(Yoga$1.EDGE_BOTTOM, style.marginBottom || 0);
    }
};
var applyPaddingStyles = function(node, style) {
    if ('padding' in style) {
        var _style_padding;
        node.setPadding(Yoga$1.EDGE_ALL, (_style_padding = style.padding) !== null && _style_padding !== void 0 ? _style_padding : 0);
    }
    if ('paddingX' in style) {
        var _style_paddingX;
        node.setPadding(Yoga$1.EDGE_HORIZONTAL, (_style_paddingX = style.paddingX) !== null && _style_paddingX !== void 0 ? _style_paddingX : 0);
    }
    if ('paddingY' in style) {
        var _style_paddingY;
        node.setPadding(Yoga$1.EDGE_VERTICAL, (_style_paddingY = style.paddingY) !== null && _style_paddingY !== void 0 ? _style_paddingY : 0);
    }
    if ('paddingLeft' in style) {
        node.setPadding(Yoga$1.EDGE_LEFT, style.paddingLeft || 0);
    }
    if ('paddingRight' in style) {
        node.setPadding(Yoga$1.EDGE_RIGHT, style.paddingRight || 0);
    }
    if ('paddingTop' in style) {
        node.setPadding(Yoga$1.EDGE_TOP, style.paddingTop || 0);
    }
    if ('paddingBottom' in style) {
        node.setPadding(Yoga$1.EDGE_BOTTOM, style.paddingBottom || 0);
    }
};
var applyFlexStyles = function(node, style) {
    if ('flexGrow' in style) {
        var _style_flexGrow;
        node.setFlexGrow((_style_flexGrow = style.flexGrow) !== null && _style_flexGrow !== void 0 ? _style_flexGrow : 0);
    }
    if ('flexShrink' in style) {
        node.setFlexShrink(typeof style.flexShrink === 'number' ? style.flexShrink : 1);
    }
    if ('flexWrap' in style) {
        if (style.flexWrap === 'nowrap') {
            node.setFlexWrap(Yoga$1.WRAP_NO_WRAP);
        }
        if (style.flexWrap === 'wrap') {
            node.setFlexWrap(Yoga$1.WRAP_WRAP);
        }
        if (style.flexWrap === 'wrap-reverse') {
            node.setFlexWrap(Yoga$1.WRAP_WRAP_REVERSE);
        }
    }
    if ('flexDirection' in style) {
        if (style.flexDirection === 'row') {
            node.setFlexDirection(Yoga$1.FLEX_DIRECTION_ROW);
        }
        if (style.flexDirection === 'row-reverse') {
            node.setFlexDirection(Yoga$1.FLEX_DIRECTION_ROW_REVERSE);
        }
        if (style.flexDirection === 'column') {
            node.setFlexDirection(Yoga$1.FLEX_DIRECTION_COLUMN);
        }
        if (style.flexDirection === 'column-reverse') {
            node.setFlexDirection(Yoga$1.FLEX_DIRECTION_COLUMN_REVERSE);
        }
    }
    if ('flexBasis' in style) {
        if (typeof style.flexBasis === 'number') {
            node.setFlexBasis(style.flexBasis);
        } else if (typeof style.flexBasis === 'string') {
            node.setFlexBasisPercent(Number.parseInt(style.flexBasis, 10));
        } else {
            // This should be replaced with node.setFlexBasisAuto() when new Yoga release is out
            node.setFlexBasis(Number.NaN);
        }
    }
    if ('alignItems' in style) {
        if (style.alignItems === 'stretch' || !style.alignItems) {
            node.setAlignItems(Yoga$1.ALIGN_STRETCH);
        }
        if (style.alignItems === 'flex-start') {
            node.setAlignItems(Yoga$1.ALIGN_FLEX_START);
        }
        if (style.alignItems === 'center') {
            node.setAlignItems(Yoga$1.ALIGN_CENTER);
        }
        if (style.alignItems === 'flex-end') {
            node.setAlignItems(Yoga$1.ALIGN_FLEX_END);
        }
    }
    if ('alignSelf' in style) {
        if (style.alignSelf === 'auto' || !style.alignSelf) {
            node.setAlignSelf(Yoga$1.ALIGN_AUTO);
        }
        if (style.alignSelf === 'flex-start') {
            node.setAlignSelf(Yoga$1.ALIGN_FLEX_START);
        }
        if (style.alignSelf === 'center') {
            node.setAlignSelf(Yoga$1.ALIGN_CENTER);
        }
        if (style.alignSelf === 'flex-end') {
            node.setAlignSelf(Yoga$1.ALIGN_FLEX_END);
        }
    }
    if ('justifyContent' in style) {
        if (style.justifyContent === 'flex-start' || !style.justifyContent) {
            node.setJustifyContent(Yoga$1.JUSTIFY_FLEX_START);
        }
        if (style.justifyContent === 'center') {
            node.setJustifyContent(Yoga$1.JUSTIFY_CENTER);
        }
        if (style.justifyContent === 'flex-end') {
            node.setJustifyContent(Yoga$1.JUSTIFY_FLEX_END);
        }
        if (style.justifyContent === 'space-between') {
            node.setJustifyContent(Yoga$1.JUSTIFY_SPACE_BETWEEN);
        }
        if (style.justifyContent === 'space-around') {
            node.setJustifyContent(Yoga$1.JUSTIFY_SPACE_AROUND);
        }
        if (style.justifyContent === 'space-evenly') {
            node.setJustifyContent(Yoga$1.JUSTIFY_SPACE_EVENLY);
        }
    }
};
var applyDimensionStyles = function(node, style) {
    if ('width' in style) {
        if (typeof style.width === 'number') {
            node.setWidth(style.width);
        } else if (typeof style.width === 'string') {
            node.setWidthPercent(Number.parseInt(style.width, 10));
        } else {
            node.setWidthAuto();
        }
    }
    if ('height' in style) {
        if (typeof style.height === 'number') {
            node.setHeight(style.height);
        } else if (typeof style.height === 'string') {
            node.setHeightPercent(Number.parseInt(style.height, 10));
        } else {
            node.setHeightAuto();
        }
    }
    if ('minWidth' in style) {
        if (typeof style.minWidth === 'string') {
            node.setMinWidthPercent(Number.parseInt(style.minWidth, 10));
        } else {
            var _style_minWidth;
            node.setMinWidth((_style_minWidth = style.minWidth) !== null && _style_minWidth !== void 0 ? _style_minWidth : 0);
        }
    }
    if ('minHeight' in style) {
        if (typeof style.minHeight === 'string') {
            node.setMinHeightPercent(Number.parseInt(style.minHeight, 10));
        } else {
            var _style_minHeight;
            node.setMinHeight((_style_minHeight = style.minHeight) !== null && _style_minHeight !== void 0 ? _style_minHeight : 0);
        }
    }
};
var applyDisplayStyles = function(node, style) {
    if ('display' in style) {
        node.setDisplay(style.display === 'flex' ? Yoga$1.DISPLAY_FLEX : Yoga$1.DISPLAY_NONE);
    }
};
var applyBorderStyles = function(node, style) {
    if ('borderStyle' in style) {
        var borderWidth = style.borderStyle ? 1 : 0;
        if (style.borderTop !== false) {
            node.setBorder(Yoga$1.EDGE_TOP, borderWidth);
        }
        if (style.borderBottom !== false) {
            node.setBorder(Yoga$1.EDGE_BOTTOM, borderWidth);
        }
        if (style.borderLeft !== false) {
            node.setBorder(Yoga$1.EDGE_LEFT, borderWidth);
        }
        if (style.borderRight !== false) {
            node.setBorder(Yoga$1.EDGE_RIGHT, borderWidth);
        }
    }
};
var applyGapStyles = function(node, style) {
    if ('gap' in style) {
        var _style_gap;
        node.setGap(Yoga$1.GUTTER_ALL, (_style_gap = style.gap) !== null && _style_gap !== void 0 ? _style_gap : 0);
    }
    if ('columnGap' in style) {
        var _style_columnGap;
        node.setGap(Yoga$1.GUTTER_COLUMN, (_style_columnGap = style.columnGap) !== null && _style_columnGap !== void 0 ? _style_columnGap : 0);
    }
    if ('rowGap' in style) {
        var _style_rowGap;
        node.setGap(Yoga$1.GUTTER_ROW, (_style_rowGap = style.rowGap) !== null && _style_rowGap !== void 0 ? _style_rowGap : 0);
    }
};
var styles = function(node) {
    var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    applyPositionStyles(node, style);
    applyMarginStyles(node, style);
    applyPaddingStyles(node, style);
    applyFlexStyles(node, style);
    applyDimensionStyles(node, style);
    applyDisplayStyles(node, style);
    applyBorderStyles(node, style);
    applyGapStyles(node, style);
};
// We need to conditionally perform devtools connection to avoid
// accidentally breaking other third-party code.
// See https://github.com/vadimdemedes/ink/issues/384
if (_process.default.env['DEV'] === 'true') ;
var diff = function(before, after) {
    if (before === after) {
        return;
    }
    if (!before) {
        return after;
    }
    var changed = {};
    var isChanged = false;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.keys(before)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var key = _step.value;
            var isDeleted = after ? !Object.hasOwn(after, key) : true;
            if (isDeleted) {
                changed[key] = undefined;
                isChanged = true;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (after) {
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = Object.keys(after)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var key1 = _step1.value;
                if (after[key1] !== before[key1]) {
                    changed[key1] = after[key1];
                    isChanged = true;
                }
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
    }
    return isChanged ? changed : undefined;
};
var cleanupYogaNode = function(node) {
    node === null || node === void 0 ? void 0 : node.unsetMeasureFunc();
    node === null || node === void 0 ? void 0 : node.freeRecursive();
};
var reconciler = createReconciler({
    getRootHostContext: function() {
        return {
            isInsideText: false
        };
    },
    prepareForCommit: function() {
        return null;
    },
    preparePortalMount: function() {
        return null;
    },
    clearContainer: function() {
        return false;
    },
    resetAfterCommit: function resetAfterCommit(rootNode) {
        if (typeof rootNode.onComputeLayout === 'function') {
            rootNode.onComputeLayout();
        }
        // Since renders are throttled at the instance level and <Static> component children
        // are rendered only once and then get deleted, we need an escape hatch to
        // trigger an immediate render to ensure <Static> children are written to output before they get erased
        if (rootNode.isStaticDirty) {
            rootNode.isStaticDirty = false;
            if (typeof rootNode.onImmediateRender === 'function') {
                rootNode.onImmediateRender();
            }
            return;
        }
        if (typeof rootNode.onRender === 'function') {
            rootNode.onRender();
        }
    },
    getChildHostContext: function getChildHostContext(parentHostContext, type) {
        var previousIsInsideText = parentHostContext.isInsideText;
        var isInsideText = type === 'ink-text' || type === 'ink-virtual-text';
        if (previousIsInsideText === isInsideText) {
            return parentHostContext;
        }
        return {
            isInsideText: isInsideText
        };
    },
    shouldSetTextContent: function() {
        return false;
    },
    createInstance: function createInstance(originalType, newProps, _root, hostContext) {
        if (hostContext.isInsideText && originalType === 'ink-box') {
            throw new Error("<Box> can’t be nested inside <Text> component");
        }
        var type = originalType === 'ink-text' && hostContext.isInsideText ? 'ink-virtual-text' : originalType;
        var node = createNode(type);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(newProps)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
                if (key === 'children') {
                    continue;
                }
                if (key === 'style') {
                    setStyle(node, value);
                    if (node.yogaNode) {
                        styles(node.yogaNode, value);
                    }
                    continue;
                }
                if (key === 'internal_transform') {
                    node.internal_transform = value;
                    continue;
                }
                if (key === 'internal_static') {
                    node.internal_static = true;
                    continue;
                }
                setAttribute(node, key, value);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return node;
    },
    createTextInstance: function createTextInstance(text, _root, hostContext) {
        if (!hostContext.isInsideText) {
            throw new Error('Text string "'.concat(text, '" must be rendered inside <Text> component'));
        }
        return createTextNode(text);
    },
    resetTextContent: function resetTextContent() {},
    hideTextInstance: function hideTextInstance(node) {
        setTextNodeValue(node, '');
    },
    unhideTextInstance: function unhideTextInstance(node, text) {
        setTextNodeValue(node, text);
    },
    getPublicInstance: function(instance) {
        return instance;
    },
    hideInstance: function hideInstance(node) {
        var _node_yogaNode;
        (_node_yogaNode = node.yogaNode) === null || _node_yogaNode === void 0 ? void 0 : _node_yogaNode.setDisplay(Yoga$1.DISPLAY_NONE);
    },
    unhideInstance: function unhideInstance(node) {
        var _node_yogaNode;
        (_node_yogaNode = node.yogaNode) === null || _node_yogaNode === void 0 ? void 0 : _node_yogaNode.setDisplay(Yoga$1.DISPLAY_FLEX);
    },
    appendInitialChild: appendChildNode,
    appendChild: appendChildNode,
    insertBefore: insertBeforeNode,
    finalizeInitialChildren: function finalizeInitialChildren(node, _type, _props, rootNode) {
        if (node.internal_static) {
            rootNode.isStaticDirty = true;
            // Save reference to <Static> node to skip traversal of entire
            // node tree to find it
            rootNode.staticNode = node;
        }
        return false;
    },
    isPrimaryRenderer: true,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    scheduleTimeout: setTimeout,
    cancelTimeout: clearTimeout,
    noTimeout: -1,
    getCurrentEventPriority: function() {
        return constantsExports.DefaultEventPriority;
    },
    beforeActiveInstanceBlur: function beforeActiveInstanceBlur() {},
    afterActiveInstanceBlur: function afterActiveInstanceBlur() {},
    detachDeletedInstance: function detachDeletedInstance() {},
    getInstanceFromNode: function() {
        return null;
    },
    prepareScopeUpdate: function prepareScopeUpdate() {},
    getInstanceFromScope: function() {
        return null;
    },
    appendChildToContainer: appendChildNode,
    insertInContainerBefore: insertBeforeNode,
    removeChildFromContainer: function removeChildFromContainer(node, removeNode) {
        removeChildNode(node, removeNode);
        cleanupYogaNode(removeNode.yogaNode);
    },
    prepareUpdate: function prepareUpdate(node, _type, oldProps, newProps, rootNode) {
        if (node.internal_static) {
            rootNode.isStaticDirty = true;
        }
        var props = diff(oldProps, newProps);
        var style = diff(oldProps['style'], newProps['style']);
        if (!props && !style) {
            return null;
        }
        return {
            props: props,
            style: style
        };
    },
    commitUpdate: function commitUpdate(node, param) {
        var props = param.props, style = param.style;
        if (props) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.entries(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
                    if (key === 'style') {
                        setStyle(node, value);
                        continue;
                    }
                    if (key === 'internal_transform') {
                        node.internal_transform = value;
                        continue;
                    }
                    if (key === 'internal_static') {
                        node.internal_static = true;
                        continue;
                    }
                    setAttribute(node, key, value);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
        if (style && node.yogaNode) {
            styles(node.yogaNode, style);
        }
    },
    commitTextUpdate: function commitTextUpdate(node, _oldText, newText) {
        setTextNodeValue(node, newText);
    },
    removeChild: function removeChild(node, removeNode) {
        removeChildNode(node, removeNode);
        cleanupYogaNode(removeNode.yogaNode);
    }
});
function indentString(string) {
    var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _options_indent = options.indent, indent = _options_indent === void 0 ? ' ' : _options_indent, _options_includeEmptyLines = options.includeEmptyLines, includeEmptyLines = _options_includeEmptyLines === void 0 ? false : _options_includeEmptyLines;
    if (typeof string !== 'string') {
        throw new TypeError("Expected `input` to be a `string`, got `".concat(typeof string === "undefined" ? "undefined" : _type_of(string), "`"));
    }
    if (typeof count !== 'number') {
        throw new TypeError("Expected `count` to be a `number`, got `".concat(typeof count === "undefined" ? "undefined" : _type_of(count), "`"));
    }
    if (count < 0) {
        throw new RangeError("Expected `count` to be at least 0, got `".concat(count, "`"));
    }
    if (typeof indent !== 'string') {
        throw new TypeError("Expected `options.indent` to be a `string`, got `".concat(typeof indent === "undefined" ? "undefined" : _type_of(indent), "`"));
    }
    if (count === 0) {
        return string;
    }
    var regex = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, indent.repeat(count));
}
var getMaxWidth = function(yogaNode) {
    return yogaNode.getComputedWidth() - yogaNode.getComputedPadding(Yoga$1.EDGE_LEFT) - yogaNode.getComputedPadding(Yoga$1.EDGE_RIGHT) - yogaNode.getComputedBorder(Yoga$1.EDGE_LEFT) - yogaNode.getComputedBorder(Yoga$1.EDGE_RIGHT);
};
var cliBoxes$1 = {
    exports: {}
};
var single = {
    topLeft: "┌",
    top: "─",
    topRight: "┐",
    right: "│",
    bottomRight: "┘",
    bottom: "─",
    bottomLeft: "└",
    left: "│"
};
var double = {
    topLeft: "╔",
    top: "═",
    topRight: "╗",
    right: "║",
    bottomRight: "╝",
    bottom: "═",
    bottomLeft: "╚",
    left: "║"
};
var round = {
    topLeft: "╭",
    top: "─",
    topRight: "╮",
    right: "│",
    bottomRight: "╯",
    bottom: "─",
    bottomLeft: "╰",
    left: "│"
};
var bold = {
    topLeft: "┏",
    top: "━",
    topRight: "┓",
    right: "┃",
    bottomRight: "┛",
    bottom: "━",
    bottomLeft: "┗",
    left: "┃"
};
var singleDouble = {
    topLeft: "╓",
    top: "─",
    topRight: "╖",
    right: "║",
    bottomRight: "╜",
    bottom: "─",
    bottomLeft: "╙",
    left: "║"
};
var doubleSingle = {
    topLeft: "╒",
    top: "═",
    topRight: "╕",
    right: "│",
    bottomRight: "╛",
    bottom: "═",
    bottomLeft: "╘",
    left: "│"
};
var classic = {
    topLeft: "+",
    top: "-",
    topRight: "+",
    right: "|",
    bottomRight: "+",
    bottom: "-",
    bottomLeft: "+",
    left: "|"
};
var arrow = {
    topLeft: "↘",
    top: "↓",
    topRight: "↙",
    right: "←",
    bottomRight: "↖",
    bottom: "↑",
    bottomLeft: "↗",
    left: "→"
};
var require$$0 = {
    single: single,
    double: double,
    round: round,
    bold: bold,
    singleDouble: singleDouble,
    doubleSingle: doubleSingle,
    classic: classic,
    arrow: arrow
};
var hasRequiredCliBoxes;
function requireCliBoxes() {
    if (hasRequiredCliBoxes) return cliBoxes$1.exports;
    hasRequiredCliBoxes = 1;
    var cliBoxes = require$$0;
    cliBoxes$1.exports = cliBoxes;
    // TODO: Remove this for the next major release
    cliBoxes$1.exports.default = cliBoxes;
    return cliBoxes$1.exports;
}
var cliBoxesExports = requireCliBoxes();
var cliBoxes = /*@__PURE__*/ getDefaultExportFromCjs(cliBoxesExports);
var ansiColors = {
    exports: {}
};
var symbols = {
    exports: {}
};
var hasRequiredSymbols;
function requireSymbols() {
    if (hasRequiredSymbols) return symbols.exports;
    hasRequiredSymbols = 1;
    (function(module) {
        var isHyper = typeof process !== 'undefined' && process.env.TERM_PROGRAM === 'Hyper';
        var isWindows = typeof process !== 'undefined' && process.platform === 'win32';
        var isLinux = typeof process !== 'undefined' && process.platform === 'linux';
        var common = {
            ballotDisabled: '☒',
            ballotOff: '☐',
            ballotOn: '☑',
            bullet: '•',
            bulletWhite: '◦',
            fullBlock: '█',
            heart: '❤',
            identicalTo: '≡',
            line: '─',
            mark: '※',
            middot: '·',
            minus: '－',
            multiplication: '×',
            obelus: '÷',
            pencilDownRight: '✎',
            pencilRight: '✏',
            pencilUpRight: '✐',
            percent: '%',
            pilcrow2: '❡',
            pilcrow: '¶',
            plusMinus: '±',
            question: '?',
            section: '§',
            starsOff: '☆',
            starsOn: '★',
            upDownArrow: '↕'
        };
        var windows = Object.assign({}, common, {
            check: '√',
            cross: '×',
            ellipsisLarge: '...',
            ellipsis: '...',
            info: 'i',
            questionSmall: '?',
            pointer: '>',
            pointerSmall: '»',
            radioOff: '( )',
            radioOn: '(*)',
            warning: '‼'
        });
        var other = Object.assign({}, common, {
            ballotCross: '✘',
            check: '✔',
            cross: '✖',
            ellipsisLarge: '⋯',
            ellipsis: '…',
            info: 'ℹ',
            questionFull: '？',
            questionSmall: '﹖',
            pointer: isLinux ? '▸' : '❯',
            pointerSmall: isLinux ? '‣' : '›',
            radioOff: '◯',
            radioOn: '◉',
            warning: '⚠'
        });
        module.exports = isWindows && !isHyper ? windows : other;
        Reflect.defineProperty(module.exports, 'common', {
            enumerable: false,
            value: common
        });
        Reflect.defineProperty(module.exports, 'windows', {
            enumerable: false,
            value: windows
        });
        Reflect.defineProperty(module.exports, 'other', {
            enumerable: false,
            value: other
        });
    })(symbols);
    return symbols.exports;
}
var hasRequiredAnsiColors;
function requireAnsiColors() {
    if (hasRequiredAnsiColors) return ansiColors.exports;
    hasRequiredAnsiColors = 1;
    var isObject = function(val) {
        return val !== null && (typeof val === "undefined" ? "undefined" : _type_of(val)) === 'object' && !Array.isArray(val);
    };
    /* eslint-disable no-control-regex */ // this is a modified version of https://github.com/chalk/ansi-regex (MIT License)
    var ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;
    var hasColor = function() {
        if (typeof process !== 'undefined') {
            return process.env.FORCE_COLOR !== '0';
        }
        return false;
    };
    var create = function() {
        var colors = {
            enabled: hasColor(),
            visible: true,
            styles: {},
            keys: {}
        };
        var ansi = function(style) {
            var open = style.open = "\x1b[".concat(style.codes[0], "m");
            var close = style.close = "\x1b[".concat(style.codes[1], "m");
            var regex = style.regex = new RegExp("\\u001b\\[".concat(style.codes[1], "m"), 'g');
            style.wrap = function(input, newline) {
                if (input.includes(close)) input = input.replace(regex, close + open);
                var output = open + input + close;
                // see https://github.com/chalk/chalk/pull/92, thanks to the
                // chalk contributors for this fix. However, we've confirmed that
                // this issue is also present in Windows terminals
                return newline ? output.replace(/\r*\n/g, "".concat(close, "$&").concat(open)) : output;
            };
            return style;
        };
        var wrap = function(style, input, newline) {
            return typeof style === 'function' ? style(input) : style.wrap(input, newline);
        };
        var style = function(input, stack) {
            if (input === '' || input == null) return '';
            if (colors.enabled === false) return input;
            if (colors.visible === false) return '';
            var str = '' + input;
            var nl = str.includes('\n');
            var n = stack.length;
            if (n > 0 && stack.includes('unstyle')) {
                stack = _to_consumable_array(new Set([
                    'unstyle'
                ].concat(_to_consumable_array(stack)))).reverse();
            }
            while(n-- > 0)str = wrap(colors.styles[stack[n]], str, nl);
            return str;
        };
        var define = function(name, codes, type) {
            colors.styles[name] = ansi({
                name: name,
                codes: codes
            });
            var keys = colors.keys[type] || (colors.keys[type] = []);
            keys.push(name);
            Reflect.defineProperty(colors, name, {
                configurable: true,
                enumerable: true,
                set: function set(value) {
                    colors.alias(name, value);
                },
                get: function get() {
                    var color = function(input) {
                        return style(input, color.stack);
                    };
                    Reflect.setPrototypeOf(color, colors);
                    color.stack = this.stack ? this.stack.concat(name) : [
                        name
                    ];
                    return color;
                }
            });
        };
        define('reset', [
            0,
            0
        ], 'modifier');
        define('bold', [
            1,
            22
        ], 'modifier');
        define('dim', [
            2,
            22
        ], 'modifier');
        define('italic', [
            3,
            23
        ], 'modifier');
        define('underline', [
            4,
            24
        ], 'modifier');
        define('inverse', [
            7,
            27
        ], 'modifier');
        define('hidden', [
            8,
            28
        ], 'modifier');
        define('strikethrough', [
            9,
            29
        ], 'modifier');
        define('black', [
            30,
            39
        ], 'color');
        define('red', [
            31,
            39
        ], 'color');
        define('green', [
            32,
            39
        ], 'color');
        define('yellow', [
            33,
            39
        ], 'color');
        define('blue', [
            34,
            39
        ], 'color');
        define('magenta', [
            35,
            39
        ], 'color');
        define('cyan', [
            36,
            39
        ], 'color');
        define('white', [
            37,
            39
        ], 'color');
        define('gray', [
            90,
            39
        ], 'color');
        define('grey', [
            90,
            39
        ], 'color');
        define('bgBlack', [
            40,
            49
        ], 'bg');
        define('bgRed', [
            41,
            49
        ], 'bg');
        define('bgGreen', [
            42,
            49
        ], 'bg');
        define('bgYellow', [
            43,
            49
        ], 'bg');
        define('bgBlue', [
            44,
            49
        ], 'bg');
        define('bgMagenta', [
            45,
            49
        ], 'bg');
        define('bgCyan', [
            46,
            49
        ], 'bg');
        define('bgWhite', [
            47,
            49
        ], 'bg');
        define('blackBright', [
            90,
            39
        ], 'bright');
        define('redBright', [
            91,
            39
        ], 'bright');
        define('greenBright', [
            92,
            39
        ], 'bright');
        define('yellowBright', [
            93,
            39
        ], 'bright');
        define('blueBright', [
            94,
            39
        ], 'bright');
        define('magentaBright', [
            95,
            39
        ], 'bright');
        define('cyanBright', [
            96,
            39
        ], 'bright');
        define('whiteBright', [
            97,
            39
        ], 'bright');
        define('bgBlackBright', [
            100,
            49
        ], 'bgBright');
        define('bgRedBright', [
            101,
            49
        ], 'bgBright');
        define('bgGreenBright', [
            102,
            49
        ], 'bgBright');
        define('bgYellowBright', [
            103,
            49
        ], 'bgBright');
        define('bgBlueBright', [
            104,
            49
        ], 'bgBright');
        define('bgMagentaBright', [
            105,
            49
        ], 'bgBright');
        define('bgCyanBright', [
            106,
            49
        ], 'bgBright');
        define('bgWhiteBright', [
            107,
            49
        ], 'bgBright');
        colors.ansiRegex = ANSI_REGEX;
        colors.hasColor = colors.hasAnsi = function(str) {
            colors.ansiRegex.lastIndex = 0;
            return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
        };
        colors.alias = function(name, color) {
            var fn = typeof color === 'string' ? colors[color] : color;
            if (typeof fn !== 'function') {
                throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
            }
            if (!fn.stack) {
                Reflect.defineProperty(fn, 'name', {
                    value: name
                });
                colors.styles[name] = fn;
                fn.stack = [
                    name
                ];
            }
            Reflect.defineProperty(colors, name, {
                configurable: true,
                enumerable: true,
                set: function set(value) {
                    colors.alias(name, value);
                },
                get: function get() {
                    var _$color = function(input) {
                        return style(input, _$color.stack);
                    };
                    Reflect.setPrototypeOf(_$color, colors);
                    _$color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
                    return _$color;
                }
            });
        };
        colors.theme = function(custom) {
            if (!isObject(custom)) throw new TypeError('Expected theme to be an object');
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = Object.keys(custom)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var name = _step.value;
                    colors.alias(name, custom[name]);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return colors;
        };
        colors.alias('unstyle', function(str) {
            if (typeof str === 'string' && str !== '') {
                colors.ansiRegex.lastIndex = 0;
                return str.replace(colors.ansiRegex, '');
            }
            return '';
        });
        colors.alias('noop', function(str) {
            return str;
        });
        colors.none = colors.clear = colors.noop;
        colors.stripColor = colors.unstyle;
        colors.symbols = requireSymbols();
        colors.define = define;
        return colors;
    };
    ansiColors.exports = create();
    ansiColors.exports.create = create;
    return ansiColors.exports;
}
var ansiColorsExports = requireAnsiColors();
var chalk = /*@__PURE__*/ getDefaultExportFromCjs(ansiColorsExports);
var rgbRegex = /^rgb\(\s?(\d+),\s?(\d+),\s?(\d+)\s?\)$/;
var ansiRegex = /^ansi256\(\s?(\d+)\s?\)$/;
var isNamedColor = function(color) {
    return color in chalk;
};
var colorize = function(str, color, type) {
    if (!color) {
        return str;
    }
    if (isNamedColor(color)) {
        if (type === 'foreground') {
            return chalk[color](str);
        }
        var methodName = "bg".concat(color[0].toUpperCase() + color.slice(1));
        return chalk[methodName](str);
    }
    if (color.startsWith('#')) {
        return type === 'foreground' ? chalk.hex(color)(str) : chalk.bgHex(color)(str);
    }
    if (color.startsWith('ansi256')) {
        var matches = ansiRegex.exec(color);
        if (!matches) {
            return str;
        }
        var value = Number(matches[1]);
        return type === 'foreground' ? chalk.ansi256(value)(str) : chalk.bgAnsi256(value)(str);
    }
    if (color.startsWith('rgb')) {
        var matches1 = rgbRegex.exec(color);
        if (!matches1) {
            return str;
        }
        var firstValue = Number(matches1[1]);
        var secondValue = Number(matches1[2]);
        var thirdValue = Number(matches1[3]);
        return type === 'foreground' ? chalk.rgb(firstValue, secondValue, thirdValue)(str) : chalk.bgRgb(firstValue, secondValue, thirdValue)(str);
    }
    return str;
};
var renderBorder = function(x, y, node, output) {
    if (node.style.borderStyle) {
        var width = node.yogaNode.getComputedWidth();
        var height = node.yogaNode.getComputedHeight();
        var box = typeof node.style.borderStyle === 'string' ? cliBoxes[node.style.borderStyle] : node.style.borderStyle;
        var _node_style_borderTopColor;
        var topBorderColor = (_node_style_borderTopColor = node.style.borderTopColor) !== null && _node_style_borderTopColor !== void 0 ? _node_style_borderTopColor : node.style.borderColor;
        var _node_style_borderBottomColor;
        var bottomBorderColor = (_node_style_borderBottomColor = node.style.borderBottomColor) !== null && _node_style_borderBottomColor !== void 0 ? _node_style_borderBottomColor : node.style.borderColor;
        var _node_style_borderLeftColor;
        var leftBorderColor = (_node_style_borderLeftColor = node.style.borderLeftColor) !== null && _node_style_borderLeftColor !== void 0 ? _node_style_borderLeftColor : node.style.borderColor;
        var _node_style_borderRightColor;
        var rightBorderColor = (_node_style_borderRightColor = node.style.borderRightColor) !== null && _node_style_borderRightColor !== void 0 ? _node_style_borderRightColor : node.style.borderColor;
        var _node_style_borderTopDimColor;
        var dimTopBorderColor = (_node_style_borderTopDimColor = node.style.borderTopDimColor) !== null && _node_style_borderTopDimColor !== void 0 ? _node_style_borderTopDimColor : node.style.borderDimColor;
        var _node_style_borderBottomDimColor;
        var dimBottomBorderColor = (_node_style_borderBottomDimColor = node.style.borderBottomDimColor) !== null && _node_style_borderBottomDimColor !== void 0 ? _node_style_borderBottomDimColor : node.style.borderDimColor;
        var _node_style_borderLeftDimColor;
        var dimLeftBorderColor = (_node_style_borderLeftDimColor = node.style.borderLeftDimColor) !== null && _node_style_borderLeftDimColor !== void 0 ? _node_style_borderLeftDimColor : node.style.borderDimColor;
        var _node_style_borderRightDimColor;
        var dimRightBorderColor = (_node_style_borderRightDimColor = node.style.borderRightDimColor) !== null && _node_style_borderRightDimColor !== void 0 ? _node_style_borderRightDimColor : node.style.borderDimColor;
        var showTopBorder = node.style.borderTop !== false;
        var showBottomBorder = node.style.borderBottom !== false;
        var showLeftBorder = node.style.borderLeft !== false;
        var showRightBorder = node.style.borderRight !== false;
        var contentWidth = width - (showLeftBorder ? 1 : 0) - (showRightBorder ? 1 : 0);
        var topBorder = showTopBorder ? colorize((showLeftBorder ? box.topLeft : '') + box.top.repeat(contentWidth) + (showRightBorder ? box.topRight : ''), topBorderColor, 'foreground') : undefined;
        if (showTopBorder && dimTopBorderColor) {
            topBorder = chalk.dim(topBorder);
        }
        var verticalBorderHeight = height;
        if (showTopBorder) {
            verticalBorderHeight -= 1;
        }
        if (showBottomBorder) {
            verticalBorderHeight -= 1;
        }
        var leftBorder = (colorize(box.left, leftBorderColor, 'foreground') + '\n').repeat(verticalBorderHeight);
        if (dimLeftBorderColor) {
            leftBorder = chalk.dim(leftBorder);
        }
        var rightBorder = (colorize(box.right, rightBorderColor, 'foreground') + '\n').repeat(verticalBorderHeight);
        if (dimRightBorderColor) {
            rightBorder = chalk.dim(rightBorder);
        }
        var bottomBorder = showBottomBorder ? colorize((showLeftBorder ? box.bottomLeft : '') + box.bottom.repeat(contentWidth) + (showRightBorder ? box.bottomRight : ''), bottomBorderColor, 'foreground') : undefined;
        if (showBottomBorder && dimBottomBorderColor) {
            bottomBorder = chalk.dim(bottomBorder);
        }
        var offsetY = showTopBorder ? 1 : 0;
        if (topBorder) {
            output.write(x, y, topBorder, {
                transformers: []
            });
        }
        if (showLeftBorder) {
            output.write(x, y + offsetY, leftBorder, {
                transformers: []
            });
        }
        if (showRightBorder) {
            output.write(x + width - 1, y + offsetY, rightBorder, {
                transformers: []
            });
        }
        if (bottomBorder) {
            output.write(x, y + height - 1, bottomBorder, {
                transformers: []
            });
        }
    }
};
// If parent container is `<Box>`, text nodes will be treated as separate nodes in
// the tree and will have their own coordinates in the layout.
// To ensure text nodes are aligned correctly, take X and Y of the first text node
// and use it as offset for the rest of the nodes
// Only first node is taken into account, because other text nodes can't have margin or padding,
// so their coordinates will be relative to the first node anyway
var applyPaddingToText = function(node, text) {
    var _node_childNodes_;
    var yogaNode = (_node_childNodes_ = node.childNodes[0]) === null || _node_childNodes_ === void 0 ? void 0 : _node_childNodes_.yogaNode;
    if (yogaNode) {
        var offsetX = yogaNode.getComputedLeft();
        var offsetY = yogaNode.getComputedTop();
        text = '\n'.repeat(offsetY) + indentString(text, offsetX);
    }
    return text;
};
// After nodes are laid out, render each to output object, which later gets rendered to terminal
var renderNodeToOutput = function(node, output, options) {
    var _options_offsetX = options.offsetX, offsetX = _options_offsetX === void 0 ? 0 : _options_offsetX, _options_offsetY = options.offsetY, offsetY = _options_offsetY === void 0 ? 0 : _options_offsetY, _options_transformers = options.transformers, transformers = _options_transformers === void 0 ? [] : _options_transformers, skipStaticElements = options.skipStaticElements;
    if (skipStaticElements && node.internal_static) {
        return;
    }
    var yogaNode = node.yogaNode;
    if (yogaNode) {
        if (yogaNode.getDisplay() === Yoga$1.DISPLAY_NONE) {
            return;
        }
        // Left and top positions in Yoga are relative to their parent node
        var x = offsetX + yogaNode.getComputedLeft();
        var y = offsetY + yogaNode.getComputedTop();
        // Transformers are functions that transform final text output of each component
        // See Output class for logic that applies transformers
        var newTransformers = transformers;
        if (typeof node.internal_transform === 'function') {
            newTransformers = [
                node.internal_transform
            ].concat(_to_consumable_array(transformers));
        }
        if (node.nodeName === 'ink-text') {
            var text = squashTextNodes(node);
            if (text.length > 0) {
                var currentWidth = widestLine(text);
                var maxWidth = getMaxWidth(yogaNode);
                if (currentWidth > maxWidth) {
                    var _node_style_textWrap;
                    var textWrap = (_node_style_textWrap = node.style.textWrap) !== null && _node_style_textWrap !== void 0 ? _node_style_textWrap : 'wrap';
                    text = wrapText(text, maxWidth, textWrap);
                }
                text = applyPaddingToText(node, text);
                output.write(x, y, text, {
                    transformers: newTransformers
                });
            }
            return;
        }
        var clipped = false;
        if (node.nodeName === 'ink-box') {
            renderBorder(x, y, node, output);
            var clipHorizontally = node.style.overflowX === 'hidden' || node.style.overflow === 'hidden';
            var clipVertically = node.style.overflowY === 'hidden' || node.style.overflow === 'hidden';
            if (clipHorizontally || clipVertically) {
                var x1 = clipHorizontally ? x + yogaNode.getComputedBorder(Yoga$1.EDGE_LEFT) : undefined;
                var x2 = clipHorizontally ? x + yogaNode.getComputedWidth() - yogaNode.getComputedBorder(Yoga$1.EDGE_RIGHT) : undefined;
                var y1 = clipVertically ? y + yogaNode.getComputedBorder(Yoga$1.EDGE_TOP) : undefined;
                var y2 = clipVertically ? y + yogaNode.getComputedHeight() - yogaNode.getComputedBorder(Yoga$1.EDGE_BOTTOM) : undefined;
                output.clip({
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                });
                clipped = true;
            }
        }
        if (node.nodeName === 'ink-root' || node.nodeName === 'ink-box') {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = node.childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var childNode = _step.value;
                    renderNodeToOutput(childNode, output, {
                        offsetX: x,
                        offsetY: y,
                        transformers: newTransformers,
                        skipStaticElements: skipStaticElements
                    });
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            if (clipped) {
                output.unclip();
            }
        }
    }
};
function isFullwidthCodePoint(codePoint) {
    if (!Number.isInteger(codePoint)) {
        return false;
    }
    return eastAsianWidth(codePoint) === 2;
}
// \x1b and \x9b
var ESCAPES$1 = new Set([
    27,
    155
]);
var CODE_POINT_0 = '0'.codePointAt(0);
var CODE_POINT_9 = '9'.codePointAt(0);
var endCodesSet$1 = new Set();
var endCodesMap$1 = new Map();
var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
try {
    for(var _iterator = ansiStyles.codes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
        var _step_value = _sliced_to_array(_step.value, 2), start = _step_value[0], end = _step_value[1];
        endCodesSet$1.add(ansiStyles.color.ansi(end));
        endCodesMap$1.set(ansiStyles.color.ansi(start), ansiStyles.color.ansi(end));
    }
} catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
} finally{
    try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
        }
    } finally{
        if (_didIteratorError) {
            throw _iteratorError;
        }
    }
}
function getEndCode$1(code) {
    if (endCodesSet$1.has(code)) {
        return code;
    }
    if (endCodesMap$1.has(code)) {
        return endCodesMap$1.get(code);
    }
    code = code.slice(2);
    if (code.includes(';')) {
        code = code[0] + '0';
    }
    var returnValue = ansiStyles.codes.get(Number.parseInt(code, 10));
    if (returnValue) {
        return ansiStyles.color.ansi(returnValue);
    }
    return ansiStyles.reset.open;
}
function findNumberIndex$1(string) {
    for(var index = 0; index < string.length; index++){
        var codePoint = string.codePointAt(index);
        if (codePoint >= CODE_POINT_0 && codePoint <= CODE_POINT_9) {
            return index;
        }
    }
    return -1;
}
function parseAnsiCode$1(string, offset) {
    string = string.slice(offset, offset + 19);
    var startIndex = findNumberIndex$1(string);
    if (startIndex !== -1) {
        var endIndex = string.indexOf('m', startIndex);
        if (endIndex === -1) {
            endIndex = string.length;
        }
        return string.slice(0, endIndex + 1);
    }
}
function tokenize$1(string) {
    var endCharacter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.POSITIVE_INFINITY;
    var returnValue = [];
    var index = 0;
    var visibleCount = 0;
    while(index < string.length){
        var codePoint = string.codePointAt(index);
        if (ESCAPES$1.has(codePoint)) {
            var code = parseAnsiCode$1(string, index);
            if (code) {
                returnValue.push({
                    type: 'ansi',
                    code: code,
                    endCode: getEndCode$1(code)
                });
                index += code.length;
                continue;
            }
        }
        var isFullWidth = isFullwidthCodePoint(codePoint);
        var character = String.fromCodePoint(codePoint);
        returnValue.push({
            type: 'character',
            value: character,
            isFullWidth: isFullWidth
        });
        index += character.length;
        visibleCount += isFullWidth ? 2 : character.length;
        if (visibleCount >= endCharacter) {
            break;
        }
    }
    return returnValue;
}
function reduceAnsiCodes$1(codes) {
    var returnValue = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function() {
            var code = _step.value;
            if (code.code === ansiStyles.reset.open) {
                // Reset code, disable all codes
                returnValue = [];
            } else if (endCodesSet$1.has(code.code)) {
                // This is an end code, disable all matching start codes
                returnValue = returnValue.filter(function(returnValueCode) {
                    return returnValueCode.endCode !== code.code;
                });
            } else {
                // This is a start code. Disable all styles this "overrides", then enable it
                returnValue = returnValue.filter(function(returnValueCode) {
                    return returnValueCode.endCode !== code.endCode;
                });
                returnValue.push(code);
            }
        };
        for(var _iterator = codes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return returnValue;
}
function undoAnsiCodes$1(codes) {
    var reduced = reduceAnsiCodes$1(codes);
    var endCodes = reduced.map(function(param) {
        var endCode = param.endCode;
        return endCode;
    });
    return endCodes.reverse().join('');
}
function sliceAnsi(string, start, end) {
    var tokens = tokenize$1(string, end);
    var activeCodes = [];
    var position = 0;
    var returnValue = '';
    var include = false;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var token = _step.value;
            if (end !== undefined && position >= end) {
                break;
            }
            if (token.type === 'ansi') {
                activeCodes.push(token);
                if (include) {
                    returnValue += token.code;
                }
            } else {
                // Character
                if (!include && position >= start) {
                    include = true;
                    // Simplify active codes
                    activeCodes = reduceAnsiCodes$1(activeCodes);
                    returnValue = activeCodes.map(function(param) {
                        var code = param.code;
                        return code;
                    }).join('');
                }
                if (include) {
                    returnValue += token.value;
                }
                position += token.isFullWidth ? 2 : token.value.length;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    // Disable active codes at the end
    returnValue += undoAnsiCodes$1(activeCodes);
    return returnValue;
}
var ESCAPES = new Set([
    27,
    155
]); // \x1b and \x9b
var endCodesSet = new Set();
var endCodesMap = new Map();
var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
try {
    for(var _iterator1 = ansiStyles.codes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
        var _step_value1 = _sliced_to_array(_step1.value, 2), start1 = _step_value1[0], end1 = _step_value1[1];
        endCodesSet.add(ansiStyles.color.ansi(end1));
        endCodesMap.set(ansiStyles.color.ansi(start1), ansiStyles.color.ansi(end1));
    }
} catch (err) {
    _didIteratorError1 = true;
    _iteratorError1 = err;
} finally{
    try {
        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
        }
    } finally{
        if (_didIteratorError1) {
            throw _iteratorError1;
        }
    }
}
var linkStartCodePrefix = "\x1B]8;;";
var linkStartCodePrefixCharCodes = linkStartCodePrefix.split("").map(function(char) {
    return char.charCodeAt(0);
});
var linkCodeSuffix = "\x07";
var linkEndCode = "\x1b]8;;".concat(linkCodeSuffix);
function getEndCode(code) {
    if (endCodesSet.has(code)) return code;
    if (endCodesMap.has(code)) return endCodesMap.get(code);
    if (code.startsWith(linkStartCodePrefix)) return linkEndCode;
    code = code.slice(2);
    if (code.includes(";")) {
        code = code[0] + "0";
    }
    var ret = ansiStyles.codes.get(parseInt(code, 10));
    if (ret) {
        return ansiStyles.color.ansi(ret);
    } else {
        return ansiStyles.reset.open;
    }
}
function ansiCodesToString(codes) {
    return codes.map(function(code) {
        return code.code;
    }).join("");
}
/** Reduces the given array of ANSI codes to the minimum necessary to render with the same style */ function reduceAnsiCodes(codes) {
    return reduceAnsiCodesIncremental([], codes);
}
/** Like {@link reduceAnsiCodes}, but assumes that `codes` is already reduced. Further reductions are only done for the items in `newCodes`. */ function reduceAnsiCodesIncremental(codes, newCodes) {
    var ret = _to_consumable_array(codes);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function() {
            var code = _step.value;
            if (code.code === ansiStyles.reset.open) {
                // Reset code, disable all codes
                ret = [];
            } else if (endCodesSet.has(code.code)) {
                // This is an end code, disable all matching start codes
                ret = ret.filter(function(retCode) {
                    return retCode.endCode !== code.code;
                });
            } else {
                // This is a start code. Disable all styles this "overrides", then enable it
                ret = ret.filter(function(retCode) {
                    return retCode.endCode !== code.endCode;
                });
                ret.push(code);
            }
        };
        for(var _iterator = newCodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return ret;
}
/** Returns the combination of ANSI codes needed to undo the given ANSI codes */ function undoAnsiCodes(codes) {
    return reduceAnsiCodes(codes).reverse().map(function(code) {
        return _object_spread_props(_object_spread({}, code), {
            code: code.endCode
        });
    });
}
/**
 * Returns the minimum amount of ANSI codes necessary to get from the compound style `from` to `to`.
 * Both `from` and `to` are expected to be reduced.
 */ function diffAnsiCodes(from, to) {
    var endCodesInTo = new Set(to.map(function(code) {
        return code.endCode;
    }));
    var startCodesInFrom = new Set(from.map(function(code) {
        return code.code;
    }));
    return(// Ignore all styles in `from` that are not overwritten or removed by `to`
    // Disable all styles in `from` that are removed in `to`
    _to_consumable_array(undoAnsiCodes(from.filter(function(code) {
        return !endCodesInTo.has(code.endCode);
    }))).concat(// Add all styles in `to` that don't exist in `from`
    _to_consumable_array(to.filter(function(code) {
        return !startCodesInFrom.has(code.code);
    }))));
}
function styledCharsFromTokens(tokens) {
    var codes = [];
    var ret = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var token = _step.value;
            if (token.type === "ansi") {
                codes = reduceAnsiCodesIncremental(codes, [
                    token
                ]);
            } else if (token.type === "char") {
                ret.push(_object_spread_props(_object_spread({}, token), {
                    styles: _to_consumable_array(codes)
                }));
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return ret;
}
function styledCharsToString(chars) {
    var ret = "";
    for(var i = 0; i < chars.length; i++){
        var char = chars[i];
        if (i === 0) {
            ret += ansiCodesToString(char.styles);
        } else {
            ret += ansiCodesToString(diffAnsiCodes(chars[i - 1].styles, char.styles));
        }
        ret += char.value;
        // reset active styles at the end of the string
        if (i === chars.length - 1) {
            ret += ansiCodesToString(diffAnsiCodes(char.styles, []));
        }
    }
    return ret;
}
function findNumberIndex(str) {
    for(var index = 0; index < str.length; index++){
        var charCode = str.charCodeAt(index);
        if (charCode >= 48 && charCode <= 57) {
            return index;
        }
    }
    return -1;
}
function parseLinkCode(string, offset) {
    string = string.slice(offset);
    for(var index = 1; index < linkStartCodePrefixCharCodes.length; index++){
        if (string.charCodeAt(index) !== linkStartCodePrefixCharCodes[index]) {
            return undefined;
        }
    }
    // This is a link code (with or without the URL part). Find the end of it.
    var endIndex = string.indexOf("\x07", linkStartCodePrefix.length);
    if (endIndex === -1) return undefined;
    return string.slice(0, endIndex + 1);
}
function parseAnsiCode(string, offset) {
    string = string.slice(offset, offset + 19);
    var startIndex = findNumberIndex(string);
    if (startIndex !== -1) {
        var endIndex = string.indexOf("m", startIndex);
        if (endIndex === -1) {
            endIndex = string.length;
        }
        return string.slice(0, endIndex + 1);
    }
}
function tokenize(str) {
    var endChar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.POSITIVE_INFINITY;
    var ret = [];
    var index = 0;
    var visible = 0;
    while(index < str.length){
        var codePoint = str.codePointAt(index);
        if (ESCAPES.has(codePoint)) {
            // TODO: We should probably decide on the next character ("[" or "]") which code path to take.
            var code = parseLinkCode(str, index) || parseAnsiCode(str, index);
            if (code) {
                ret.push({
                    type: "ansi",
                    code: code,
                    endCode: getEndCode(code)
                });
                index += code.length;
                continue;
            }
        }
        var fullWidth = isFullwidthCodePoint$1(codePoint);
        var character = String.fromCodePoint(codePoint);
        ret.push({
            type: "char",
            value: character,
            fullWidth: fullWidth
        });
        index += character.length;
        visible += fullWidth ? 2 : character.length;
        if (visible >= endChar) {
            break;
        }
    }
    return ret;
}
var Output = /*#__PURE__*/ function() {
    "use strict";
    function Output(options) {
        _class_call_check(this, Output);
        this.operations = [];
        var width = options.width, height = options.height;
        this.width = width;
        this.height = height;
    }
    var _proto = Output.prototype;
    _proto.write = function write(x, y, text, options) {
        var transformers = options.transformers;
        if (!text) {
            return;
        }
        this.operations.push({
            type: 'write',
            x: x,
            y: y,
            text: text,
            transformers: transformers
        });
    };
    _proto.clip = function clip(clip) {
        this.operations.push({
            type: 'clip',
            clip: clip
        });
    };
    _proto.unclip = function unclip() {
        this.operations.push({
            type: 'unclip'
        });
    };
    _proto.get = function get() {
        // Initialize output array with a specific set of rows, so that margin/padding at the bottom is preserved
        var output = [];
        for(var y = 0; y < this.height; y++){
            var row = [];
            for(var x = 0; x < this.width; x++){
                row.push({
                    type: 'char',
                    value: ' ',
                    fullWidth: false,
                    styles: []
                });
            }
            output.push(row);
        }
        var clips = [];
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function() {
                var operation = _step.value;
                if (operation.type === 'clip') {
                    clips.push(operation.clip);
                }
                if (operation.type === 'unclip') {
                    clips.pop();
                }
                if (operation.type === 'write') {
                    var text = operation.text, transformers = operation.transformers;
                    var x = operation.x, y = operation.y;
                    var lines = text.split('\n');
                    var clip = clips.at(-1);
                    if (clip) {
                        var clipHorizontally = typeof (clip === null || clip === void 0 ? void 0 : clip.x1) === 'number' && typeof (clip === null || clip === void 0 ? void 0 : clip.x2) === 'number';
                        var clipVertically = typeof (clip === null || clip === void 0 ? void 0 : clip.y1) === 'number' && typeof (clip === null || clip === void 0 ? void 0 : clip.y2) === 'number';
                        // If text is positioned outside of clipping area altogether,
                        // skip to the next operation to avoid unnecessary calculations
                        if (clipHorizontally) {
                            var width = widestLine(text);
                            if (x + width < clip.x1 || x > clip.x2) {
                                return "continue";
                            }
                        }
                        if (clipVertically) {
                            var height = lines.length;
                            if (y + height < clip.y1 || y > clip.y2) {
                                return "continue";
                            }
                        }
                        if (clipHorizontally) {
                            lines = lines.map(function(line) {
                                var from = x < clip.x1 ? clip.x1 - x : 0;
                                var width = stringWidth(line);
                                var to = x + width > clip.x2 ? clip.x2 - x : width;
                                return sliceAnsi(line, from, to);
                            });
                            if (x < clip.x1) {
                                x = clip.x1;
                            }
                        }
                        if (clipVertically) {
                            var from = y < clip.y1 ? clip.y1 - y : 0;
                            var height1 = lines.length;
                            var to = y + height1 > clip.y2 ? clip.y2 - y : height1;
                            lines = lines.slice(from, to);
                            if (y < clip.y1) {
                                y = clip.y1;
                            }
                        }
                    }
                    var offsetY = 0;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = lines.entries()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _step_value = _sliced_to_array(_step1.value, 2), index = _step_value[0], line = _step_value[1];
                            var currentLine = output[y + offsetY];
                            // Line can be missing if `text` is taller than height of pre-initialized `this.output`
                            if (!currentLine) {
                                continue;
                            }
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = transformers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion1 = (_step2 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var transformer = _step2.value;
                                    line = transformer(line, index);
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                            var characters = styledCharsFromTokens(tokenize(line));
                            var offsetX = x;
                            var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                            try {
                                for(var _iterator2 = characters[Symbol.iterator](), _step3; !(_iteratorNormalCompletion2 = (_step3 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                    var character = _step3.value;
                                    currentLine[offsetX] = character;
                                    // Some characters take up more than one column. In that case, the following
                                    // pixels need to be cleared to avoid printing extra characters
                                    var isWideCharacter = character.fullWidth || character.value.length > 1;
                                    if (isWideCharacter) {
                                        currentLine[offsetX + 1] = {
                                            type: 'char',
                                            value: '',
                                            fullWidth: false,
                                            styles: character.styles
                                        };
                                    }
                                    offsetX += isWideCharacter ? 2 : 1;
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                        _iterator2.return();
                                    }
                                } finally{
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                            offsetY++;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            };
            for(var _iterator = this.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var generatedOutput = output.map(function(line) {
            // See https://github.com/vadimdemedes/ink/pull/564#issuecomment-1637022742
            var lineWithoutEmptyItems = line.filter(function(item) {
                return item !== undefined;
            });
            return styledCharsToString(lineWithoutEmptyItems).trimEnd();
        }).join('\n');
        return {
            output: generatedOutput,
            height: output.length
        };
    };
    return Output;
}();
var renderer = function(node) {
    if (node.yogaNode) {
        var _node_staticNode;
        var output = new Output({
            width: node.yogaNode.getComputedWidth(),
            height: node.yogaNode.getComputedHeight()
        });
        renderNodeToOutput(node, output, {
            skipStaticElements: true
        });
        var staticOutput;
        if ((_node_staticNode = node.staticNode) === null || _node_staticNode === void 0 ? void 0 : _node_staticNode.yogaNode) {
            staticOutput = new Output({
                width: node.staticNode.yogaNode.getComputedWidth(),
                height: node.staticNode.yogaNode.getComputedHeight()
            });
            renderNodeToOutput(node.staticNode, staticOutput, {
                skipStaticElements: false
            });
        }
        var _output_get = output.get(), generatedOutput = _output_get.output, outputHeight = _output_get.height;
        return {
            output: generatedOutput,
            outputHeight: outputHeight,
            // Newline at the end is needed, because static output doesn't have one, so
            // interactive output will override last line of static output
            staticOutput: staticOutput ? "".concat(staticOutput.get().output, "\n") : ''
        };
    }
    return {
        output: '',
        outputHeight: 0,
        staticOutput: ''
    };
};
var onetime$1 = {
    exports: {}
};
var mimicFn = {
    exports: {}
};
var hasRequiredMimicFn;
function requireMimicFn() {
    if (hasRequiredMimicFn) return mimicFn.exports;
    hasRequiredMimicFn = 1;
    var mimicFn$1 = function(to, from) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Reflect.ownKeys(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var prop = _step.value;
                Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return to;
    };
    mimicFn.exports = mimicFn$1;
    // TODO: Remove this for the next major release
    mimicFn.exports.default = mimicFn$1;
    return mimicFn.exports;
}
var hasRequiredOnetime;
function requireOnetime() {
    if (hasRequiredOnetime) return onetime$1.exports;
    hasRequiredOnetime = 1;
    var mimicFn = requireMimicFn();
    var calledFunctions = new WeakMap();
    var onetime = function(function_) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (typeof function_ !== 'function') {
            throw new TypeError('Expected a function');
        }
        var returnValue;
        var callCount = 0;
        var functionName = function_.displayName || function_.name || '<anonymous>';
        var onetime = function onetime1() {
            for(var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++){
                arguments_[_key] = arguments[_key];
            }
            calledFunctions.set(onetime, ++callCount);
            if (callCount === 1) {
                returnValue = function_.apply(this, arguments_);
                function_ = null;
            } else if (options.throw === true) {
                throw new Error("Function `".concat(functionName, "` can only be called once"));
            }
            return returnValue;
        };
        mimicFn(onetime, function_);
        calledFunctions.set(onetime, callCount);
        return onetime;
    };
    onetime$1.exports = onetime;
    // TODO: Remove this for the next major release
    onetime$1.exports.default = onetime;
    onetime$1.exports.callCount = function(function_) {
        if (!calledFunctions.has(function_)) {
            throw new Error("The given function `".concat(function_.name, "` is not wrapped by the `onetime` package"));
        }
        return calledFunctions.get(function_);
    };
    return onetime$1.exports;
}
var onetimeExports = requireOnetime();
var onetime = /*@__PURE__*/ getDefaultExportFromCjs(onetimeExports);
var restoreCursor = onetime(function() {
    signalExit(function() {
        _process.default.stderr.write('\u001B[?25h');
    }, {
        alwaysLast: true
    });
});
var isHidden = false;
var cliCursor = {};
cliCursor.show = function() {
    var writableStream = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _process.default.stderr;
    if (!writableStream.isTTY) {
        return;
    }
    isHidden = false;
    writableStream.write('\u001B[?25h');
};
cliCursor.hide = function() {
    var writableStream = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _process.default.stderr;
    if (!writableStream.isTTY) {
        return;
    }
    restoreCursor();
    isHidden = true;
    writableStream.write('\u001B[?25l');
};
cliCursor.toggle = function(force, writableStream) {
    if (force !== undefined) {
        isHidden = force;
    }
    if (isHidden) {
        cliCursor.show(writableStream);
    } else {
        cliCursor.hide(writableStream);
    }
};
var create = function(stream) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_showCursor = _ref.showCursor, showCursor = _ref_showCursor === void 0 ? false : _ref_showCursor;
    var previousLineCount = 0;
    var previousOutput = '';
    var hasHiddenCursor = false;
    var render = function(str) {
        if (!showCursor && !hasHiddenCursor) {
            cliCursor.hide();
            hasHiddenCursor = true;
        }
        var output = str + '\n';
        if (output === previousOutput) {
            return;
        }
        previousOutput = output;
        stream.write(eraseLines(previousLineCount) + output);
        previousLineCount = output.split('\n').length;
    };
    render.clear = function() {
        stream.write(eraseLines(previousLineCount));
        previousOutput = '';
        previousLineCount = 0;
    };
    render.done = function() {
        previousOutput = '';
        previousLineCount = 0;
        if (!showCursor) {
            cliCursor.show();
            hasHiddenCursor = false;
        }
    };
    return render;
};
var logUpdate = {
    create: create
};
// Store all instances of Ink (instance.js) to ensure that consecutive render() calls
// use the same instance of Ink and don't create a new one
//
// This map has to be stored in a separate file, because render.js creates instances,
// but instance.js should delete itself from the map on unmount
var instances = new WeakMap();
/**
 * `AppContext` is a React context, which exposes a method to manually exit the app (unmount).
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
var AppContext = (0, _react.createContext)({
    exit: function exit() {}
});
AppContext.displayName = 'InternalAppContext';
/**
 * `StdinContext` is a React context, which exposes input stream.
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
var StdinContext = (0, _react.createContext)({
    stdin: _process.default.stdin,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    internal_eventEmitter: new _events.EventEmitter(),
    setRawMode: function setRawMode() {},
    isRawModeSupported: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    internal_exitOnCtrlC: true
});
StdinContext.displayName = 'InternalStdinContext';
/**
 * `StdoutContext` is a React context, which exposes stdout stream, where Ink renders your app.
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
var StdoutContext = (0, _react.createContext)({
    stdout: _process.default.stdout,
    write: function write() {}
});
StdoutContext.displayName = 'InternalStdoutContext';
/**
 * `StderrContext` is a React context, which exposes stderr stream.
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
var StderrContext = (0, _react.createContext)({
    stderr: _process.default.stderr,
    write: function write() {}
});
StderrContext.displayName = 'InternalStderrContext';
// eslint-disable-next-line @typescript-eslint/naming-convention
var FocusContext = (0, _react.createContext)({
    activeId: undefined,
    add: function add() {},
    remove: function remove() {},
    activate: function activate() {},
    deactivate: function deactivate() {},
    enableFocus: function enableFocus() {},
    disableFocus: function disableFocus() {},
    focusNext: function focusNext() {},
    focusPrevious: function focusPrevious() {},
    focus: function focus() {}
});
FocusContext.displayName = 'InternalFocusContext';
var escapeStringRegexp;
var hasRequiredEscapeStringRegexp;
function requireEscapeStringRegexp() {
    if (hasRequiredEscapeStringRegexp) return escapeStringRegexp;
    hasRequiredEscapeStringRegexp = 1;
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    escapeStringRegexp = function(string) {
        if (typeof string !== 'string') {
            throw new TypeError('Expected a string');
        }
        return string.replace(matchOperatorsRegex, '\\$&');
    };
    return escapeStringRegexp;
}
var stackUtils$1;
var hasRequiredStackUtils;
function requireStackUtils() {
    if (hasRequiredStackUtils) return stackUtils$1;
    hasRequiredStackUtils = 1;
    var escapeStringRegexp = requireEscapeStringRegexp();
    var _$cwd = (typeof process === "undefined" ? "undefined" : _type_of(process)) === 'object' && process && typeof process.cwd === 'function' ? process.cwd() : '.';
    var natives = [].concat(_module.default.builtinModules, 'bootstrap_node', 'node').map(function(n) {
        return new RegExp("(?:\\((?:node:)?".concat(n, "(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?").concat(n, "(?:\\.js)?:\\d+:\\d+$)"));
    });
    natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
    var StackUtils = /*#__PURE__*/ function() {
        "use strict";
        function StackUtils(opts) {
            _class_call_check(this, StackUtils);
            opts = _object_spread({
                ignoredPackages: []
            }, opts);
            if ('internals' in opts === false) {
                opts.internals = StackUtils.nodeInternals();
            }
            if ('cwd' in opts === false) {
                opts.cwd = _$cwd;
            }
            this._cwd = opts.cwd.replace(/\\/g, '/');
            this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
            this._wrapCallSite = opts.wrapCallSite || false;
        }
        var _proto = StackUtils.prototype;
        _proto.clean = function clean(stack) {
            var _this = this;
            var indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            indent = ' '.repeat(indent);
            if (!Array.isArray(stack)) {
                stack = stack.split('\n');
            }
            if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
                stack = stack.slice(1);
            }
            var outdent = false;
            var lastNonAtLine = null;
            var result = [];
            stack.forEach(function(st) {
                st = st.replace(/\\/g, '/');
                if (_this._internals.some(function(internal) {
                    return internal.test(st);
                })) {
                    return;
                }
                var isAtLine = /^\s*at /.test(st);
                if (outdent) {
                    st = st.trimEnd().replace(/^(\s+)at /, '$1');
                } else {
                    st = st.trim();
                    if (isAtLine) {
                        st = st.slice(3);
                    }
                }
                st = st.replace("".concat(_this._cwd, "/"), '');
                if (st) {
                    if (isAtLine) {
                        if (lastNonAtLine) {
                            result.push(lastNonAtLine);
                            lastNonAtLine = null;
                        }
                        result.push(st);
                    } else {
                        outdent = true;
                        lastNonAtLine = st;
                    }
                }
            });
            return result.map(function(line) {
                return "".concat(indent).concat(line, "\n");
            }).join('');
        };
        _proto.captureString = function captureString(limit) {
            var fn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.captureString;
            if (typeof limit === 'function') {
                fn = limit;
                limit = Infinity;
            }
            var stackTraceLimit = Error.stackTraceLimit;
            if (limit) {
                Error.stackTraceLimit = limit;
            }
            var obj = {};
            Error.captureStackTrace(obj, fn);
            var stack = obj.stack;
            Error.stackTraceLimit = stackTraceLimit;
            return this.clean(stack);
        };
        _proto.capture = function capture(limit) {
            var _this = this;
            var fn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.capture;
            if (typeof limit === 'function') {
                fn = limit;
                limit = Infinity;
            }
            var prepareStackTrace = Error.prepareStackTrace, stackTraceLimit = Error.stackTraceLimit;
            Error.prepareStackTrace = function(obj, site) {
                if (_this._wrapCallSite) {
                    return site.map(_this._wrapCallSite);
                }
                return site;
            };
            if (limit) {
                Error.stackTraceLimit = limit;
            }
            var obj = {};
            Error.captureStackTrace(obj, fn);
            var stack = obj.stack;
            Object.assign(Error, {
                prepareStackTrace: prepareStackTrace,
                stackTraceLimit: stackTraceLimit
            });
            return stack;
        };
        _proto.at = function at() {
            var fn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.at;
            var _this_capture = _sliced_to_array(this.capture(1, fn), 1), site = _this_capture[0];
            if (!site) {
                return {};
            }
            var res = {
                line: site.getLineNumber(),
                column: site.getColumnNumber()
            };
            setFile(res, site.getFileName(), this._cwd);
            if (site.isConstructor()) {
                Object.defineProperty(res, 'constructor', {
                    value: true,
                    configurable: true
                });
            }
            if (site.isEval()) {
                res.evalOrigin = site.getEvalOrigin();
            }
            // Node v10 stopped with the isNative() on callsites, apparently
            /* istanbul ignore next */ if (site.isNative()) {
                res.native = true;
            }
            var typename;
            try {
                typename = site.getTypeName();
            } catch (_) {}
            if (typename && typename !== 'Object' && typename !== '[object Object]') {
                res.type = typename;
            }
            var fname = site.getFunctionName();
            if (fname) {
                res.function = fname;
            }
            var meth = site.getMethodName();
            if (meth && fname !== meth) {
                res.method = meth;
            }
            return res;
        };
        _proto.parseLine = function parseLine(line) {
            var match = line && line.match(re);
            if (!match) {
                return null;
            }
            var ctor = match[1] === 'new';
            var fname = match[2];
            var evalOrigin = match[3];
            var evalFile = match[4];
            var evalLine = Number(match[5]);
            var evalCol = Number(match[6]);
            var file = match[7];
            var lnum = match[8];
            var col = match[9];
            var native = match[10] === 'native';
            var closeParen = match[11] === ')';
            var method;
            var res = {};
            if (lnum) {
                res.line = Number(lnum);
            }
            if (col) {
                res.column = Number(col);
            }
            if (closeParen && file) {
                // make sure parens are balanced
                // if we have a file like "asdf) [as foo] (xyz.js", then odds are
                // that the fname should be += " (asdf) [as foo]" and the file
                // should be just "xyz.js"
                // walk backwards from the end to find the last unbalanced (
                var closes = 0;
                for(var i = file.length - 1; i > 0; i--){
                    if (file.charAt(i) === ')') {
                        closes++;
                    } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {
                        closes--;
                        if (closes === -1 && file.charAt(i - 1) === ' ') {
                            var before = file.slice(0, i - 1);
                            var after = file.slice(i + 1);
                            file = after;
                            fname += " (".concat(before);
                            break;
                        }
                    }
                }
            }
            if (fname) {
                var methodMatch = fname.match(methodRe);
                if (methodMatch) {
                    fname = methodMatch[1];
                    method = methodMatch[2];
                }
            }
            setFile(res, file, this._cwd);
            if (ctor) {
                Object.defineProperty(res, 'constructor', {
                    value: true,
                    configurable: true
                });
            }
            if (evalOrigin) {
                res.evalOrigin = evalOrigin;
                res.evalLine = evalLine;
                res.evalColumn = evalCol;
                res.evalFile = evalFile && evalFile.replace(/\\/g, '/');
            }
            if (native) {
                res.native = true;
            }
            if (fname) {
                res.function = fname;
            }
            if (method && fname !== method) {
                res.method = method;
            }
            return res;
        };
        StackUtils.nodeInternals = function nodeInternals() {
            return _to_consumable_array(natives);
        };
        return StackUtils;
    }();
    function setFile(result, filename, cwd) {
        if (filename) {
            filename = filename.replace(/\\/g, '/');
            if (filename.startsWith("".concat(cwd, "/"))) {
                filename = filename.slice(cwd.length + 1);
            }
            result.file = filename;
        }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
        if (ignoredPackages.length === 0) {
            return [];
        }
        var packages = ignoredPackages.map(function(mod) {
            return escapeStringRegexp(mod);
        });
        return new RegExp("[/\\\\]node_modules[/\\\\](?:".concat(packages.join('|'), ")[/\\\\][^:]+:\\d+:\\d+"));
    }
    var re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy
    '(?:\\s*at )?' + // $1 = ctor if 'new'
    '(?:(new) )?' + // $2 = function name (can be literally anything)
    // May contain method at the end as [as xyz]
    '(?:(.*?) \\()?' + // (eval at <anonymous> (file.js:1:1),
    // $3 = eval origin
    // $4:$5:$6 are eval file/line/col, but not normally reported
    '(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?' + // file:line:col
    // $7:$8:$9
    // $10 = 'native' if native
    '(?:(.+?):(\\d+):(\\d+)|(native))' + // maybe close the paren, then end
    // if $11 is ), then we only allow balanced parens in the filename
    // any imbalance is placed on the fname.  This is a heuristic, and
    // bound to be incorrect in some edge cases.  The bet is that
    // having weird characters in method names is more common than
    // having weird characters in filenames, which seems reasonable.
    '(\\)?)$');
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    stackUtils$1 = StackUtils;
    return stackUtils$1;
}
var stackUtilsExports = requireStackUtils();
var StackUtils = /*@__PURE__*/ getDefaultExportFromCjs(stackUtilsExports);
var convertToSpaces = function(input) {
    var spaces = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    return input.replace(/^\t+/gm, function($1) {
        return ' '.repeat($1.length * spaces);
    });
};
var generateLineNumbers = function(line, around) {
    var lineNumbers = [];
    var min = line - around;
    var max = line + around;
    for(var lineNumber = min; lineNumber <= max; lineNumber++){
        lineNumbers.push(lineNumber);
    }
    return lineNumbers;
};
var codeExcerpt = function(source, line) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _a;
    if (typeof source !== 'string') {
        throw new TypeError('Source code is missing.');
    }
    if (!line || line < 1) {
        throw new TypeError('Line number must start from `1`.');
    }
    var lines = convertToSpaces(source).split(/\r?\n/);
    if (line > lines.length) {
        return;
    }
    return generateLineNumbers(line, (_a = options.around) !== null && _a !== void 0 ? _a : 3).filter(function(line) {
        return lines[line - 1] !== undefined;
    }).map(function(line) {
        return {
            line: line,
            value: lines[line - 1]
        };
    });
};
/**
 * `<Box>` is an essential Ink component to build your layout. It's like `<div style="display: flex">` in the browser.
 */ var Box = (0, _react.forwardRef)(function(_param, ref) {
    var children = _param.children, style = _object_without_properties(_param, [
        "children"
    ]);
    var _style_overflowX, _ref, _style_overflowY, _ref1;
    return _react.default.createElement("ink-box", {
        ref: ref,
        style: _object_spread_props(_object_spread({}, style), {
            overflowX: (_ref = (_style_overflowX = style.overflowX) !== null && _style_overflowX !== void 0 ? _style_overflowX : style.overflow) !== null && _ref !== void 0 ? _ref : 'visible',
            overflowY: (_ref1 = (_style_overflowY = style.overflowY) !== null && _style_overflowY !== void 0 ? _style_overflowY : style.overflow) !== null && _ref1 !== void 0 ? _ref1 : 'visible'
        })
    }, children);
});
Box.displayName = 'Box';
Box.defaultProps = {
    flexWrap: 'nowrap',
    flexDirection: 'row',
    flexGrow: 0,
    flexShrink: 1
};
/**
 * This component can display text, and change its style to make it colorful, bold, underline, italic or strikethrough.
 */ function Text(param) {
    var color = param.color, backgroundColor = param.backgroundColor, _param_dimColor = param.dimColor, dimColor = _param_dimColor === void 0 ? false : _param_dimColor, _param_bold = param.bold, bold = _param_bold === void 0 ? false : _param_bold, _param_italic = param.italic, italic = _param_italic === void 0 ? false : _param_italic, _param_underline = param.underline, underline = _param_underline === void 0 ? false : _param_underline, _param_strikethrough = param.strikethrough, strikethrough = _param_strikethrough === void 0 ? false : _param_strikethrough, _param_inverse = param.inverse, inverse = _param_inverse === void 0 ? false : _param_inverse, _param_wrap = param.wrap, wrap = _param_wrap === void 0 ? 'wrap' : _param_wrap, children = param.children;
    if (children === undefined || children === null) {
        return null;
    }
    var transform = function(children) {
        if (dimColor) {
            children = chalk.dim(children);
        }
        if (color) {
            children = colorize(children, color, 'foreground');
        }
        if (backgroundColor) {
            children = colorize(children, backgroundColor, 'background');
        }
        if (bold) {
            children = chalk.bold(children);
        }
        if (italic) {
            children = chalk.italic(children);
        }
        if (underline) {
            children = chalk.underline(children);
        }
        if (strikethrough) {
            children = chalk.strikethrough(children);
        }
        if (inverse) {
            children = chalk.inverse(children);
        }
        return children;
    };
    return _react.default.createElement("ink-text", {
        style: {
            flexGrow: 0,
            flexShrink: 1,
            flexDirection: 'row',
            textWrap: wrap
        },
        internal_transform: transform
    }, children);
}
// Error's source file is reported as file:///home/user/file.js
// This function removes the file://[cwd] part
var cleanupPath = function(path) {
    return path === null || path === void 0 ? void 0 : path.replace("file://".concat((0, _process.cwd)(), "/"), '');
};
var stackUtils = new StackUtils({
    cwd: (0, _process.cwd)(),
    internals: StackUtils.nodeInternals()
});
function ErrorOverview(param) {
    var error = param.error;
    var stack = error.stack ? error.stack.split('\n').slice(1) : undefined;
    var origin = stack ? stackUtils.parseLine(stack[0]) : undefined;
    var filePath = cleanupPath(origin === null || origin === void 0 ? void 0 : origin.file);
    var excerpt;
    var lineWidth = 0;
    if (filePath && (origin === null || origin === void 0 ? void 0 : origin.line) && _fs.existsSync(filePath)) {
        var sourceCode = _fs.readFileSync(filePath, 'utf8');
        excerpt = codeExcerpt(sourceCode, origin.line);
        if (excerpt) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = excerpt[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var line = _step.value.line;
                    lineWidth = Math.max(lineWidth, String(line).length);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    return _react.default.createElement(Box, {
        flexDirection: "column",
        padding: 1
    }, _react.default.createElement(Box, null, _react.default.createElement(Text, {
        backgroundColor: "red",
        color: "white"
    }, ' ', "ERROR", ' '), _react.default.createElement(Text, null, " ", error.message)), origin && filePath && _react.default.createElement(Box, {
        marginTop: 1
    }, _react.default.createElement(Text, {
        dimColor: true
    }, filePath, ":", origin.line, ":", origin.column)), origin && excerpt && _react.default.createElement(Box, {
        marginTop: 1,
        flexDirection: "column"
    }, excerpt.map(function(param) {
        var line = param.line, value = param.value;
        return _react.default.createElement(Box, {
            key: line
        }, _react.default.createElement(Box, {
            width: lineWidth + 1
        }, _react.default.createElement(Text, {
            dimColor: line !== origin.line,
            backgroundColor: line === origin.line ? 'red' : undefined,
            color: line === origin.line ? 'white' : undefined
        }, String(line).padStart(lineWidth, ' '), ":")), _react.default.createElement(Text, {
            key: line,
            backgroundColor: line === origin.line ? 'red' : undefined,
            color: line === origin.line ? 'white' : undefined
        }, ' ' + value));
    })), error.stack && _react.default.createElement(Box, {
        marginTop: 1,
        flexDirection: "column"
    }, error.stack.split('\n').slice(1).map(function(line) {
        var parsedLine = stackUtils.parseLine(line);
        // If the line from the stack cannot be parsed, we print out the unparsed line.
        if (!parsedLine) {
            return _react.default.createElement(Box, {
                key: line
            }, _react.default.createElement(Text, {
                dimColor: true
            }, "- "), _react.default.createElement(Text, {
                dimColor: true,
                bold: true
            }, line));
        }
        var _cleanupPath;
        return _react.default.createElement(Box, {
            key: line
        }, _react.default.createElement(Text, {
            dimColor: true
        }, "- "), _react.default.createElement(Text, {
            dimColor: true,
            bold: true
        }, parsedLine.function), _react.default.createElement(Text, {
            dimColor: true,
            color: "gray"
        }, ' ', "(", (_cleanupPath = cleanupPath(parsedLine.file)) !== null && _cleanupPath !== void 0 ? _cleanupPath : '', ":", parsedLine.line, ":", parsedLine.column, ")"));
    })));
}
var tab = '\t';
var shiftTab = '\u001B[Z';
var escape = '\u001B';
// Root component for all Ink apps
// It renders stdin and stdout contexts, so that children can access them if needed
// It also handles Ctrl+C exiting and cursor visibility
var App = /*#__PURE__*/ function(PureComponent) {
    "use strict";
    _inherits(App, PureComponent);
    function App() {
        _class_call_check(this, App);
        var _this;
        _this = _call_super(this, App, arguments), _this.state = {
            isFocusEnabled: true,
            activeFocusId: undefined,
            focusables: [],
            error: undefined
        }, // Count how many components enabled raw mode to avoid disabling
        // raw mode until all components don't need it anymore
        _this.rawModeEnabledCount = 0, // eslint-disable-next-line @typescript-eslint/naming-convention
        _this.internal_eventEmitter = new _events.EventEmitter(), _this.handleSetRawMode = function(isEnabled) {
            var stdin = _this.props.stdin;
            if (!_this.isRawModeSupported()) {
                if (stdin === _process.default.stdin) {
                    throw new Error('Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported');
                } else {
                    throw new Error('Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported');
                }
            }
            stdin.setEncoding('utf8');
            if (isEnabled) {
                // Ensure raw mode is enabled only once
                if (_this.rawModeEnabledCount === 0) {
                    stdin.ref();
                    stdin.setRawMode(true);
                    stdin.addListener('readable', _this.handleReadable);
                }
                _this.rawModeEnabledCount++;
                return;
            }
            // Disable raw mode only when no components left that are using it
            if (--_this.rawModeEnabledCount === 0) {
                stdin.setRawMode(false);
                stdin.removeListener('readable', _this.handleReadable);
                stdin.unref();
            }
        }, _this.handleReadable = function() {
            var chunk;
            // eslint-disable-next-line @typescript-eslint/ban-types
            while((chunk = _this.props.stdin.read()) !== null){
                _this.handleInput(chunk);
                _this.internal_eventEmitter.emit('input', chunk);
            }
        }, _this.handleInput = function(input) {
            // Exit on Ctrl+C
            // eslint-disable-next-line unicorn/no-hex-escape
            if (input === '\x03' && _this.props.exitOnCtrlC) {
                _this.handleExit();
            }
            // Reset focus when there's an active focused component on Esc
            if (input === escape && _this.state.activeFocusId) {
                _this.setState({
                    activeFocusId: undefined
                });
            }
            if (_this.state.isFocusEnabled && _this.state.focusables.length > 0) {
                if (input === tab) {
                    _this.focusNext();
                }
                if (input === shiftTab) {
                    _this.focusPrevious();
                }
            }
        }, _this.handleExit = function(error) {
            if (_this.isRawModeSupported()) {
                _this.handleSetRawMode(false);
            }
            _this.props.onExit(error);
        }, _this.enableFocus = function() {
            _this.setState({
                isFocusEnabled: true
            });
        }, _this.disableFocus = function() {
            _this.setState({
                isFocusEnabled: false
            });
        }, _this.focus = function(id) {
            _this.setState(function(previousState) {
                var hasFocusableId = previousState.focusables.some(function(focusable) {
                    return (focusable === null || focusable === void 0 ? void 0 : focusable.id) === id;
                });
                if (!hasFocusableId) {
                    return previousState;
                }
                return {
                    activeFocusId: id
                };
            });
        }, _this.focusNext = function() {
            _this.setState(function(previousState) {
                var _previousState_focusables_find;
                var firstFocusableId = (_previousState_focusables_find = previousState.focusables.find(function(focusable) {
                    return focusable.isActive;
                })) === null || _previousState_focusables_find === void 0 ? void 0 : _previousState_focusables_find.id;
                var nextFocusableId = _this.findNextFocusable(previousState);
                return {
                    activeFocusId: nextFocusableId !== null && nextFocusableId !== void 0 ? nextFocusableId : firstFocusableId
                };
            });
        }, _this.focusPrevious = function() {
            _this.setState(function(previousState) {
                var _previousState_focusables_findLast;
                var lastFocusableId = (_previousState_focusables_findLast = previousState.focusables.findLast(function(focusable) {
                    return focusable.isActive;
                })) === null || _previousState_focusables_findLast === void 0 ? void 0 : _previousState_focusables_findLast.id;
                var previousFocusableId = _this.findPreviousFocusable(previousState);
                return {
                    activeFocusId: previousFocusableId !== null && previousFocusableId !== void 0 ? previousFocusableId : lastFocusableId
                };
            });
        }, _this.addFocusable = function(id, param) {
            var autoFocus = param.autoFocus;
            _this.setState(function(previousState) {
                var nextFocusId = previousState.activeFocusId;
                if (!nextFocusId && autoFocus) {
                    nextFocusId = id;
                }
                return {
                    activeFocusId: nextFocusId,
                    focusables: _to_consumable_array(previousState.focusables).concat([
                        {
                            id: id,
                            isActive: true
                        }
                    ])
                };
            });
        }, _this.removeFocusable = function(id) {
            _this.setState(function(previousState) {
                return {
                    activeFocusId: previousState.activeFocusId === id ? undefined : previousState.activeFocusId,
                    focusables: previousState.focusables.filter(function(focusable) {
                        return focusable.id !== id;
                    })
                };
            });
        }, _this.activateFocusable = function(id) {
            _this.setState(function(previousState) {
                return {
                    focusables: previousState.focusables.map(function(focusable) {
                        if (focusable.id !== id) {
                            return focusable;
                        }
                        return {
                            id: id,
                            isActive: true
                        };
                    })
                };
            });
        }, _this.deactivateFocusable = function(id) {
            _this.setState(function(previousState) {
                return {
                    activeFocusId: previousState.activeFocusId === id ? undefined : previousState.activeFocusId,
                    focusables: previousState.focusables.map(function(focusable) {
                        if (focusable.id !== id) {
                            return focusable;
                        }
                        return {
                            id: id,
                            isActive: false
                        };
                    })
                };
            });
        }, _this.findNextFocusable = function(state) {
            var activeIndex = state.focusables.findIndex(function(focusable) {
                return focusable.id === state.activeFocusId;
            });
            for(var index = activeIndex + 1; index < state.focusables.length; index++){
                var focusable = state.focusables[index];
                if (focusable === null || focusable === void 0 ? void 0 : focusable.isActive) {
                    return focusable.id;
                }
            }
            return undefined;
        }, _this.findPreviousFocusable = function(state) {
            var activeIndex = state.focusables.findIndex(function(focusable) {
                return focusable.id === state.activeFocusId;
            });
            for(var index = activeIndex - 1; index >= 0; index--){
                var focusable = state.focusables[index];
                if (focusable === null || focusable === void 0 ? void 0 : focusable.isActive) {
                    return focusable.id;
                }
            }
            return undefined;
        };
        return _this;
    }
    var _proto = App.prototype;
    // Determines if TTY is supported on the provided stdin
    _proto.isRawModeSupported = function isRawModeSupported() {
        return this.props.stdin.isTTY;
    };
    _proto.render = function render() {
        return _react.default.createElement(AppContext.Provider, {
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            value: {
                exit: this.handleExit
            }
        }, _react.default.createElement(StdinContext.Provider, {
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            value: {
                stdin: this.props.stdin,
                setRawMode: this.handleSetRawMode,
                isRawModeSupported: this.isRawModeSupported(),
                // eslint-disable-next-line @typescript-eslint/naming-convention
                internal_exitOnCtrlC: this.props.exitOnCtrlC,
                // eslint-disable-next-line @typescript-eslint/naming-convention
                internal_eventEmitter: this.internal_eventEmitter
            }
        }, _react.default.createElement(StdoutContext.Provider, {
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            value: {
                stdout: this.props.stdout,
                write: this.props.writeToStdout
            }
        }, _react.default.createElement(StderrContext.Provider, {
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            value: {
                stderr: this.props.stderr,
                write: this.props.writeToStderr
            }
        }, _react.default.createElement(FocusContext.Provider, {
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            value: {
                activeId: this.state.activeFocusId,
                add: this.addFocusable,
                remove: this.removeFocusable,
                activate: this.activateFocusable,
                deactivate: this.deactivateFocusable,
                enableFocus: this.enableFocus,
                disableFocus: this.disableFocus,
                focusNext: this.focusNext,
                focusPrevious: this.focusPrevious,
                focus: this.focus
            }
        }, this.state.error ? _react.default.createElement(ErrorOverview, {
            error: this.state.error
        }) : this.props.children)))));
    };
    _proto.componentDidMount = function componentDidMount() {
        cliCursor.hide(this.props.stdout);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        cliCursor.show(this.props.stdout);
        // ignore calling setRawMode on an handle stdin it cannot be called
        if (this.isRawModeSupported()) {
            this.handleSetRawMode(false);
        }
    };
    _proto.componentDidCatch = function componentDidCatch(error) {
        this.handleExit(error);
    };
    App.getDerivedStateFromError = function getDerivedStateFromError(error) {
        return {
            error: error
        };
    };
    return App;
}(_react.PureComponent);
App.displayName = 'InternalApp';
var noop = function() {};
var Ink = /*#__PURE__*/ function() {
    "use strict";
    function Ink(options) {
        var _this = this;
        _class_call_check(this, Ink);
        this.resized = function() {
            _this.calculateLayout();
            _this.onRender();
        };
        this.resolveExitPromise = function() {};
        this.rejectExitPromise = function() {};
        this.unsubscribeExit = function() {};
        this.calculateLayout = function() {
            // The 'columns' property can be undefined or 0 when not using a TTY.
            // In that case we fall back to 80.
            var terminalWidth = _this.options.stdout.columns || 80;
            _this.rootNode.yogaNode.setWidth(terminalWidth);
            _this.rootNode.yogaNode.calculateLayout(undefined, undefined, Yoga$1.DIRECTION_LTR);
        };
        this.onRender = function() {
            if (_this.isUnmounted) {
                return;
            }
            var _renderer = renderer(_this.rootNode), output = _renderer.output, outputHeight = _renderer.outputHeight, staticOutput = _renderer.staticOutput;
            // If <Static> output isn't empty, it means new children have been added to it
            var hasStaticOutput = staticOutput && staticOutput !== '\n';
            if (_this.options.debug) {
                if (hasStaticOutput) {
                    _this.fullStaticOutput += staticOutput;
                }
                _this.options.stdout.write(_this.fullStaticOutput + output);
                return;
            }
            if (isInCi) {
                if (hasStaticOutput) {
                    _this.options.stdout.write(staticOutput);
                }
                _this.lastOutput = output;
                return;
            }
            if (hasStaticOutput) {
                _this.fullStaticOutput += staticOutput;
            }
            if (outputHeight >= _this.options.stdout.rows) {
                _this.options.stdout.write(clearTerminal + _this.fullStaticOutput + output);
                _this.lastOutput = output;
                return;
            }
            // To ensure static output is cleanly rendered before main output, clear main output first
            if (hasStaticOutput) {
                _this.log.clear();
                _this.options.stdout.write(staticOutput);
                _this.log(output);
            }
            if (!hasStaticOutput && output !== _this.lastOutput) {
                _this.throttledLog(output);
            }
            _this.lastOutput = output;
        };
        autoBind(this);
        this.options = options;
        this.rootNode = createNode('ink-root');
        this.rootNode.onComputeLayout = this.calculateLayout;
        this.rootNode.onRender = options.debug ? this.onRender : throttle(this.onRender, 32, {
            leading: true,
            trailing: true
        });
        this.rootNode.onImmediateRender = this.onRender;
        this.log = logUpdate.create(options.stdout);
        this.throttledLog = options.debug ? this.log : throttle(this.log, undefined, {
            leading: true,
            trailing: true
        });
        // Ignore last render after unmounting a tree to prevent empty output before exit
        this.isUnmounted = false;
        // Store last output to only rerender when needed
        this.lastOutput = '';
        // This variable is used only in debug mode to store full static output
        // so that it's rerendered every time, not just new static parts, like in non-debug mode
        this.fullStaticOutput = '';
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.container = reconciler.createContainer(this.rootNode, // Legacy mode
        0, null, false, null, 'id', function() {}, null);
        // Unmount when process exits
        this.unsubscribeExit = signalExit(this.unmount, {
            alwaysLast: false
        });
        if (_process.default.env['DEV'] === 'true') {
            reconciler.injectIntoDevTools({
                bundleType: 0,
                // Reporting React DOM's version, not Ink's
                // See https://github.com/facebook/react/issues/16666#issuecomment-532639905
                version: '16.13.1',
                rendererPackageName: 'ink'
            });
        }
        if (options.patchConsole) {
            this.patchConsole();
        }
        if (!isInCi) {
            options.stdout.on('resize', this.resized);
            this.unsubscribeResize = function() {
                options.stdout.off('resize', _this.resized);
            };
        }
    }
    var _proto = Ink.prototype;
    _proto.render = function render(node) {
        var tree = _react.default.createElement(App, {
            stdin: this.options.stdin,
            stdout: this.options.stdout,
            stderr: this.options.stderr,
            writeToStdout: this.writeToStdout,
            writeToStderr: this.writeToStderr,
            exitOnCtrlC: this.options.exitOnCtrlC,
            onExit: this.unmount
        }, node);
        reconciler.updateContainer(tree, this.container, null, noop);
    };
    _proto.writeToStdout = function writeToStdout(data) {
        if (this.isUnmounted) {
            return;
        }
        if (this.options.debug) {
            this.options.stdout.write(data + this.fullStaticOutput + this.lastOutput);
            return;
        }
        if (isInCi) {
            this.options.stdout.write(data);
            return;
        }
        this.log.clear();
        this.options.stdout.write(data);
        this.log(this.lastOutput);
    };
    _proto.writeToStderr = function writeToStderr(data) {
        if (this.isUnmounted) {
            return;
        }
        if (this.options.debug) {
            this.options.stderr.write(data);
            this.options.stdout.write(this.fullStaticOutput + this.lastOutput);
            return;
        }
        if (isInCi) {
            this.options.stderr.write(data);
            return;
        }
        this.log.clear();
        this.options.stderr.write(data);
        this.log(this.lastOutput);
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
    _proto.unmount = function unmount(error) {
        if (this.isUnmounted) {
            return;
        }
        this.calculateLayout();
        this.onRender();
        this.unsubscribeExit();
        if (typeof this.restoreConsole === 'function') {
            this.restoreConsole();
        }
        if (typeof this.unsubscribeResize === 'function') {
            this.unsubscribeResize();
        }
        // CIs don't handle erasing ansi escapes well, so it's better to
        // only render last frame of non-static output
        if (isInCi) {
            this.options.stdout.write(this.lastOutput + '\n');
        } else if (!this.options.debug) {
            this.log.done();
        }
        this.isUnmounted = true;
        reconciler.updateContainer(null, this.container, null, noop);
        instances.delete(this.options.stdout);
        if (_instanceof(error, Error)) {
            this.rejectExitPromise(error);
        } else {
            this.resolveExitPromise();
        }
    };
    _proto.waitUntilExit = function waitUntilExit() {
        return _async_to_generator(function() {
            var _this;
            return _ts_generator(this, function(_state) {
                _this = this;
                this.exitPromise || (this.exitPromise = new Promise(function(resolve, reject) {
                    _this.resolveExitPromise = resolve;
                    _this.rejectExitPromise = reject;
                }));
                return [
                    2,
                    this.exitPromise
                ];
            });
        }).call(this);
    };
    _proto.clear = function clear() {
        if (!isInCi && !this.options.debug) {
            this.log.clear();
        }
    };
    _proto.patchConsole = function patchConsole1() {
        var _this = this;
        if (this.options.debug) {
            return;
        }
        this.restoreConsole = patchConsole(function(stream, data) {
            if (stream === 'stdout') {
                _this.writeToStdout(data);
            }
            if (stream === 'stderr') {
                var isReactMessage = data.startsWith('The above error occurred');
                if (!isReactMessage) {
                    _this.writeToStderr(data);
                }
            }
        });
    };
    return Ink;
}();
/**
 * Mount a component and render the output.
 */ var render = function(node, options) {
    var inkOptions = _object_spread({
        stdout: _process.default.stdout,
        stdin: _process.default.stdin,
        stderr: _process.default.stderr,
        debug: false,
        exitOnCtrlC: true,
        patchConsole: true
    }, getOptions(options));
    var instance = getInstance(inkOptions.stdout, function() {
        return new Ink(inkOptions);
    });
    instance.render(node);
    return {
        rerender: instance.render,
        unmount: function unmount() {
            instance.unmount();
        },
        waitUntilExit: instance.waitUntilExit,
        cleanup: function() {
            return instances.delete(inkOptions.stdout);
        },
        clear: instance.clear
    };
};
var getOptions = function() {
    var stdout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (_instanceof(stdout, _stream.Stream)) {
        return {
            stdout: stdout,
            stdin: _process.default.stdin
        };
    }
    return stdout;
};
var getInstance = function(stdout, createInstance) {
    var instance = instances.get(stdout);
    if (!instance) {
        instance = createInstance();
        instances.set(stdout, instance);
    }
    return instance;
};
/**
 * `<Static>` component permanently renders its output above everything else.
 * It's useful for displaying activity like completed tasks or logs - things that
 * are not changing after they're rendered (hence the name "Static").
 *
 * It's preferred to use `<Static>` for use cases like these, when you can't know
 * or control the amount of items that need to be rendered.
 *
 * For example, [Tap](https://github.com/tapjs/node-tap) uses `<Static>` to display
 * a list of completed tests. [Gatsby](https://github.com/gatsbyjs/gatsby) uses it
 * to display a list of generated pages, while still displaying a live progress bar.
 */ function Static(props) {
    var items = props.items, render = props.children, customStyle = props.style;
    var _useState = _sliced_to_array((0, _react.useState)(0), 2), index = _useState[0], setIndex = _useState[1];
    var itemsToRender = (0, _react.useMemo)(function() {
        return items.slice(index);
    }, [
        items,
        index
    ]);
    (0, _react.useLayoutEffect)(function() {
        setIndex(items.length);
    }, [
        items.length
    ]);
    var children = itemsToRender.map(function(item, itemIndex) {
        return render(item, index + itemIndex);
    });
    var style = (0, _react.useMemo)(function() {
        return _object_spread({
            position: 'absolute',
            flexDirection: 'column'
        }, customStyle);
    }, [
        customStyle
    ]);
    return _react.default.createElement("ink-box", {
        internal_static: true,
        style: style
    }, children);
}
/**
 * Transform a string representation of React components before they are written to output.
 * For example, you might want to apply a gradient to text, add a clickable link or create some text effects.
 * These use cases can't accept React nodes as input, they are expecting a string.
 * That's what <Transform> component does, it gives you an output string of its child components and lets you transform it in any way.
 */ function Transform(param) {
    var children = param.children, transform = param.transform;
    if (children === undefined || children === null) {
        return null;
    }
    return _react.default.createElement("ink-text", {
        style: {
            flexGrow: 0,
            flexShrink: 1,
            flexDirection: 'row'
        },
        internal_transform: transform
    }, children);
}
/**
 * Adds one or more newline (\n) characters. Must be used within <Text> components.
 */ function Newline(param) {
    var _param_count = param.count, count = _param_count === void 0 ? 1 : _param_count;
    return _react.default.createElement("ink-text", null, '\n'.repeat(count));
}
/**
 * A flexible space that expands along the major axis of its containing layout.
 * It's useful as a shortcut for filling all the available spaces between elements.
 */ function Spacer() {
    return _react.default.createElement(Box, {
        flexGrow: 1
    });
}
// Copied from https://github.com/enquirer/enquirer/blob/36785f3399a41cd61e9d28d1eb9c2fcd73d69b4c/lib/keypress.js
var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
var fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
var keyName = {
    /* xterm/gnome ESC O letter */ OP: 'f1',
    OQ: 'f2',
    OR: 'f3',
    OS: 'f4',
    /* xterm/rxvt ESC [ number ~ */ '[11~': 'f1',
    '[12~': 'f2',
    '[13~': 'f3',
    '[14~': 'f4',
    /* from Cygwin and used in libuv */ '[[A': 'f1',
    '[[B': 'f2',
    '[[C': 'f3',
    '[[D': 'f4',
    '[[E': 'f5',
    /* common */ '[15~': 'f5',
    '[17~': 'f6',
    '[18~': 'f7',
    '[19~': 'f8',
    '[20~': 'f9',
    '[21~': 'f10',
    '[23~': 'f11',
    '[24~': 'f12',
    /* xterm ESC [ letter */ '[A': 'up',
    '[B': 'down',
    '[C': 'right',
    '[D': 'left',
    '[E': 'clear',
    '[F': 'end',
    '[H': 'home',
    /* xterm/gnome ESC O letter */ OA: 'up',
    OB: 'down',
    OC: 'right',
    OD: 'left',
    OE: 'clear',
    OF: 'end',
    OH: 'home',
    /* xterm/rxvt ESC [ number ~ */ '[1~': 'home',
    '[2~': 'insert',
    '[3~': 'delete',
    '[4~': 'end',
    '[5~': 'pageup',
    '[6~': 'pagedown',
    /* putty */ '[[5~': 'pageup',
    '[[6~': 'pagedown',
    /* rxvt */ '[7~': 'home',
    '[8~': 'end',
    /* rxvt keys with modifiers */ '[a': 'up',
    '[b': 'down',
    '[c': 'right',
    '[d': 'left',
    '[e': 'clear',
    '[2$': 'insert',
    '[3$': 'delete',
    '[5$': 'pageup',
    '[6$': 'pagedown',
    '[7$': 'home',
    '[8$': 'end',
    Oa: 'up',
    Ob: 'down',
    Oc: 'right',
    Od: 'left',
    Oe: 'clear',
    '[2^': 'insert',
    '[3^': 'delete',
    '[5^': 'pageup',
    '[6^': 'pagedown',
    '[7^': 'home',
    '[8^': 'end',
    /* misc. */ '[Z': 'tab'
};
var nonAlphanumericKeys = _to_consumable_array(Object.values(keyName)).concat([
    'backspace'
]);
var isShiftKey = function(code) {
    return [
        '[a',
        '[b',
        '[c',
        '[d',
        '[e',
        '[2$',
        '[3$',
        '[5$',
        '[6$',
        '[7$',
        '[8$',
        '[Z'
    ].includes(code);
};
var isCtrlKey = function(code) {
    return [
        'Oa',
        'Ob',
        'Oc',
        'Od',
        'Oe',
        '[2^',
        '[3^',
        '[5^',
        '[6^',
        '[7^',
        '[8^'
    ].includes(code);
};
var parseKeypress = function() {
    var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '';
    var parts;
    if (_buffer.Buffer.isBuffer(s)) {
        if (s[0] > 127 && s[1] === undefined) {
            s[0] -= 128;
            s = '\x1b' + String(s);
        } else {
            s = String(s);
        }
    } else if (s !== undefined && typeof s !== 'string') {
        s = String(s);
    } else if (!s) {
        s = '';
    }
    var key = {
        name: '',
        ctrl: false,
        meta: false,
        shift: false,
        option: false,
        sequence: s,
        raw: s
    };
    key.sequence = key.sequence || s || key.name;
    if (s === '\r') {
        // carriage return
        key.raw = undefined;
        key.name = 'return';
    } else if (s === '\n') {
        // enter, should have been called linefeed
        key.name = 'enter';
    } else if (s === '\t') {
        // tab
        key.name = 'tab';
    } else if (s === '\b' || s === '\x1b\b') {
        // backspace or ctrl+h
        key.name = 'backspace';
        key.meta = s.charAt(0) === '\x1b';
    } else if (s === '\x7f' || s === '\x1b\x7f') {
        // TODO(vadimdemedes): `enquirer` detects delete key as backspace, but I had to split them up to avoid breaking changes in Ink. Merge them back together in the next major version.
        // delete
        key.name = 'delete';
        key.meta = s.charAt(0) === '\x1b';
    } else if (s === '\x1b' || s === '\x1b\x1b') {
        // escape key
        key.name = 'escape';
        key.meta = s.length === 2;
    } else if (s === ' ' || s === '\x1b ') {
        key.name = 'space';
        key.meta = s.length === 2;
    } else if (s.length === 1 && s <= '\x1a') {
        // ctrl+letter
        key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
        key.ctrl = true;
    } else if (s.length === 1 && s >= '0' && s <= '9') {
        // number
        key.name = 'number';
    } else if (s.length === 1 && s >= 'a' && s <= 'z') {
        // lowercase letter
        key.name = s;
    } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
        // shift+letter
        key.name = s.toLowerCase();
        key.shift = true;
    } else if (parts = metaKeyCodeRe.exec(s)) {
        // meta+character key
        key.meta = true;
        key.shift = /^[A-Z]$/.test(parts[1]);
    } else if (parts = fnKeyRe.exec(s)) {
        var segs = _to_consumable_array(s);
        if (segs[0] === '\u001b' && segs[1] === '\u001b') {
            key.option = true;
        }
        // ansi escape sequence
        // reassemble the key code leaving out leading \x1b's,
        // the modifier key bitflag and any meaningless "1;" sequence
        var code = [
            parts[1],
            parts[2],
            parts[4],
            parts[6]
        ].filter(Boolean).join('');
        var modifier = (parts[3] || parts[5] || 1) - 1;
        // Parse the key modifier
        key.ctrl = !!(modifier & 4);
        key.meta = !!(modifier & 10);
        key.shift = !!(modifier & 1);
        key.code = code;
        key.name = keyName[code];
        key.shift = isShiftKey(code) || key.shift;
        key.ctrl = isCtrlKey(code) || key.ctrl;
    }
    return key;
};
/**
 * `useStdin` is a React hook, which exposes stdin stream.
 */ var useStdin = function() {
    return (0, _react.useContext)(StdinContext);
};
/**
 * This hook is used for handling user input.
 * It's a more convenient alternative to using `StdinContext` and listening to `data` events.
 * The callback you pass to `useInput` is called for each character when user enters any input.
 * However, if user pastes text and it's more than one character, the callback will be called only once and the whole string will be passed as `input`.
 *
 * ```
 * import {useInput} from 'ink';
 *
 * const UserInput = () => {
 *   useInput((input, key) => {
 *     if (input === 'q') {
 *       // Exit program
 *     }
 *
 *     if (key.leftArrow) {
 *       // Left arrow key pressed
 *     }
 *   });
 *
 *   return …
 * };
 * ```
 */ var useInput = function(inputHandler) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var _useStdin = useStdin(), stdin = _useStdin.stdin, setRawMode = _useStdin.setRawMode, internal_exitOnCtrlC = _useStdin.internal_exitOnCtrlC, internal_eventEmitter = _useStdin.internal_eventEmitter;
    (0, _react.useEffect)(function() {
        if (options.isActive === false) {
            return;
        }
        setRawMode(true);
        return function() {
            setRawMode(false);
        };
    }, [
        options.isActive,
        setRawMode
    ]);
    (0, _react.useEffect)(function() {
        if (options.isActive === false) {
            return;
        }
        var handleData = function(data) {
            var keypress = parseKeypress(data);
            var key = {
                upArrow: keypress.name === 'up',
                downArrow: keypress.name === 'down',
                leftArrow: keypress.name === 'left',
                rightArrow: keypress.name === 'right',
                pageDown: keypress.name === 'pagedown',
                pageUp: keypress.name === 'pageup',
                return: keypress.name === 'return',
                escape: keypress.name === 'escape',
                ctrl: keypress.ctrl,
                shift: keypress.shift,
                tab: keypress.name === 'tab',
                backspace: keypress.name === 'backspace',
                delete: keypress.name === 'delete',
                // `parseKeypress` parses \u001B\u001B[A (meta + up arrow) as meta = false
                // but with option = true, so we need to take this into account here
                // to avoid breaking changes in Ink.
                // TODO(vadimdemedes): consider removing this in the next major version.
                meta: keypress.meta || keypress.name === 'escape' || keypress.option
            };
            var input = keypress.ctrl ? keypress.name : keypress.sequence;
            if (nonAlphanumericKeys.includes(keypress.name)) {
                input = '';
            }
            // Strip meta if it's still remaining after `parseKeypress`
            // TODO(vadimdemedes): remove this in the next major version.
            if (input.startsWith('\u001B')) {
                input = input.slice(1);
            }
            if (input.length === 1 && typeof input[0] === 'string' && /[A-Z]/.test(input[0])) {
                key.shift = true;
            }
            // If app is not supposed to exit on Ctrl+C, then let input listener handle it
            if (!(input === 'c' && key.ctrl) || !internal_exitOnCtrlC) {
                // @ts-expect-error TypeScript types for `batchedUpdates` require an argument, but React's codebase doesn't provide it and it works without it as exepected.
                reconciler.batchedUpdates(function() {
                    inputHandler(input, key);
                });
            }
        };
        internal_eventEmitter === null || internal_eventEmitter === void 0 ? void 0 : internal_eventEmitter.on('input', handleData);
        return function() {
            internal_eventEmitter === null || internal_eventEmitter === void 0 ? void 0 : internal_eventEmitter.removeListener('input', handleData);
        };
    }, [
        options.isActive,
        stdin,
        internal_exitOnCtrlC,
        inputHandler
    ]);
};
/**
 * `useApp` is a React hook, which exposes a method to manually exit the app (unmount).
 */ var useApp = function() {
    return (0, _react.useContext)(AppContext);
};
/**
 * `useStdout` is a React hook, which exposes stdout stream.
 */ var useStdout = function() {
    return (0, _react.useContext)(StdoutContext);
};
/**
 * `useStderr` is a React hook, which exposes stderr stream.
 */ var useStderr = function() {
    return (0, _react.useContext)(StderrContext);
};
/**
 * Component that uses `useFocus` hook becomes "focusable" to Ink,
 * so when user presses <kbd>Tab</kbd>, Ink will switch focus to this component.
 * If there are multiple components that execute `useFocus` hook, focus will be
 * given to them in the order that these components are rendered in.
 * This hook returns an object with `isFocused` boolean property, which
 * determines if this component is focused or not.
 */ var useFocus = function() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref_isActive = _ref.isActive, isActive = _ref_isActive === void 0 ? true : _ref_isActive, _ref_autoFocus = _ref.autoFocus, autoFocus = _ref_autoFocus === void 0 ? false : _ref_autoFocus, customId = _ref.id;
    var _useStdin = useStdin(), isRawModeSupported = _useStdin.isRawModeSupported, setRawMode = _useStdin.setRawMode;
    var _useContext = (0, _react.useContext)(FocusContext), activeId = _useContext.activeId, add = _useContext.add, remove = _useContext.remove, activate = _useContext.activate, deactivate = _useContext.deactivate, focus = _useContext.focus;
    var id = (0, _react.useMemo)(function() {
        return customId !== null && customId !== void 0 ? customId : Math.random().toString().slice(2, 7);
    }, [
        customId
    ]);
    (0, _react.useEffect)(function() {
        add(id, {
            autoFocus: autoFocus
        });
        return function() {
            remove(id);
        };
    }, [
        id,
        autoFocus
    ]);
    (0, _react.useEffect)(function() {
        if (isActive) {
            activate(id);
        } else {
            deactivate(id);
        }
    }, [
        isActive,
        id
    ]);
    (0, _react.useEffect)(function() {
        if (!isRawModeSupported || !isActive) {
            return;
        }
        setRawMode(true);
        return function() {
            setRawMode(false);
        };
    }, [
        isActive
    ]);
    return {
        isFocused: Boolean(id) && activeId === id,
        focus: focus
    };
};
/**
 * This hook exposes methods to enable or disable focus management for all
 * components or manually switch focus to next or previous components.
 */ var useFocusManager = function() {
    var focusContext = (0, _react.useContext)(FocusContext);
    return {
        enableFocus: focusContext.enableFocus,
        disableFocus: focusContext.disableFocus,
        focusNext: focusContext.focusNext,
        focusPrevious: focusContext.focusPrevious,
        focus: focusContext.focus
    };
};
/**
 * Measure the dimensions of a particular `<Box>` element.
 */ var measureElement = function(node) {
    var _node_yogaNode, _node_yogaNode1;
    var _node_yogaNode_getComputedWidth, _node_yogaNode_getComputedHeight;
    return {
        width: (_node_yogaNode_getComputedWidth = (_node_yogaNode = node.yogaNode) === null || _node_yogaNode === void 0 ? void 0 : _node_yogaNode.getComputedWidth()) !== null && _node_yogaNode_getComputedWidth !== void 0 ? _node_yogaNode_getComputedWidth : 0,
        height: (_node_yogaNode_getComputedHeight = (_node_yogaNode1 = node.yogaNode) === null || _node_yogaNode1 === void 0 ? void 0 : _node_yogaNode1.getComputedHeight()) !== null && _node_yogaNode_getComputedHeight !== void 0 ? _node_yogaNode_getComputedHeight : 0
    };
};

/* CJS INTEROP */ if (exports.__esModule && exports.default) { try { Object.defineProperty(exports.default, '__esModule', { value: true }); for (var key in exports) { exports.default[key] = exports[key]; } } catch (_) { }; module.exports = exports.default; }
